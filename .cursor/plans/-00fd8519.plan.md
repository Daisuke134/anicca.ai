---
name: 緊急バグ修正4件
overview: ""
todos:
  - id: a5e5be8c-9e4d-4810-ad0e-b61951adb8e7
    content: "NotificationScheduler.swift: .caf形式の音声ファイルのみを使用するよう修正"
    status: pending
  - id: 4b1c5bd6-a98a-4103-80cf-707265987748
    content: "HabitsSectionView.swift: withAnimation(.none)を削除"
    status: pending
  - id: a9257451-0252-41b1-bd87-9a2fa6eebd72
    content: "AppState.swift/WakePromptBuilder.swift: カスタム習慣IDに基づく名前取得"
    status: pending
  - id: 7ca152e5-2cc1-4906-82f6-644bb86fe736
    content: "VoiceSessionController.swift: Stickyモードを.wakeのみに限定"
    status: pending
isProject: false
---

# 緊急バグ修正4件

---

## 問題1: ロック画面でTime Sensitive通知の音が鳴らない

### 原因

1. [`NotificationScheduler.swift`](aniccaios/aniccaios/Notifications/NotificationScheduler.swift) 250-258行目の `wakeSound()` 関数でファイル名が `"Defaul"` とタイポされている
2. **致命的問題**: `.mp3` 形式はiOSのUNNotificationSoundでロック画面再生に非対応。Appleドキュメントによると、通知音は `aiff`, `wav`, `caf` 形式のみ対応
3. `AniccaWake.caf` は存在するが、`Defaul.mp3` が先に見つかるため `.caf` にフォールバックしていない

### 修正パッチ

```swift
// NotificationScheduler.swift (250-259行目)
// 修正前:
private func wakeSound() -> UNNotificationSound {
    if Bundle.main.url(forResource: "Defaul", withExtension: "mp3") != nil {
        return UNNotificationSound(named: UNNotificationSoundName("Defaul.mp3"))
    }
    if Bundle.main.url(forResource: "AniccaWake", withExtension: "caf") != nil {
        return UNNotificationSound(named: UNNotificationSoundName("AniccaWake.caf"))
    }
    logger.error("Wake sound missing in bundle; falling back to default alert")
    return .default
}

// 修正後:
private func wakeSound() -> UNNotificationSound {
    // UNNotificationSoundはaiff, wav, caf形式のみ対応（mp3非対応）
    // Appleドキュメント: https://developer.apple.com/documentation/usernotifications/unnotificationsound
    if Bundle.main.url(forResource: "AniccaWake", withExtension: "caf") != nil {
        return UNNotificationSound(named: UNNotificationSoundName("AniccaWake.caf"))
    }
    logger.error("Wake sound AniccaWake.caf missing in bundle; falling back to default alert")
    return .default
}
```

---

## 問題2: 習慣タブのトグルOFF時の変なエフェクト

### 原因

[`HabitsSectionView.swift`](aniccaios/aniccaios/Habits/HabitsSectionView.swift) 324-329行目と380-385行目で `withAnimation(.none)` を使用しているが、これはリストの再描画トランジションを完全に制御できない。SwiftUIの標準的なアプローチに従うべき。

### 修正パッチ

```swift
// HabitsSectionView.swift (324-329行目 habitRow)
// 修正前:
} else {
    // トグルOFF時はAppStateからも削除して永続化（アニメーション無効化）
    withAnimation(.none) {
        activeHabits.remove(habit)
        habitTimes.removeValue(forKey: habit)
    }
    appState.removeHabitSchedule(habit)
}

// 修正後:
} else {
    // トグルOFF時はAppStateからも削除して永続化
    activeHabits.remove(habit)
    habitTimes.removeValue(forKey: habit)
    appState.removeHabitSchedule(habit)
}
```
```swift
// HabitsSectionView.swift (380-385行目 customHabitRow)
// 修正前:
} else {
    // トグルOFF時はAppStateからも削除して永続化（アニメーション無効化）
    withAnimation(.none) {
        activeCustomHabits.remove(id)
        customHabitTimes.removeValue(forKey: id)
    }
    appState.updateCustomHabitSchedule(id: id, time: nil)
}

// 修正後:
} else {
    // トグルOFF時はAppStateからも削除して永続化
    activeCustomHabits.remove(id)
    customHabitTimes.removeValue(forKey: id)
    appState.updateCustomHabitSchedule(id: id, time: nil)
}
```

---

## 問題3: オフにした習慣が「フィードバック」という誤った値でグラウンディングされる

### 原因

1. [`WakePromptBuilder.swift`](aniccaios/aniccaios/WakePromptBuilder.swift) 76-79行目で `CustomHabitStore.shared.displayName()` を使用
2. この関数は `loadAll().first?.name` を返すため、配列の最初のカスタム習慣の名前が返される
3. 実際にトリガーされたカスタム習慣のIDに基づく名前を取得していない

### 修正パッチ

カスタム習慣のIDを `HabitPromptBuilder` に渡す必要があります。

```swift
// AppState.swift - prepareForImmediateSession と handleHabitTrigger の修正
// 新しいメソッドシグネチャを追加

// 修正後 (300-307行目付近):
func prepareForImmediateSession(habit: HabitType, customHabitId: UUID? = nil) {
    pendingConsultPrompt = nil
    let customHabitName = customHabitId.flatMap { id in
        customHabits.first(where: { $0.id == id })?.name
    }
    let prompt = promptBuilder.buildPrompt(for: habit, scheduledTime: habitSchedules[habit], now: Date(), profile: userProfile, customHabitName: customHabitName)
    pendingHabitPrompt = (habit: habit, prompt: prompt)
    pendingHabitTrigger = PendingHabitTrigger(id: UUID(), habit: habit)
    shouldStartSessionImmediately = true
    selectedRootTab = .talk
}

func handleHabitTrigger(_ habit: HabitType, customHabitId: UUID? = nil) {
    pendingConsultPrompt = nil
    let customHabitName = customHabitId.flatMap { id in
        customHabits.first(where: { $0.id == id })?.name
    }
    let prompt = promptBuilder.buildPrompt(for: habit, scheduledTime: habitSchedules[habit], now: Date(), profile: userProfile, customHabitName: customHabitName)
    pendingHabitPrompt = (habit: habit, prompt: prompt)
    pendingHabitTrigger = PendingHabitTrigger(id: UUID(), habit: habit)
}
```
```swift
// WakePromptBuilder.swift - buildPrompt にカスタム習慣名を渡すパラメータ追加

// 修正後 (17行目付近):
func buildPrompt(for habit: HabitType, scheduledTime: DateComponents?, now: Date, profile: UserProfile, customHabitName: String? = nil) -> String {
    // ...
}

// 修正後 (68-80行目付近の taskDescription):
let taskDescription: String
switch habit {
case .wake:
    taskDescription = NSLocalizedString("habit_title_wake", comment: "")
case .training:
    taskDescription = NSLocalizedString("habit_title_training", comment: "")
case .bedtime:
    taskDescription = NSLocalizedString("habit_title_bedtime", comment: "")
case .custom:
    // 渡された名前を優先し、なければフォールバック
    taskDescription = customHabitName ?? CustomHabitStore.shared.displayName(
        fallback: NSLocalizedString("habit_title_custom_fallback", comment: "")
    )
}
```

---

## 問題4: Stickyモードを起床のみに限定する

### 原因

[`VoiceSessionController.swift`](aniccaios/aniccaios/VoiceSessionController.swift) 52-64行目と84-96行目で、`.training` のみを除外しているが、**起床以外のすべての習慣（bedtime、custom）も双方向対話にすべき**。

### 修正パッチ

```swift
// VoiceSessionController.swift (52-64行目)
// 修正前:
// Stickyモードは全習慣に適用（Trainingを除く）
if currentHabitType != nil && currentHabitType != .training && isStickyEnabled {
    stickyActive = true
    stickyUserReplyCount = 0
    stickyReady = false
    logger.info("Sticky enabled for habit: \(String(describing: self.currentHabitType))")
} else {
    stickyActive = false
    stickyUserReplyCount = 0
    stickyReady = false
    if currentHabitType == .training {
        logger.info("Sticky disabled: Training mode is one-way interaction")
    }
}

// 修正後:
// Stickyモードは起床のみに適用
if currentHabitType == .wake && isStickyEnabled {
    stickyActive = true
    stickyUserReplyCount = 0
    stickyReady = false
    logger.info("Sticky enabled for wake habit")
} else {
    stickyActive = false
    stickyUserReplyCount = 0
    stickyReady = false
    if currentHabitType == .training {
        logger.info("Sticky disabled: Training mode is one-way interaction")
    } else if currentHabitType != nil && currentHabitType != .wake {
        logger.info("Sticky disabled: bidirectional dialog for non-wake habits")
    }
}
```
```swift
// VoiceSessionController.swift (84-96行目 startFromVoip内)
// 修正前:
// Stickyモードは全習慣に適用（Trainingを除く）
if habit != .training && isStickyEnabled {
    stickyActive = true
    stickyUserReplyCount = 0
    stickyReady = false
    logger.info("Sticky enabled for VoIP habit: \(String(describing: habit))")
} else {
    stickyActive = false
    stickyUserReplyCount = 0
    stickyReady = false
    if habit == .training {
        logger.info("Sticky disabled: Training mode is one-way interaction")
    }
}

// 修正後:
// Stickyモードは起床のみに適用
if habit == .wake && isStickyEnabled {
    stickyActive = true
    stickyUserReplyCount = 0
    stickyReady = false
    logger.info("Sticky enabled for VoIP wake habit")
} else {
    stickyActive = false
    stickyUserReplyCount = 0
    stickyReady = false
    if habit == .training {
        logger.info("Sticky disabled: Training mode is one-way interaction")
    } else if habit != .wake {
        logger.info("Sticky disabled: bidirectional dialog for non-wake habits")
    }
}
```

---

## 影響範囲

| 修正 | ファイル | 影響 |

|------|---------|------|

| 問題1 | `NotificationScheduler.swift` | 通知音がロック画面で正しく再生される |

| 問題2 | `HabitsSectionView.swift` | トグルOFF時の変なアニメーションが消える |

| 問題3 | `AppState.swift`, `WakePromptBuilder.swift` | カスタム習慣のグラウンディング値が正しくなる |

| 問題4 | `VoiceSessionController.swift` | 起床以外は双方向対話になる |