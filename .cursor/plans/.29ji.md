以下は実装せずに記述するための完全な修正案。必要箇所に上書きして利用すること。

---

### 1) AlarmKitビルドエラー修正（`Alarm`に`configuration`なし / `secondary`を`let`化）
```diff
// aniccaios/aniccaios/Notifications/AlarmKitHabitCoordinator.swift

@@ func scheduleHabit(...)
-        var secondary = StartConversationIntent()
+        let secondary = StartConversationIntent()

@@ func cancelHabitAlarms(_ habit: HabitType) async
-        // Alarm.attributesは直接参照できないため、configuration経由でアクセス
-        if let metadata = alarm.configuration.attributes?.metadata as? HabitAlarmMetadata,
-           metadata.habit == habit.rawValue {
-            try manager.cancel(id: alarm.id)
-        }
-        // Alarmはconfigurationを直接持たないため、永続化IDのみで突合
-        if persistedIds.contains(alarm.id) {
-            try manager.cancel(id: alarm.id)
-        } else {
-            logger.debug("Skipping non-habit alarm \(alarm.id)")
-        }
+        // Alarmはconfigurationを直接持たないため、永続化IDのみで突合
+        if persistedIds.contains(alarm.id) {
+            try manager.cancel(id: alarm.id)
+        } else {
+            logger.debug("Skipping non-habit alarm \(alarm.id)")
+        }
```

---

### 2) アラーム音を常に先頭8秒だけ再生＆再生条件を絞る
```diff
// aniccaios/aniccaios/Notifications/AlarmKitHabitCoordinator.swift

@@ @MainActor private func playAlarmSoundInApp()
-        audioPlayer = try AVAudioPlayer(contentsOf: soundURL)
-        audioPlayer?.prepareToPlay()
-        audioPlayer?.play()
+        // フルスクリーンアラームを使う習慣はAlarmKit UIに任せ、ここでは鳴らさない
+        guard shouldPlayInApp(for: currentHabit) else { return }

+        audioPlayer = try AVAudioPlayer(contentsOf: soundURL)
+        audioPlayer?.prepareToPlay()
+        audioPlayer?.currentTime = 0
+        audioPlayer?.play()

+        // 先頭8秒で強制停止
+        Task { [weak self] in
+            try? await Task.sleep(nanoseconds: 8_000_000_000)
+            self?.audioPlayer?.stop()
+        }
```
※ `shouldPlayInApp(for:)` は「Full Screen Alarm OFF かつサイレント解除時のみ再生」などの条件判定を入れる想定のヘルパー。

---

### 3) 残留アラーム問題 - 「Skipping non-habit alarm」の意味と真の解決策

**ログの意味**: 「Skipping non-habit alarm」は**正常な動作**です。
- wakeの習慣をキャンセルする時、trainingやbedtimeのアラームIDはスキップされる（正常）
- **問題点**: 過去のアプリバージョンで登録されたが、UserDefaultsに永続化されなかったIDがあると、どの習慣のキャンセルでも引っかからず永遠に残る

**真の解決策**: 全習慣のpersisted IDを合わせた「既知ID」以外のアラームを強制キャンセル

```diff
// aniccaios/aniccaios/Notifications/AlarmKitHabitCoordinator.swift

@@ func cancelHabitAlarms(_ habit: HabitType) async {
     let persistedIds = loadPersistedIds(for: habit)
+    // 全習慣の既知IDを集める
+    let allKnownIds: Set<UUID> = Set(HabitType.allCases.flatMap { loadPersistedIds(for: $0) })
     
     do {
         let currentAlarms = try manager.alarms
         for alarm in currentAlarms {
             if persistedIds.contains(alarm.id) {
                 try manager.cancel(id: alarm.id)
+            } else if !allKnownIds.contains(alarm.id) {
+                // どの習慣にも属さない孤児アラーム → 強制キャンセル
+                logger.warning("Cancelling orphan alarm \(alarm.id.uuidString) not in any habit")
+                try manager.cancel(id: alarm.id)
             } else {
-                logger.debug("Skipping non-habit alarm \(alarm.id.uuidString)")
+                logger.debug("Skipping alarm \(alarm.id.uuidString) - belongs to other habit")
             }
         }
     }
```

---

### 4) Stickyモードが喋り続けない問題 - **重大なバグ発見！**

**原因**: OpenAI Realtime APIのイベント名が間違っています。

**正しいイベント名**（公式SDKで確認済み）:
- `conversation.item.done`（ユーザー発話完了）
- `response.done`（アシスタント応答完了）
- ※ `conversation.item.completed` や `response.completed` は**存在しない**

**なぜカウントが0のままなのか**: `conversation.item.completed`というイベントはOpenAI Realtime APIに存在しないため、そのcaseに入らず、カウントが増えていなかった。

```diff
// aniccaios/aniccaios/VoiceSessionController.swift

@@ private func handleRealtimeEvent(_ event: [String: Any])
-    case "conversation.item.completed":
+    case "conversation.item.done":
         guard stickyActive else { return }
         if
             let item = event["item"] as? [String: Any],
             let role = item["role"] as? String,
             role == "user"
         {
             self.stickyUserReplyCount += 1
-            logger.info("Sticky reply \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold) from user")
-            if self.stickyUserReplyCount >= stickyReleaseThreshold {
-                stickyActive = false
-                logger.info("Sticky mode released after \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold) replies - session now free")
-            }
+            logger.info("Sticky \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold): user replied")
+            print("Sticky \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold): user replied")
+            if self.stickyUserReplyCount >= stickyReleaseThreshold {
+                stickyActive = false
+                logger.info("Sticky released at \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold)")
+                print("Sticky released at \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold)")
+            }
         }
-    case "response.completed":
+    case "response.done":
         if stickyActive {
-            logger.info("Sticky \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold): response.completed received, triggering next response")
+            logger.info("Sticky \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold): response.done → trigger next")
+            print("Sticky \(self.stickyUserReplyCount)/\(self.stickyReleaseThreshold): response.done → trigger next")
            sendWakeResponseCreate()
         }
     default:
         break
     }
```

■ optional: 最初の音声開始でゲートを開ける（desktopに近い挙動）
```diff
// VoiceSessionController.swift （Sticky用のゲート）
+    private var stickyReady = false

@@ func start(...)
     if currentHabitType != nil && isStickyEnabled {
         stickyActive = true
         stickyUserReplyCount = 0
+        stickyReady = false
     }

@@ private func handleRealtimeEvent(_ event: [String: Any])
     switch type {
+    case "output_audio_buffer.started":
+        if stickyActive && !stickyReady {
+            stickyReady = true
+            logger.info("Sticky ready: first audio started")
+            print("Sticky ready: first audio started")
+        }
     case "conversation.item.done":
-        guard stickyActive else { return }
+        guard stickyActive && stickyReady else { return }
        ...
```

---

### 5) StickyログをXcodeでも確実に可視化
```diff
// VoiceSessionController.swift の Sticky関連ログ
logger.info("Sticky ...")
print("Sticky ...") // Xcodeコンソールでも見える
```

---

### 6) CFBundleVersion不一致（拡張と親アプリを揃える）
```diff
// 例: aniccaios/aniccaios/AlarmKitExtension/Info.plist
- <key>CFBundleVersion</key>
- <string>1</string>
+ <key>CFBundleVersion</key>
+ <string>$(CURRENT_PROJECT_VERSION)</string>

// 例: aniccaios/aniccaios/NotificationServiceExtension/Info.plist も同様に
```
- 親アプリと同じ `CURRENT_PROJECT_VERSION` を参照させてビルド番号を一致させる。

---

---

## まとめ

| 問題 | 原因 | 修正 |
|------|------|------|
| Skipping non-habit alarm | 正常動作だが孤児IDが残る | 全習慣に属さないIDを強制キャンセル |
| Sticky 0/10のまま | **イベント名が間違い** | `response.completed`→`response.done`、`conversation.item.completed`→`conversation.item.done` |
| カウント増えない | 存在しないイベントをリッスン | 上記と同じ |

**最重要修正**: イベント名の修正だけでStickyモードは動き出すはずです。

---

以上を実装すれば:
- AlarmKitビルドエラー/警告解消（configuration誤参照の排除、let化）
- アラーム音8秒制限と再生条件の整理
- 残留アラームの孤児ID強制キャンセルで過去時刻発火を抑止
- Stickyモード: 正しいイベント名でカウントし、連続発話が途切れない・ログも見える
- CFBundleVersion不一致の解消