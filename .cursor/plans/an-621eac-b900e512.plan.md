<!-- b900e512-8429-4a54-a403-f7b1ee0ab4d4 fa7d2a9c-6b5c-47f1-95f4-ae0eabe40d39 -->
# 実装計画（疑似パッチ付き）

### ゴール

- 起床/就寝はデフォルト5回、その他（トレーニング/カスタム）は2回のフォローアップ通知へ変更。全習慣で「時刻＋フォローアップ回数(1-10)」を編集可能に。
- ローカライズ不具合を修正（Training詳細の日本語混在、Sign Out、メインボタン文言）。
- Manage Plan → Customer Center の言語をユーザー設定に追従、Refundの要件整理。
- `aniccaai.com` の Privacy / Support を英日対応（/en, /ja）。
- `Resources/Prompts/common.txt` を行動変容・話速・理想の姿活用に最適化。

---

### 1) 通知：フォローアップ回数を習慣別に可変化（デフォルト適用）

- 既存: `NotificationScheduler.AlarmLoop.repeatCount = 10` 固定
- 変更: AppStateに回数設定を保持（wake/bedtime=5、training/custom=2）。Scheduler は AppState から取得。
- カスタム習慣もスケジュール対象に（UUID単位）。

疑似パッチ（抜粋）:

```diff
*** aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@
-    private enum AlarmLoop {
-        /// 8秒サウンド + 2秒休止 = 10秒ごとに再通知
-        static let intervalSeconds = 10
-        /// メイン通知のあとに繰り返すサウンド付き通知の最大回数
-        static let repeatCount = 10
-    }
+    private enum AlarmLoop {
+        /// 8秒サウンド + 2秒休止 = 10秒ごとに再通知
+        static let intervalSeconds = 10
+    }
+
+    private func repeatCount(for habit: HabitType) -> Int {
+        return AppState.shared.followupCount(for: habit)
+    }
@@C
-    /// メイン通知の 0 秒起点から 10 秒間隔で最大 10 個のサウンド付きフォローアップを登録
+    /// メイン通知の 0 秒起点から 10 秒間隔で AppState 設定回数ぶんのフォローアップを登録
     private func scheduleFollowupLoop(for habit: HabitType, baseComponents: DateComponents) {
@@
-            for index in 1...AlarmLoop.repeatCount {
+            for index in 1...repeatCount(for: habit) {
                 guard let fireDate = Calendar.current.date(
                     byAdding: .second,
-                    value: index * AlarmLoop.intervalSeconds,
+                    value: index * AlarmLoop.intervalSeconds,
                     to: firstFireDate
                 ) else { continue }
@@
     }
+
+    // MARK: - Custom Habit (UUID) support
+    func applyCustomSchedules(_ schedules: [UUID: (name: String, time: DateComponents)]) async {
+        // いったん全カスタムの pending/delivered を掃除（簡易実装）
+        await removePending(withPrefix: "HABIT_CUSTOM_MAIN_")
+        await removePending(withPrefix: "HABIT_CUSTOM_FOLLOW_")
+        await removeDelivered(withPrefix: "HABIT_CUSTOM_FOLLOW_")
+        for (id, entry) in schedules {
+            await scheduleCustomMain(id: id, name: entry.name, time: entry.time)
+            scheduleCustomFollowups(id: id, name: entry.name, baseComponents: entry.time)
+        }
+    }
+
+    private func scheduleCustomMain(id: UUID, name: String, time: DateComponents) async {
+        let trigger = UNCalendarNotificationTrigger(dateMatching: time, repeats: true)
+        let req = UNNotificationRequest(
+            identifier: keyCustomMain(id: id, time: time),
+            content: customBaseContent(name: name, isFollowup: false),
+            trigger: trigger
+        )
+        try? await center.add(req)
+    }
+
+    private func scheduleCustomFollowups(id: UUID, name: String, baseComponents: DateComponents) {
+        Task {
+            await removePending(withPrefix: keyCustomFollowPrefix(id: id))
+            await removeDelivered(withPrefix: keyCustomFollowPrefix(id: id))
+            guard let first = nextFireDate(from: baseComponents) else { return }
+            let repeats = AppState.shared.customFollowupCount(for: id)
+            for index in 1...max(1, min(10, repeats)) {
+                guard let fireDate = Calendar.current.date(byAdding: .second, value: index * AlarmLoop.intervalSeconds, to: first) else { continue }
+                let comps = Calendar.current.dateComponents([.year,.month,.day,.hour,.minute,.second], from: fireDate)
+                let trig = UNCalendarNotificationTrigger(dateMatching: comps, repeats: false)
+                let req = UNNotificationRequest(
+                    identifier: keyCustomFollow(id: id, ts: Int(fireDate.timeIntervalSince1970)),
+                    content: customBaseContent(name: name, isFollowup: true),
+                    trigger: trig
+                )
+                try? await center.add(req)
+            }
+        }
+    }
+
+    private func customBaseContent(name: String, isFollowup: Bool) -> UNMutableNotificationContent {
+        let c = UNMutableNotificationContent()
+        c.title = isFollowup ? String(format: localizedString("notification_custom_followup_title_format"), name) : name
+        c.body  = isFollowup ? String(format: localizedString("notification_custom_followup_body_format"), name) : String(format: localizedString("notification_custom_body_format"), name)
+        c.categoryIdentifier = Category.habitAlarm.rawValue
+        c.interruptionLevel = .timeSensitive
+        c.sound = wakeSound()
+        return c
+    }
+
+    private func keyCustomMain(id: UUID, time: DateComponents) -> String { "HABIT_CUSTOM_MAIN_\(id.uuidString)" }
+    private func keyCustomFollow(id: UUID, ts: Int) -> String { "HABIT_CUSTOM_FOLLOW_\(id.uuidString)_\(ts)" }
+    private func keyCustomFollowPrefix(id: UUID) -> String { "HABIT_CUSTOM_FOLLOW_\(id.uuidString)_" }
```

---

### 2) AppState：回数設定の保持・保存・再スケジュール

疑似パッチ（抜粋）:

```diff
*** aniccaios/aniccaios/AppState.swift
@@
     @Published private(set) var habitSchedules: [HabitType: DateComponents] = [:]
+    @Published private(set) var habitFollowupCounts: [HabitType: Int] = [:]
+    @Published private(set) var customHabitFollowupCounts: [UUID: Int] = [:]
@@
-    private let onboardingKey = "com.anicca.onboardingComplete"
+    private let onboardingKey = "com.anicca.onboardingComplete"
+    private let followupCountsKey = "com.anicca.followupCounts"
+    private let customFollowupCountsKey = "com.anicca.customFollowupCounts"
@@
     private init() {
@@
-        // Load habit schedules (new format)
+        // Load habit schedules (new format)
         if let data = defaults.data(forKey: habitSchedulesKey),
@@
         }
+
+        // Load followup counts (with defaults)
+        loadFollowupCounts()
@@
-        Task {
-            await scheduler.applySchedules(habitSchedules)
-        }
+        Task { await scheduler.applySchedules(habitSchedules) }
+        Task { await applyCustomSchedulesToScheduler() }
@@
     func updateHabit(_ habit: HabitType, time: Date) async {
@@
-        await scheduler.applySchedules(habitSchedules)
+        await scheduler.applySchedules(habitSchedules)
     }
@@
     func updateCustomHabitSchedule(id: UUID, time: DateComponents?) {
@@
-        Task {
-            await updateHabitNotifications()
-        }
+        Task { await applyCustomSchedulesToScheduler() }
     }
+
+    // MARK: Followups
+    func followupCount(for habit: HabitType) -> Int {
+        if let n = habitFollowupCounts[habit] { return bounded(n) }
+        return defaultFollowupCount(for: habit)
+    }
+    func customFollowupCount(for id: UUID) -> Int {
+        return bounded(customHabitFollowupCounts[id] ?? 2)
+    }
+    func updateFollowupCount(for habit: HabitType, count: Int) {
+        habitFollowupCounts[habit] = bounded(count)
+        saveFollowupCounts()
+        Task { await scheduler.applySchedules(habitSchedules) }
+    }
+    func updateCustomFollowupCount(id: UUID, count: Int) {
+        customHabitFollowupCounts[id] = bounded(count)
+        saveCustomFollowupCounts()
+        Task { await applyCustomSchedulesToScheduler() }
+    }
+    private func defaultFollowupCount(for habit: HabitType) -> Int {
+        switch habit { case .wake, .bedtime: return 5; default: return 2 }
+    }
+    private func bounded(_ n: Int) -> Int { max(1, min(10, n)) }
+
+    private func loadFollowupCounts() {
+        if let data = defaults.data(forKey: followupCountsKey),
+           let dict = try? JSONDecoder().decode([String:Int].self, from: data) {
+            habitFollowupCounts = dict.compactMapKeys { HabitType(rawValue: $0) }
+        } else {
+            habitFollowupCounts = [.wake: 5, .bedtime: 5, .training: 2, .custom: 2]
+        }
+        if let data = defaults.data(forKey: customFollowupCountsKey),
+           let dict = try? JSONDecoder().decode([String:Int].self, from: data) {
+            customHabitFollowupCounts = dict.compactMapKeys { UUID(uuidString: $0) }
+        }
+    }
+    private func saveFollowupCounts() {
+        let enc = habitFollowupCounts.mapKeys { $0.rawValue }
+        if let data = try? JSONEncoder().encode(enc) { defaults.set(data, forKey: followupCountsKey) }
+    }
+    private func saveCustomFollowupCounts() {
+        let enc = customHabitFollowupCounts.mapKeys { $0.uuidString }
+        if let data = try? JSONEncoder().encode(enc) { defaults.set(data, forKey: customFollowupCountsKey) }
+    }
+    private func applyCustomSchedulesToScheduler() async {
+        var payload: [UUID:(String, DateComponents)] = [:]
+        for h in customHabits {
+            if let t = customHabitSchedules[h.id] { payload[h.id] = (h.name, t) }
+        }
+        await scheduler.applyCustomSchedules(payload)
+    }
```

---

### 3) 習慣UI：全習慣で「時刻＋回数」を編集（カスタム含む）

- 既存の `HabitEditSheet` に「再通知回数」セクションを追加（1〜10）。
- カスタム習慣は `CustomHabitEditSheet` を新設し、同様に編集可能。
- Training詳細の「回数で計測/時間で計測」をローカライズキーに置換。
- `HabitTrainingFocusStepView.swift` も同様にローカライズキーに置換。

疑似パッチ（抜粋）:

```diff
*** aniccaios/aniccaios/Habits/HabitsSectionView.swift
@@
 enum SheetRoute: Identifiable {
@@
-    case editor(HabitType)
+    case editor(HabitType)
+    case customEditor(UUID)
@@
-            case .editor(let h):
+            case .editor(let h):
                 HabitEditSheet(habit: h, onSave: {
                     // 保存後に習慣時刻を再読み込み
                     loadHabitTimes()
                 })
                 .environmentObject(appState)
+            case .customEditor(let id):
+                CustomHabitEditSheet(customId: id) { loadHabitTimes() }
+                .environmentObject(appState)
@@
-            .onTapGesture {
-                if isActive {
-                    sheetTime = date ?? Date()
-                    activeSheet = .custom(id)
-                }
-            }
+            .onTapGesture { if isActive { activeSheet = .customEditor(id) } }
@@
-                        if option.id == "Push-up" || option.id == "Core" {
-                            Text("回数で計測")
+                        if option.id == "Push-up" || option.id == "Core" {
+                            Text(String(localized: "training_measure_reps"))
                                .font(.caption)
                                .foregroundStyle(.secondary)
+                        } else if option.id == "Cardio" || option.id == "Stretch" {
+                            Text(String(localized: "training_measure_time"))
                                .font(.caption)
                                .foregroundStyle(.secondary)
                         }
@@
 struct HabitEditSheet: View {
@@
-    @Environment(\.dismiss) private var dismiss
+    @Environment(\.dismiss) private var dismiss
+    @State private var followups: Int = 2
@@
     var body: some View {
@@
         Form {
             // Time（全習慣共通）
             Section {
                 DatePicker(String(localized: "common_time"), selection: $time, displayedComponents: [.hourAndMinute])
             }
+            // Follow-ups（全習慣共通）
+            Section(String(localized: "followup_repeats_title")) {
+                Stepper(value: $followups, in: 1...10) {
+                    Text("\(followups) \(String(localized: \"followup_times_unit\"))")
+                }
+                Text(String(localized: "followup_repeats_help")).font(.footnote).foregroundStyle(.secondary)
+            }
@@
-        .onAppear {
-            load()
-        }
+        .onAppear { load(); followups = appState.followupCount(for: habit) }
@@
     private func save() {
         // 時刻を保存
         Task {
             await appState.updateHabit(habit, time: time)
+            appState.updateFollowupCount(for: habit, count: followups)
             // 保存後にコールバックを呼び出し
             await MainActor.run { onSave?() }
         }
@@
 }
+
+struct CustomHabitEditSheet: View {
+    @EnvironmentObject private var appState: AppState
+    @Environment(\.dismiss) private var dismiss
+    let customId: UUID
+    let onSave: () -> Void
+    @State private var time = Date()
+    @State private var followups: Int = 2
+    var body: some View {
+        NavigationView {
+            Form {
+                Section { DatePicker(String(localized: "common_time"), selection: $time, displayedComponents: [.hourAndMinute]) }
+                Section(String(localized: "followup_repeats_title")) {
+                    Stepper(value: $followups, in: 1...10) { Text("\(followups) \(String(localized: \"followup_times_unit\"))") }
+                    Text(String(localized: "followup_repeats_help")).font(.footnote).foregroundStyle(.secondary)
+                }
+            }
+            .navigationTitle(appState.customHabits.first(where: { $0.id == customId })?.name ?? String(localized: "habit_title_custom_fallback"))
+            .toolbar {
+                ToolbarItem(placement: .cancellationAction) { Button(String(localized: "common_cancel")) { dismiss() } }
+                ToolbarItem(placement: .confirmationAction) { Button(String(localized: "common_save")) { save() } }
+            }
+        }
+        .onAppear {
+            if let comps = appState.customHabitSchedules[customId], let d = Calendar.current.date(from: comps) { time = d }
+            followups = appState.customFollowupCount(for: customId)
+        }
+    }
+    private func save() {
+        appState.updateCustomHabitSchedule(id: customId, time: Calendar.current.dateComponents([.hour,.minute], from: time))
+        appState.updateCustomFollowupCount(id: customId, count: followups)
+        Task { await MainActor.run { onSave(); dismiss() } }
+    }
+}
```

追加修正: `HabitTrainingFocusStepView.swift` も同様に修正

```diff
*** aniccaios/aniccaios/Onboarding/HabitTrainingFocusStepView.swift
@@
                                 if option.id == "Push-up" || option.id == "Core" {
-                                    Text("回数で計測")
+                                    Text(String(localized: "training_measure_reps"))
                                         .font(.caption)
                                         .foregroundStyle(.secondary)
                                 } else if option.id == "Cardio" || option.id == "Stretch" {
-                                    Text("時間で計測")
+                                    Text(String(localized: "training_measure_time"))
                                         .font(.caption)
                                         .foregroundStyle(.secondary)
                                 }
```

---

### 4) ローカライズ修正・追加

- Training詳細の計測文言をローカライズ。
- 日本語の Sign Out 表記が `common_sign_out` 未定義のため英語に落ちる問題を修正。
- メインボタン文言を英語版「Consult Anicca」に変更。

疑似パッチ（抜粋）:

```diff
*** aniccaios/aniccaios/Resources/en.lproj/Localizable.strings
@@
-"session_button_talk" = "Talk to Anicca";
+"session_button_talk" = "Consult Anicca";
+"training_measure_reps" = "Measured by reps";
+"training_measure_time" = "Measured by time";
+"followup_repeats_title" = "Reminder repeats";
+"followup_repeats_help" = "Re-alert every 10s, 1–10 times.";
+"followup_times_unit" = "times";
+"settings_contact_support" = "Contact support";
@@
 "common_sign_out" = "Sign Out";
```
```diff
*** aniccaios/aniccaios/Resources/ja.lproj/Localizable.strings
@@
-"session_button_talk" = "Anicca と話す";
+"session_button_talk" = "Aniccaに相談する";
+"training_measure_reps" = "回数で計測";
+"training_measure_time" = "時間で計測";
+"followup_repeats_title" = "再通知回数";
+"followup_repeats_help" = "10秒ごとに再通知。1〜10回から選択。";
+"followup_times_unit" = "回";
+"common_sign_out" = "サインアウト";
```

---

### 5) Customer Center 言語＆Refund要件

- Customer Center のロケールを `AppState.userProfile.preferredLanguage` に合わせる。
- サポートリンクも言語別に遷移。

疑似パッチ:

```diff
*** aniccaios/aniccaios/Views/ManageSubscriptionSheet.swift
@@
-        .sheet(isPresented: $showingCustomerCenter) {
-            RevenueCatUI.CustomerCenterView()
-                .environment(\.locale, .autoupdatingCurrent)
+        .sheet(isPresented: $showingCustomerCenter) {
+            RevenueCatUI.CustomerCenterView()
+                .environment(\.locale, Locale(identifier: appState.userProfile.preferredLanguage.rawValue))
@@
-            Link(destination: URL(string: "https://aniccaai.com/support")!) {
-                Text("Contact support")
+            Link(destination: supportURL) {
+                Text(String(localized: "settings_contact_support"))
             }
         }
     }
+    
+    private var supportURL: URL {
+        let lang = appState.userProfile.preferredLanguage.rawValue
+        return URL(string: "https://aniccaai.com/support/\(lang)")!
+    }
```

Refundについて（ドキュメント要旨）:

- Customer Center の “Refund Request (iOS only)” はAppleの返金UIを表示。追加実装は不要（RevenueCatの設定で有効化し、必要ならフィードバック/プロモオファー設定）
- “Cannot connect. Retry” は多くの場合「端末が返金APIに接続できない / 該当購入がない / 環境がシミュレータ・サンドボックス未整備」などが原因。
  - 実機・Sandbox/本番の有効な購入が必要
  - Apple App Store Server Notifications を設定（返金のハンドリングに必要）
  - RevenueCatダッシュボードの “Handling of refund requests” 設定を確認
  - 参考: Customer Center Config / Handling Refund Requests（RevCat docs）

---

### 6) 法務リンク：言語別遷移

疑似パッチ:

```diff
*** aniccaios/aniccaios/Views/LegalLinksView.swift
@@
 struct LegalLinksView: View {
     var body: some View {
         VStack(spacing: 8) {
-            Link(String(localized: "legal_privacy_policy"), destination: URL(string: "https://aniccaai.com/privacy")!)
+            Link(String(localized: "legal_privacy_policy"), destination: privacyURL)
             Link(String(localized: "legal_terms_of_use"), destination: URL(string: "https://www.apple.com/legal/internet-services/itunes/dev/stdeula/")!)
         }
         .font(.footnote)
         .foregroundColor(.secondary)
         .multilineTextAlignment(.center)
         .padding(.vertical, 8)
         .frame(maxWidth: .infinity)
         .background(.ultraThinMaterial)
     }
+    
+    private var privacyURL: URL {
+        let lang = AppState.shared.userProfile.preferredLanguage.rawValue
+        return URL(string: "https://aniccaai.com/privacy/\(lang)")!
+    }
```

---

### 7) メイン画面ボタン文言

- 文字列変更のみ（4)で対応済み）。UI変更なし。

---

### 8) 理想の姿（Ideal Traits）：9個に整理＆ローカライズ表示

- トークンは英語固定（保存用）にし、表示はローカライズ。
- 候補: kind, altruistic, confident, mindful, optimistic, resilient, disciplined, honest, calm

疑似パッチ（抜粋）:

```diff
*** aniccaios/aniccaios/SettingsView.swift
@@
-    private let idealTraitOptions = [
-        "confident", "empathetic", "gentle", "optimistic", "creative",
-        "energetic", "calm", "assertive", "motivational", "supportive",
-        "direct", "encouraging", "analytical", "patient", "friendly", "professional"
-    ]
+    private let idealTraitOptions = [
+        "kind","altruistic","confident","mindful","optimistic","resilient","disciplined","honest","calm"
+    ]
@@
-        Button(action: {
+        Button(action: {
             var traits = appState.userProfile.idealTraits
             if isSelected {
                 traits.removeAll { $0 == trait }
             } else {
                 traits.append(trait)
             }
             appState.updateIdealTraits(traits)
         }) {
-            Text(trait)
+            Text(LocalizedStringKey("ideal_trait_\(trait)"))
```

文字列追加:

```diff
*** en.lproj/Localizable.strings
+"settings_ideal_traits" = "Ideal self";
+"ideal_trait_kind" = "Kind";
+"ideal_trait_altruistic" = "Altruistic";
+"ideal_trait_confident" = "Confident";
+"ideal_trait_mindful" = "Mindful";
+"ideal_trait_optimistic" = "Optimistic";
+"ideal_trait_resilient" = "Resilient";
+"ideal_trait_disciplined" = "Disciplined";
+"ideal_trait_honest" = "Honest";
+"ideal_trait_calm" = "Calm";
```
```diff
*** ja.lproj/Localizable.strings
+"settings_ideal_traits" = "理想の姿";
+"ideal_trait_kind" = "やさしさ";
+"ideal_trait_altruistic" = "利他性";
+"ideal_trait_confident" = "自信";
+"ideal_trait_mindful" = "マインドフル";
+"ideal_trait_optimistic" = "楽観性";
+"ideal_trait_resilient" = "レジリエンス";
+"ideal_trait_disciplined" = "規律性";
+"ideal_trait_honest" = "誠実";
+"ideal_trait_calm" = "落ち着き";
```

---

### 9) プロンプト: `Resources/Prompts/common.txt` 改善

- 理想の姿と行動の接続、話速の明示、能動的リードを明文化。

疑似パッチ（差分のみ）:

```diff
*** aniccaios/aniccaios/Resources/Prompts/common.txt
@@
-${IDEAL_TRAITS}が理想の姿として設定されている場合、これらの特性を意識して話すこと。
+${IDEAL_TRAITS}が理想の姿として設定されている場合、これらの特性を意識して話すこと。
+特にユーザーが行動に苦労しているときは、理想の姿を明確に引き合いに出し、
+「あなたは◯◯（理想の特性）になりたい。そのために今この一歩（現在の行動）が大切」
+と、理想と現在の行動を結びつけて前進を促すこと。
+
+【話し方】常に落ち着いたテンポで、できる限りゆったり話す。早口にならない。
+各フレーズの間に短い間を置き、余裕のある声で、安心感を与えるトーンで話す。
+
+【役割】あなたの目的は、ユーザーが理想の自分に近づくよう行動変容を導くこと。
+ユーザーの指示待ちではなく、あなたが主体的にリードし、可能性を信じて手を取り前へ進める。
+必要な提案や次の一歩は、あなたから先に提示してよい。
@@
-以下の声掛けを、絶対に${LANGUAGE_LINE}の言葉で行うこと。絶対に他の言葉は喋らないこと。指示通りに。 
+以下の声掛けを、絶対に${LANGUAGE_LINE}の言葉で行うこと。絶対に他の言葉は喋らないこと。指示通りに。
```

---

### 10) Web: Privacy / Support を英日対応に

- `/privacy/en` と `/privacy/ja` を追加し、`/privacy` は言語自動判定でリダイレクト。
- `/support` も同様に対応。

疑似パッチ（抜粋）:

```diff
*** apps/landing/app/privacy/page.tsx
@@
-export const metadata = { title: 'プライバシーポリシー | Anicca' };
-
-export default function PrivacyPage() {
-  return (/* ...日本語本文... */)
-}
+import { headers } from 'next/headers'
+import { redirect } from 'next/navigation'
+export const metadata = { title: 'Privacy | Anicca' }
+export default function PrivacyIndex() {
+  const accept = headers().get('accept-language') || ''
+  const lang = accept.startsWith('ja') ? 'ja' : 'en'
+  redirect(`/privacy/${lang}`)
+}
```

新規追加：

```diff
*** Add: apps/landing/app/privacy/en/page.tsx
+export const metadata = { title: 'Privacy Policy | Anicca' };
+export default function PrivacyEN() { return (<main className="container mx-auto max-w-3xl px-4 py-24">{/* English content */}</main>); }
```
```diff
*** Add: apps/landing/app/privacy/ja/page.tsx
+export const metadata = { title: 'プライバシーポリシー | Anicca' };
+export default function PrivacyJA() { return (<main className="container mx-auto max-w-3xl px-4 py-24">{/* 既存の日本語本文を移設 */}</main>); }
```

Support も同様:

```diff
*** apps/landing/app/support/page.tsx
@@
-export const metadata = {
-  title: 'Support | Anicca',
-  description: 'Get help with Anicca - your voice-powered habit formation coach'
-};
-
-export default function SupportPage() {
-  return (/* 英語本文 */)
-}
+import { headers } from 'next/headers'
+import { redirect } from 'next/navigation'
+export const metadata = { title: 'Support | Anicca' }
+export default function SupportIndex() {
+  const accept = headers().get('accept-language') || ''
+  const lang = accept.startsWith('ja') ? 'ja' : 'en'
+  redirect(`/support/${lang}`)
+}
```
```diff
*** Add: apps/landing/app/support/en/page.tsx
+export const metadata = { title: 'Support | Anicca' };
+export default function SupportEN() { return (<main className="container mx-auto max-w-3xl px-4 py-24">{/* existing EN content */}</main>); }
```
```diff
*** Add: apps/landing/app/support/ja/page.tsx
+export const metadata = { title: 'サポート | Anicca' };
+export default function SupportJA() { return (<main className="container mx-auto max-w-3xl px-4 py-24">{/* 日本語版コンテンツ */}</main>); }
```

---

### UIの変化（ドット図）

- 習慣（Settings → Habits）
  - Wake/Training/Sleep/Custom をタップ
    - → ● Habit Edit Sheet
      - ● Time (DatePicker)
      - ● Reminder repeats (Stepper 1–10)
      - ● Save / Cancel
- カスタム習慣
  - 有効な行をタップ
    - → ● Custom Habit Edit Sheet（上記と同じ構成、タイトルは習慣名）
- Settings → Manage plan → Customer Center
  - → ● Customer Center（言語=ユーザー設定）
    - ● Change Plans（iOS）
    - ● Refund Request（iOS, Apple標準UI）
- メイン画面
  - ● ボタン文言（英）: “Consult Anicca”
  - ● （日）: “Aniccaに相談する”
- 設定 → サインアウト（日本語）
  - ● “サインアウト” と表示
- 法務リンク
  - ● Privacy → `https://aniccaai.com/privacy/{en|ja}`
  - ● Support → `https://aniccaai.com/support/{en|ja}`

---

### 検証ポイント

- Wake/Bedtimeデフォルト5回、Training/Customデフォルト2回でスケジュールされる。
- 回数を1–10で変更して保存 → 次回スケジュールに反映。
- Training詳細の計測ラベルが英語環境で英語表示。
- 日本語環境の Sign Out が日本語表示。
- Manage Plan → Customer Center の表示言語がユーザー設定に一致。
- Refund Request は実機＋有効な購入で Apple UI が表示（シミュレータや未購入では“Cannot connect”になり得る）。
- Privacy/Support が /en /ja に遷移。

---

### 補足（Refund要件の要約）

- 必須: 実機 / 購入履歴（60日以内） / Appleアカウント / ネットワーク。
- 推奨: Apple App Store Server Notifications の設定、RevenueCatの「Handling of refund requests」有効化・方針設定、必要に応じて Customer Center のフィードバック/プロモオファー設定。

### To-dos

- [ ] 習慣別フォローアップ回数の実装（Scheduler + AppState）
- [ ] HabitEditSheet/CustomEditorに回数セクション追加
- [ ] Training計測ラベル・SignOut・主ボタンの文言修正
- [ ] Customer Centerのロケールとサポートリンクを言語別に
- [ ] common.txtの行動変容／話速／能動誘導の追記
- [ ] Privacy/Supportの/en・/jaページ追加とリダイレクト
- [ ] 理想の姿の9項目定義とローカライズ表示