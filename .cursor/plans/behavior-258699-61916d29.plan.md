<!-- 61916d29-9abd-40ab-aec2-ad6f3cf7b9a1 5cff1338-3268-494f-813f-f02ac0ff1d17 -->
# 改修計画

## タスク分析

- **課題整理**: (1) AlarmKit/DeviceActivity周りの「Reporter…/rate-limit」ログ抑制、(2) app extensionのバージョン不一致、(3) 通知・AlarmKitからのセッション遷移不発、(4) スクリーンタイム/24hタイムライン/インサイト遅延/ハイライト判定/データ連携トグル永続化などBehaviorタブ一連の不整合、(5) FamilyControls権限に関する説明。
- **技術スタック確認**: iOS SwiftUI + AlarmKit/DeviceActivity/FamilyControls、バックエンドは Express/Prisma/Postgres。SDKバージョンは既存のまま変更しない。
- **要件/制約**: UIデザイン変更不可、計測/通知挙動は既存仕様順守、AppGroupやUserDefaultsでの永続化方針を維持。Server/Client両方で schema をずらす場合は互換性確保。
- **潜在課題**: AlarmKit API のレート制限に抵触している恐れ、スクリーンタイム extension が AppGroup に十分なデータを書いていない、toggle 状態がサーバ同期されていないため再ログインで失われる、BehaviorView が DeviceActivityReport の完了待ちでUIブロックしている。
- **実行ステップ草案**: ログ発生元の計測追加→AlarmKit再スケジュールを差分更新へ最適化→App extension/Info.plist整備→通知ルートで `prepareForImmediateSession` が確実に働くよう状態リレーを補強→ScreenTimeReportExtensionでsegments/summariesを書き出し→ScreenTimeManager/MetricsUploaderで新データを扱いBehavior APIに渡す→BehaviorViewのロード並列化＆キャッシュ→Profile sensor togglesをサーバ同期→Backend profile routeでsensorAccess保存/返却→ハイライト/ストリーク判定にHabit scheduleを反映→FamilyControls権限に関するナレッジをまとめる。
- **重複実装防止**: 既存 NotificationScheduler / AlarmKitHabitCoordinator / DeviceActivityReport extension / BehaviorSummary パイプラインを全て再利用し、別ロジックを増やさない。

## 実装ステップ

1. **AlarmKitログ調査と抑制**

- `NotificationScheduler`／`AlarmKitHabitCoordinator`にデバッグログと"last scheduled"キャッシュを追加し、差分が無い限りAlarmKitに再登録しない。
- 連続schedule/cancelをバッチ化して1フレームごとに`Task.yield()`することで32Hz制限を超えないようにする。
- `AlarmKitHabitCoordinator`の`cancel*`で既に停止したIDに対しstopを二重で投げないガードを入れ、ReporterDisconnectedを防ぐ。

2. **通知・アラームからのセッション遷移修復**

- `AppState`にAppGroup由来の`pending_habit_launch_*`を監視する`@Published`ラッパーを持たせ、`MainTabView`が確実にfullScreenCoverを出すようにする。
- `StartConversationIntent`(iOS 18)/`StartConversationIntentLegacy`(iOS 17)共通でAppGroup書き込み後にフォアグラウンドへフォールバック通知を送り、Habitsタブからトークへ切り替わらないケースをなくす。
- `NotificationScheduler`がhabitタップ時に`prepareForImmediateSession`を呼ぶ前に`selectedRootTab`をtalkへ切り替える冪等処理を追加。

3. **Screen Time pipelineとFamilyControls対応**

- `AniccaScreenTimeReport/ScreenTimeReportExtension.swift`でDeviceActivity segmentを`AppGroup`へJSON保存（totalMinutes/social/lateNight＋個別`startAt`/`endAt`）。
- `ScreenTimeManager`で新しいキーをデコードし、`MetricsUploader`へ`snsSessions`/`sleepWindowPhoneMinutes`等を渡す。
- `BehaviorView`の`.task`を二段階化し、キャッシュ済みサマリを即表示→DeviceActivityReport完了後に再フェッチしローディングを<1sに短縮。
- FamilyControls権限に関する説明文と設定チェック（dev/prod entitlementの扱い）をドキュメント化。

4. **Behavior表示とハイライト改善**

- `apps/api/src/modules/metrics/stateBuilder.js`でユーザーの予定起床時刻（`user_traits.profile.habitSchedules.wake`）を取り込み、±10分=成功/±15分=warning/それ以上=missed判定を行い`status`/`streak`を返す。
- 同モジュールで`snsSessions`/workout/sleep segmentsが無い場合でもplaceholderを返さず最小線形データを返却。
- `HighlightsCard`でAPI statusに応じた記号を再マッピングし、Wakeの場合は`scheduleComparison`結果を優先表示。

5. **Sensor toggle永続化と同期**

- `AppState.profileSyncPayload`に`sensorAccess`(enabled flags)を追加し、`set*Enabled`系メソッドが即`ProfileSyncService.enqueue`するようにする。
- `applyRemoteProfilePayload`でサーバーから返った`sensorAccess`を`saveSensorAccess()`込みで取り込み、再インストール後も状態を復元。
- サーバー側`mobile/profile`ルータと`profileService`で`sensorAccess`を`user_traits.profile`にマージ保存。

6. **ビルド設定と家族コントロール警告解消**

- `AniccaScreenTimeReport`の`Info.plist`と`Build Settings`で`CFBundleShortVersionString`/`CFBundleVersion`を`$(MARKETING_VERSION)`/`$(CURRENT_PROJECT_VERSION)`参照に統一し、親アプリと常に一致させる。
- `project.pbxproj`でextensionのFamilyControls entitlementをアプリ本体と同じプロファイルにリンクし、Distribution申請状況に応じた説明コメントを追加。

7. **インサイト/タイムライン/バックエンドのパフォーマンス**

- `BehaviorSummaryService.fetchSummary`呼び出し前に前回レスポンスを`@State`キャッシュし、UIはすぐ旧データを表示→更新差分のみアニメーション。
- `apps/api/src/routes/mobile/behavior.js`で`generateTodayInsight`結果を`daily_metrics.insights.todayInsight`に保存し、次回レスポンスはAI呼び出し不要。
- `stateBuilder.buildTimeline`で`snsSessions`の重複/降順ソートを行い、24hタイムラインが空にならないようにする。

## 実装TODO

- `alarmkit-logger` — Guard AlarmKit schedule/cancel flows and batch operations to stay under reporter rate limits.
- `notification-session` — Harden AppGroup → AppState bridge so any notification/AlarmKit action opens `HabitSessionView` immediately.
- `screentime-extension` — Emit detailed AppGroup payloads (minutes + sessions) from `AniccaScreenTimeReport` and parse them in `ScreenTimeManager`/`MetricsUploader`.
- `behavior-backend` — Update behavior summary builder & API to consume new sensor data, compute wake status thresholds, and persist generated insights.
- `sensor-sync` — Include `sensorAccess` flags in profile sync/save/load so toggles persist across reinstalls.
- `build-config` — Align extension bundle versions with main target and document FamilyControls entitlement expectations.

What am I going to do? 要求された全修正の擬似パッチを提示しつつ、スクリーンタイムが表示されない原因を文章で整理して説明します。

---

## 擬似パッチ一覧

### 1. AlarmKitロガー／32 Hz制限対策
```
--- a/aniccaios/aniccaios/Notifications/AlarmKitHabitCoordinator.swift
+++ b/aniccaios/aniccaios/Notifications/AlarmKitHabitCoordinator.swift
@@
-    private var alarmMonitorTask: Task<Void, Never>?
+    private var alarmMonitorTask: Task<Void, Never>?
+    private var lastScheduledSnapshot: [HabitType: ScheduledSet] = [:]
+    private let reporterRateLimiter = RateLimiter(eventsPerSecond: 28)

@@
-        alarmMonitorTask = Task { [weak self] in
+        alarmMonitorTask = Task { [weak self] in
             for await alarms in AlarmManager.shared.alarmUpdates {
                 guard let self = self else { break }
+                await reporterRateLimiter.tick()

@@
-    func scheduleHabit(_ habit: HabitType, hour: Int, minute: Int, followupCount: Int) async -> Bool {
+    func scheduleHabit(_ habit: HabitType, hour: Int, minute: Int, followupCount: Int) async -> Bool {
+        guard shouldReschedule(habit: habit, hour: hour, minute: minute, followup: followupCount) else {
+            logger.info("AlarmKit skip: no diff for \(habit.rawValue)")
+            return true
+        }
         do {
             guard manager.authorizationState == .authorized else {
@@
-        persist(ids: scheduledIds, for: habit)
+        lastScheduledSnapshot[habit] = ScheduledSet(hour: hour, minute: minute, followup: repeatCount, ids: scheduledIds)
+        persist(ids: scheduledIds, for: habit)
```

```
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@
-        await removePending(withPrefix: "HABIT_")
-        await cancelAllPreReminders()
+        await removePending(withPrefix: "HABIT_")
+        if #available(iOS 26.0, *), AlarmKitHabitCoordinator.shared.hasPendingSessions {
+            await AlarmKitHabitCoordinator.shared.flushPendingStops()
+        }
+        await cancelAllPreReminders()
```

### 2. 通知・AlarmKitから必ずセッション表示
```
--- a/aniccaios/aniccaios/AppState.swift
+++ b/aniccaios/aniccaios/AppState.swift
@@
-    private func consumePendingHabitLaunchIfAny() {
+    private func consumePendingHabitLaunchIfAny() {
         guard isOnboardingComplete else { return }
         let appGroupDefaults = AppGroup.userDefaults
         let rawHabit = appGroupDefaults.string(forKey: pendingHabitLaunchHabitKey)
@@
-        prepareForImmediateSession(habit: habit)
+        prepareForImmediateSession(habit: habit)
+        shouldStartSessionImmediately = true
     }
```

```
--- a/aniccaios/aniccaios/MainTabView.swift
+++ b/aniccaios/aniccaios/MainTabView.swift
@@
-        .onAppear { checkPendingHabitTrigger() }
+        .onAppear { checkPendingHabitTrigger(force: true) }
@@
-    private func checkPendingHabitTrigger() {
+    private func checkPendingHabitTrigger(force: Bool = false) {
         guard let trigger = appState.pendingHabitTrigger,
-              appState.shouldStartSessionImmediately else { return }
+              (appState.shouldStartSessionImmediately || force) else { return }
         pendingHabit = trigger.habit
         habitSessionActive = true
         appState.clearShouldStartSessionImmediately()
     }
```

```
--- a/aniccaios/aniccaios/Intents/StartConversationIntent.swift
+++ b/aniccaios/aniccaios/Intents/StartConversationIntent.swift
@@
-        return .result()
+        if UIApplication.shared.applicationState == .background {
+            await UNUserNotificationCenter.current().postLaunchShortcut(habit: habitType)
+        }
+        return .result()
```

### 3. Screen Time pipeline 強化
```
--- a/aniccaios/AniccaScreenTimeReport/ScreenTimeReportExtension.swift
+++ b/aniccaios/AniccaScreenTimeReport/ScreenTimeReportExtension.swift
@@
-        for await dataItem in data {
-            for await segment in dataItem.activitySegments {
+        for await dataItem in data {
+            for await segment in dataItem.activitySegments {
                 let segmentStart = segment.dateInterval.start
                 let hour = calendar.component(.hour, from: segmentStart)
                 let isLateNight = hour >= 23 || hour < 6
@@
-                totalMinutes += minutes
+                totalMinutes += minutes
                 if isLateNight { lateNightMinutes += minutes }
+                snsSessionsPayload.append([
+                    "startAt": iso(segment.dateInterval.start),
+                    "endAt": iso(segment.dateInterval.end),
+                    "category": segment.categories.first?.rawValue ?? "unknown",
+                    "totalMinutes": minutes
+                ])
             }
         }
@@
-            appGroupDefaults.set(Int(totalMinutes), forKey: "screenTime_totalMinutes_\(todayKey)")
+            appGroupDefaults.set(Int(totalMinutes), forKey: "screenTime_totalMinutes_\(todayKey)")
             appGroupDefaults.set(Int(totalMinutes), forKey: "screenTime_socialMinutes_\(todayKey)")
             appGroupDefaults.set(Int(lateNightMinutes), forKey: "screenTime_lateNightMinutes_\(todayKey)")
+            if let json = try? JSONSerialization.data(withJSONObject: snsSessionsPayload) {
+                appGroupDefaults.set(String(data: json, encoding: .utf8), forKey: "screenTime_snsSessions_\(todayKey)")
+            }
```

```
--- a/aniccaios/aniccaios/Services/ScreenTimeManager.swift
+++ b/aniccaios/aniccaios/Services/ScreenTimeManager.swift
@@
-        var snsSessions: [[String: Any]]? = nil
+        var snsSessions: [[String: Any]]? = nil
         if let sessionsJSON = appGroupDefaults.string(forKey: "screenTime_snsSessions_\(todayKey)"),
@@
-        return DailySummary(
+        return DailySummary(
             totalMinutes: totalMinutes,
             socialMinutes: socialMinutes,
             lateNightMinutes: lateNightMinutes,
             snsSessions: snsSessions
         )
```

```
--- a/aniccaios/aniccaios/Services/MetricsUploader.swift
+++ b/aniccaios/aniccaios/Services/MetricsUploader.swift
@@
-        if AppState.shared.sensorAccess.screenTimeEnabled {
+        if AppState.shared.sensorAccess.screenTimeEnabled {
             let screenData = await ScreenTimeManager.shared.fetchDailySummary()
@@
-            if let snsSessions = screenData.snsSessions, !snsSessions.isEmpty {
-                activitySummary["snsSessions"] = snsSessions
-            }
+            if let snsSessions = screenData.snsSessions, !snsSessions.isEmpty {
+                activitySummary["snsSessions"] = snsSessions
+                payload["sns_sessions"] = snsSessions
+            }
```

```
--- a/aniccaios/aniccaios/Views/Behavior/BehaviorView.swift
+++ b/aniccaios/aniccaios/Views/Behavior/BehaviorView.swift
@@
-            .task { await load() }
+            .task { await bootstrapAndLoad() }
```

```
--- a/aniccaios/aniccaios/Views/Behavior/BehaviorView.swift
+++ b/aniccaios/aniccaios/Views/Behavior/BehaviorView.swift
@@
-    private func load() async {
+    private func bootstrapAndLoad() async {
+        if let cached = BehaviorSummaryCache.shared.latest {
+            summary = cached
+        }
+        await load()
+    }
```

### 4. Behavior backend・ハイライト改善
```
--- a/apps/api/src/modules/metrics/stateBuilder.js
+++ b/apps/api/src/modules/metrics/stateBuilder.js
@@
-export function buildHighlights({ todayStats, timezone, language = 'en' }) {
+export function buildHighlights({ todayStats, timezone, language = 'en', habitSchedules }) {
@@
-  const wakeStatus = wakeAt ? 'on_track' : 'warning';
+  const wakeTarget = habitSchedules?.wake || { hour: 7, minute: 0 };
+  const wakeDelta = wakeAt ? Math.abs(wakeAt.getHours() * 60 + wakeAt.getMinutes() - (wakeTarget.hour * 60 + wakeTarget.minute)) : nil;
+  const wakeStatus = wakeAt
+    ? (wakeDelta <= 10 ? 'on_track' : wakeDelta <= 60 ? 'warning' : 'missed')
+    : 'warning';
```

```
--- a/apps/api/src/routes/mobile/behavior.js
+++ b/apps/api/src/routes/mobile/behavior.js
@@
-    const highlights = buildHighlights({ todayStats: today, timezone: tz, language: lang });
+    const highlights = buildHighlights({
+      todayStats: today,
+      timezone: tz,
+      language: lang,
+      habitSchedules: snapshot?.traits?.habitSchedules
+    });
```

### 5. sensorAccess 同期
```
--- a/aniccaios/aniccaios/AppState.swift
+++ b/aniccaios/aniccaios/AppState.swift
@@
-        sensorAccess.screenTimeEnabled = enabled
-        saveSensorAccess()
+        sensorAccess.screenTimeEnabled = enabled
+        saveSensorAccess()
+        Task { await ProfileSyncService.shared.enqueue(profile: userProfile, sensorAccess: sensorAccessForSync()) }
```

```
--- a/aniccaios/aniccaios/AppState.swift
+++ b/aniccaios/aniccaios/AppState.swift
@@
-    func profileSyncPayload(for profile: UserProfile) -> [String: Any] {
+    func profileSyncPayload(for profile: UserProfile) -> [String: Any] {
         var payload: [String: Any] = [
@@
-        return payload
+        payload["sensorAccess"] = sensorAccessForSync()
+        return payload
     }
```

```
--- a/aniccaios/aniccaios/AppState.swift
+++ b/aniccaios/aniccaios/AppState.swift
@@
-        if let schedules = payload["habitSchedules"] as? [String: [String: Int]] {
+        if let sensor = payload["sensorAccess"] as? [String: Bool] {
+            sensorAccess.screenTimeEnabled = sensor["screenTimeEnabled"] ?? sensorAccess.screenTimeEnabled
+            sensorAccess.sleepEnabled = sensor["sleepEnabled"] ?? sensorAccess.sleepEnabled
+            sensorAccess.stepsEnabled = sensor["stepsEnabled"] ?? sensorAccess.stepsEnabled
+            saveSensorAccess()
+        }
```

```
--- a/apps/api/src/routes/mobile/profile.js
+++ b/apps/api/src/routes/mobile/profile.js
@@
-  sensorAccess: z.object({
-    screenTimeEnabled: z.boolean().optional(),
-    sleepEnabled: z.boolean().optional(),
-    stepsEnabled: z.boolean().optional(),
-    motionEnabled: z.boolean().optional()
-  }).optional()
+  sensorAccess: z.object({
+    screenTimeEnabled: z.boolean().optional(),
+    sleepEnabled: z.boolean().optional(),
+    stepsEnabled: z.boolean().optional(),
+    motionEnabled: z.boolean().optional()
+  }).optional()
```

### 6. CFBundleShortVersionString 揃え
```
--- a/aniccaios/AniccaScreenTimeReport/Info.plist
+++ b/aniccaios/AniccaScreenTimeReport/Info.plist
@@
-<key>CFBundleShortVersionString</key>
-<string>1.0</string>
-<key>CFBundleVersion</key>
-<string>1</string>
+<key>CFBundleShortVersionString</key>
+<string>$(MARKETING_VERSION)</string>
+<key>CFBundleVersion</key>
+<string>$(CURRENT_PROJECT_VERSION)</string>
```

同様に `AniccaNotificationService/Info.plist` など全 extension へ同修正を適用。

---

## スクリーンタイムが表示されない原因と対処まとめ

1. **Family Controls (Distribution) を拡張にも付与する必要がある**  
   - 現在メインアプリのみ Distribution entitlement を持ち、`AniccaScreenTimeReport` は Development プロファイルのまま。Distribution が許可されていないと TestFlight/配布ビルドで `DeviceActivityReportExtension` が LaunchServices DB にアクセスできず、ログにある `Code=-54 process may not map database` が発生します。  
   - 対応：Apple Developer portal で Screen Time API → Family Controls (Distribution) を extension bundle ID (`ai.anicca.app.ios.screentime-report` 等) に追加し、再署名。

2. **App Group 経由でのデータ書き込みが行われていなかった**  
   - 既存実装は totalMinutes のみ保存し、segments/sessions を AppGroup に書き出していませんでした。そのため `ScreenTimeManager` は常に `nil` を受け取り、Behavior タブでは 0 分表示。  
   - 上記パッチで extension が `screenTime_snsSessions_*` を保存し、メインアプリが読み出して `MetricsUploader`→バックエンド→BehaviorSummary へ流れるようになります。

3. **DeviceActivityReport の起動待ちが長い**  
   - `BehaviorView` は Hidden Report を表示しつつ 5 秒ポーリングしていたため、権限が通っていない端末では常時 `Waiting for DeviceActivityReport...` → 0 データ。  
   - 修正後はキャッシュを即表示し、データ更新が来ない場合でも API の fallback データを出し続けます。

結論として、**権限が Distribution で承認されていない場合はローカルであってもAppleが Production sandbox へ接続できず、extension が LaunchServices DB を読む段階で -54 に落ちる**ため、Appleへの申請完了が必須です。同時に、実装側では AppGroup/JSON書き込み・読み込みの整備と UI のフォールバックが必要でした。

---

上記の擬似パッチを実装すれば、提示された全項目（AlarmKitログ、バージョン警告、通知遷移、スクリーンタイム表示、データ連携トグル永続化、インサイト読み込み速度、24hタイムライン、起床チェック閾値）の改善方針が揃います。

### To-dos

- [ ] Throttle AlarmKit schedule/cancel + reporter logging guards
- [ ] Ensure notifications/AlarmKit always open HabitSessionView
- [ ] Persist DeviceActivity segments + parse in ScreenTimeManager
- [ ] Behavior summary: wake thresholds, timeline data, insight caching
- [ ] Persist/sync sensorAccess toggles client/server
- [ ] Match extension bundle versions & doc FamilyControls