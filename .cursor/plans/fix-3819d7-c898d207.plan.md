<!-- c898d207-ff9f-4812-b178-05677bcf6c4c 863e23c3-d29c-487f-b47c-cc2c8563144b -->
# Anicca iOS: Habitsトグル不具合修正 + JWT確認/強化 + アカウント削除確実化

## 要点

- Habits行のトグルで行が“消える/飛ぶ”挙動を修正（重複表示とタップ伝播が原因）。
- JWTは実装済み。iOSは`/auth/apple`でAT/RTを受領し保存、ネットワーク層でBearer付与（ただし一部直書きリクエストは未付与）。
- アカウント削除はサーバ側できちんと実データ削除＋RevenueCat購買者削除まで実装済み。iOS側は削除成功後にログアウト→ウェルカムへ遷移。

## 変更点（疑似パッチ）

### 1) Habits画面（`aniccaios/aniccaios/Habits/HabitsSectionView.swift`）

- 非アクティブ判定を「アクティブ集合」ではなく「時刻未設定」に変更（重複行の発生を防止）。
- 行全体の`onTapGesture`がトグルタップにも反応しないよう、タップ領域を左ラベル部に限定。
```diff
--- a/aniccaios/aniccaios/Habits/HabitsSectionView.swift
+++ b/aniccaios/aniccaios/Habits/HabitsSectionView.swift
@@
-    private var inactiveDefaultHabits: [HabitType] {
-        [HabitType.wake, .training, .bedtime].filter { !activeHabits.contains($0) }
-    }
+    private var inactiveDefaultHabits: [HabitType] {
+        // “未設定（時刻が無い）”を非アクティブとして扱う
+        [HabitType.wake, .training, .bedtime].filter { habit in
+            appState.habitSchedules[habit] == nil && habitTimes[habit] == nil
+        }
+    }
@@
-    private var inactiveCustomHabits: [CustomHabitConfiguration] {
-        appState.customHabits.filter { !activeCustomHabits.contains($0.id) }
-    }
+    private var inactiveCustomHabits: [CustomHabitConfiguration] {
+        // カスタムも“未設定（時刻が無い）”を非アクティブとして扱う
+        appState.customHabits.filter { cfg in
+            appState.customHabitSchedules[cfg.id] == nil && customHabitTimes[cfg.id] == nil
+        }
+    }
@@
-        HStack {
-            VStack(alignment: .leading, spacing: 8) {
+        HStack {
+            // 左側ラベル領域のみタップ可能にして、トグル操作時にシートが開かないようにする
+            VStack(alignment: .leading, spacing: 8) {
                 Text(habit.title)
                     .font(.headline)
                 Text(habit.detail)
                     .font(.subheadline)
                     .foregroundStyle(.secondary)
-            }
+            }
+            .contentShape(Rectangle())
+            .onTapGesture {
+                if isActive {
+                    activeSheet = .editor(habit)
+                } else {
+                    sheetTime = date ?? Date()
+                    activeSheet = .habit(habit)
+                }
+            }
@@
-            Toggle("", isOn: Binding(
+            Toggle("", isOn: Binding(
                 get: { isActive },
                 set: { isOn in
                     if isOn {
                         activeHabits.insert(habit)
                         if let date = date {
                             habitTimes[habit] = date
                         }
                     } else {
                         // トグルOFFでも削除しない
                         activeHabits.remove(habit)
                     }
                 }
             ))
             .labelsHidden()
-        }
-        .contentShape(Rectangle())
-        .onTapGesture {
-            if isActive {
-                activeSheet = .editor(habit)
-            } else {
-                sheetTime = date ?? Date()
-                activeSheet = .habit(habit)
-            }
-        }
+        }
@@
-        HStack {
-            VStack(alignment: .leading, spacing: 8) {
+        HStack {
+            VStack(alignment: .leading, spacing: 8) {
                 Text(name)
                     .font(.headline)
-            }
+            }
+            .contentShape(Rectangle())
+            .onTapGesture {
+                if isActive {
+                    sheetTime = date ?? Date()
+                    activeSheet = .custom(id)
+                }
+            }
@@
-            Toggle("", isOn: Binding(
+            Toggle("", isOn: Binding(
                 get: { isActive },
                 set: { isOn in
                     if isOn {
                         activeCustomHabits.insert(id)
                         if let date = date {
                             customHabitTimes[id] = date
                         }
                     } else {
                         activeCustomHabits.remove(id)
                     }
                 }
             ))
             .labelsHidden()
-        }
-        .contentShape(Rectangle())
-        .onTapGesture {
-            if isActive {
-                sheetTime = date ?? Date()
-                activeSheet = .custom(id)
-            }
-        }
+        }
```


### 2) 設定画面の削除リクエストにBearerを付与（`aniccaios/aniccaios/SettingsView.swift`）

- 既にサーバはBearer優先＋`device-id`/`user-id`フォールバック対応。より堅牢にするためBearerを付与。
```diff
--- a/aniccaios/aniccaios/SettingsView.swift
+++ b/aniccaios/aniccaios/SettingsView.swift
@@
-        var request = URLRequest(url: AppConfig.proxyBaseURL.appendingPathComponent("mobile/account"))
+        var request = URLRequest(url: AppConfig.proxyBaseURL.appendingPathComponent("mobile/account"))
         request.httpMethod = "DELETE"
         request.setValue("application/json", forHTTPHeaderField: "Content-Type")
         request.setValue(AppState.shared.resolveDeviceId(), forHTTPHeaderField: "device-id")
         request.setValue(credentials.userId, forHTTPHeaderField: "user-id")
+        // JWT/Bearer を優先的に付与（存在すれば）
+        try? await NetworkSessionManager.shared.setAuthHeaders(for: &request)
```


補足: サーバ側は既に204を返却しており仕様通り（完全削除）。

### 3) サーバ側（参考・現状の実装）

- RevenueCat購買者削除 + アプリDBデータ削除を実施済み。
```39:86:apps/api/src/routes/mobile/account.js
    // RevenueCatのSubscriber削除（App User ID）
    try {
      await deleteSubscriber(userId);
    } catch (error) {
      // RevenueCat削除失敗はログに記録するが、処理は続行
      console.error(`[Account Deletion] Failed to delete RevenueCat subscriber for user ${userId}:`, error);
    }
    
    // アプリDBの削除（pg Poolでトランザクション）
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      // 関連データを削除（外部キー制約の順序に注意）
      await client.query('DELETE FROM usage_sessions WHERE user_id = $1', [userId]);
      await client.query('DELETE FROM mobile_profiles WHERE user_id = $1', [userId]);
      ...
      if (uuidRegex.test(userId)) {
        await client.query('DELETE FROM profiles WHERE id = $1::uuid', [userId]);
      } else {
        await client.query(`DELETE FROM profiles WHERE metadata->>'apple_user_id' = $1`, [userId]);
      }
      await client.query('COMMIT');
    } catch (e) {
      await client.query('ROLLBACK');
      throw e;
    } finally {
      client.release();
    }
    
    return res.status(204).send();
```


## 現状確認（質問2/3への回答）

- **JWTログイン**: 実装済み。`/auth/apple`がAT(15分)＋RT(30日)を発行し、iOSは保存しています。
```148:164:aniccaios/aniccaios/Authentication/AuthCoordinator.swift
                let jwtToken = json["token"] as? String
                var expiresAt: Date? = nil
                if let expMs = json["expiresAt"] as? TimeInterval {
                    expiresAt = Date(timeIntervalSince1970: expMs / 1000)
                }
                if let rt = json["refreshToken"] as? String {
                    try? KeychainService.save(Data(rt.utf8), account: "rt")
                }
                var credentials = UserCredentials(
                    userId: backendUserId,
                    displayName: displayName,
                    email: email
                )
                credentials.jwtAccessToken = jwtToken
                credentials.accessTokenExpiresAt = expiresAt
```
```49:92:apps/api/src/routes/auth/apple.js
    const token = signJwtHs256(accessPayload, jwtSecret);
    // Issue Refresh Token (30 days)
    ...
    return res.json({ userId: verifiedUser.userId, ... , token, expiresAt: exp * 1000, refreshToken: rt });
```

- **ログアウト/アカウント削除**: 「Delete Account」実行時はサーバ側で購買者＋ユーザーデータを削除し、204の後にiOSが`handleLogout()`→`signOutAndWipe()`でローカルを初期化→ウェルカムに戻ります。ログに「Log out...」と出るのはこのローカル初期化のためで、サーバ側は実削除されています（提示のRailwayログどおり）。

## 検証

- Habitsトグル: 重複行が出ないこと、トグル操作でシートが誤発火しないことを確認。
- アカウント削除: 204応答、RC購買者がDELETEされるログ、DBから対象ユーザーが消えることを確認。
- JWT: `/auth/apple`でAT/RTを受領し、AuthorizedリクエストがBearer付で送れていること（今回の削除APIにも適用）。

### To-dos

- [ ] HabitsSectionViewの非アクティブ判定とタップ領域を修正
- [ ] SettingsViewのDELETE /mobile/accountにBearer付与
- [ ] 削除フロー＆JWTのE2E確認（204・RC・DBログ）