# Phase 4 å®Œå…¨å®Ÿè£…ä»•æ§˜æ›¸

> **ç›®çš„**: ã“ã®æ–‡æ›¸ã‚’èª­ã‚“ã ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã€è¿½åŠ ã®è³ªå•ãªã—ã§Phase 4ã‚’å®Œå…¨ã«å®Ÿè£…ã§ãã‚‹ã“ã¨
>
> **æœ€çµ‚æ›´æ–°**: 2026-01-21

---

## ç›®æ¬¡

1. [æ¦‚è¦](#1-æ¦‚è¦)
2. [ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§](#2-ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§)
3. [Task 0: AnalyticsEvent è¿½åŠ ](#task-0-analyticsevent-è¿½åŠ )
4. [Task 1: é€šçŸ¥è¨€èªå•é¡Œä¿®æ­£](#task-1-é€šçŸ¥è¨€èªå•é¡Œä¿®æ­£)
5. [Task 2: æ™‚åˆ»ç‰¹æœ‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿®æ­£](#task-2-æ™‚åˆ»ç‰¹æœ‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿®æ­£)
6. [Task 3: ã‚«ãƒƒã‚³å‰Šé™¤](#task-3-ã‚«ãƒƒã‚³å‰Šé™¤)
7. [Task 4: nudge_tapped å®Ÿè£…](#task-4-nudge_tapped-å®Ÿè£…)
8. [Task 5: nudge_ignored æ¨å®š](#task-5-nudge_ignored-æ¨å®š)
9. [Task 6: NudgeStats ãƒ¢ãƒ‡ãƒ«](#task-6-nudgestats-ãƒ¢ãƒ‡ãƒ«)
10. [Task 7: ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹é€šçŸ¥é¸æŠ](#task-7-ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹é€šçŸ¥é¸æŠ)
11. [Task 8: ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹Contenté¸æŠ](#task-8-ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹contenté¸æŠ)
12. [Task 9: ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–](#task-9-ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–)
13. [Task 10: èª²é‡‘ãƒ­ã‚¸ãƒƒã‚¯](#task-10-èª²é‡‘ãƒ­ã‚¸ãƒƒã‚¯)
14. [Task 11: Paywall Placementæ›´æ–°](#task-11-paywall-placementæ›´æ–°)
15. [ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹](#ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹)
16. [å®Ÿè£…é †åº](#å®Ÿè£…é †åº)

---

## 1. æ¦‚è¦

### èƒŒæ™¯

Phase 4ã§ã¯ä»¥ä¸‹ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ï¼š

1. **è¨€èªãƒã‚°**: ç«¯æœ«ã‚’æ—¥æœ¬èªã«ã—ã¦ã‚‚é€šçŸ¥ãŒè‹±èªã§è¡¨ç¤ºã•ã‚Œã‚‹
2. **æ™‚åˆ»ãƒã‚°**: ã€Œæ·±å¤œ1æ™‚ã§ã™ã€ãŒ21æ™‚ã«è¡¨ç¤ºã•ã‚Œã‚‹
3. **å­¦ç¿’ãªã—**: ã©ã®ãƒãƒªã‚¢ãƒ³ãƒˆãŒåŠ¹æœçš„ã‹ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—ãŒãªã„

### ã‚´ãƒ¼ãƒ«

- æ—¥æœ¬èªãƒ¦ãƒ¼ã‚¶ãƒ¼ã«æ—¥æœ¬èªã§é€šçŸ¥ãŒå±Šã
- æ™‚åˆ»ç‰¹æœ‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ­£ã—ã„æ™‚åˆ»ã«å±Šã
- ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ã®è‡ªå¾‹æ”¹å–„ãŒé–‹å§‹ã•ã‚Œã‚‹

---

## 2. ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§

### å¤‰æ›´ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«

| ãƒ•ã‚¡ã‚¤ãƒ« | å¤‰æ›´å†…å®¹ |
|---------|---------|
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/AnalyticsManager.swift` | Nudgeç”¨ã‚¤ãƒ™ãƒ³ãƒˆã‚±ãƒ¼ã‚¹è¿½åŠ  |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Notifications/ProblemNotificationScheduler.swift` | userInfoã«ã‚­ãƒ¼ã‚’ä¿å­˜ã€NudgeContentSelectorä½¿ç”¨ |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Models/NudgeContent.swift` | ã‚­ãƒ¼ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆè§£æ±ºã€scheduledHourå¯¾å¿œ |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Views/NudgeCardView.swift` | ã‚«ãƒƒã‚³å‰Šé™¤ |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/AppDelegate.swift` | nudge_tappedè¨˜éŒ²è¿½åŠ  |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/AppState.swift` | èµ·å‹•æ™‚ãƒã‚§ãƒƒã‚¯ã€èª²é‡‘ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼è¿½åŠ  |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/SuperwallManager.swift` | Placementæ›´æ–° |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/MainTabView.swift` | NudgeCardå®Œäº†æ™‚ã®Paywall/ãƒ¬ãƒ“ãƒ¥ãƒ¼å‡¦ç†ã€handleAppOpenPaywallå‰Šé™¤ |

### æ–°è¦ä½œæˆãƒ•ã‚¡ã‚¤ãƒ«

| ãƒ•ã‚¡ã‚¤ãƒ« | å†…å®¹ |
|---------|------|
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/NudgeStatsManager.swift` | çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ç®¡ç† |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/NudgeContentSelector.swift` | ãƒãƒªã‚¢ãƒ³ãƒˆé¸æŠãƒ­ã‚¸ãƒƒã‚¯ |

### ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆå¤‰æ›´ãªã—ã€å‚ç…§ã®ã¿ï¼‰

| ãƒ•ã‚¡ã‚¤ãƒ« | å†…å®¹ |
|---------|------|
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Resources/ja.lproj/Localizable.strings` | æ—¥æœ¬èªæ–‡å­—åˆ—ï¼ˆæ—¢å­˜ï¼‰ |
| `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Resources/en.lproj/Localizable.strings` | è‹±èªæ–‡å­—åˆ—ï¼ˆæ—¢å­˜ï¼‰ |

---

## Task 0: AnalyticsEvent è¿½åŠ 

### å•é¡Œ

`AnalyticsEvent` enum ã« Nudge ç”¨ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚±ãƒ¼ã‚¹ãŒãªã„ã€‚

### ä¿®æ­£ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/AnalyticsManager.swift`

**è¡Œ**: enum AnalyticsEvent ã®æœ«å°¾ï¼ˆ185è¡Œä»˜è¿‘ï¼‰

```swift
// As-Is: enum AnalyticsEvent ã®æœ«å°¾
    // Engagement
    case talkTabOpened = "talk_tab_opened"
    case settingsOpened = "settings_opened"
}

// To-Be: ä»¥ä¸‹ã®3ã‚±ãƒ¼ã‚¹ã‚’è¿½åŠ 
    // Engagement
    case talkTabOpened = "talk_tab_opened"
    case settingsOpened = "settings_opened"

    // Nudge (Phase 4)
    case nudgeTapped = "nudge_tapped"
    case nudgeIgnored = "nudge_ignored"
    case nudgeFeedback = "nudge_feedback"
}
```

---

## Task 1: é€šçŸ¥è¨€èªå•é¡Œä¿®æ­£

### å•é¡Œ

`NSLocalizedString`ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ™‚ã«è§£æ±ºã•ã‚Œã€è¨€èªå¤‰æ›´å¾Œã‚‚å¤ã„è¨€èªã§é…ä¿¡ã•ã‚Œã‚‹ã€‚

### åŸå› ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Notifications/ProblemNotificationScheduler.swift`

**è¡Œ**: 152-166

```swift
// As-Is (ç¾çŠ¶)
let content = NudgeContent.contentForToday(for: problem)

let notificationContent = UNMutableNotificationContent()
notificationContent.title = problem.notificationTitle  // â† æ—¢ã«è§£æ±ºã•ã‚ŒãŸæ–‡å­—åˆ—
notificationContent.body = content.notificationText    // â† æ—¢ã«è§£æ±ºã•ã‚ŒãŸæ–‡å­—åˆ—

notificationContent.userInfo = [
    "problemType": problem.rawValue,
    "notificationText": content.notificationText,      // â† æ–‡å­—åˆ—ã‚’ä¿å­˜
    "detailText": content.detailText,                  // â† æ–‡å­—åˆ—ã‚’ä¿å­˜
    "variantIndex": content.variantIndex
]
```

### ä¿®æ­£æ–¹æ³•

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Notifications/ProblemNotificationScheduler.swift`

```swift
// To-Be (ä¿®æ­£å¾Œ)
// scheduleNotification ãƒ¡ã‚½ãƒƒãƒ‰å†…

private func scheduleNotification(for problem: ProblemType, hour: Int, minute: Int) async {
    // cantWakeUp + AlarmKitè¨±å¯æ¸ˆã¿ + ãƒˆã‚°ãƒ«ON â†’ AlarmKitã«å§”è­²
    if problem == .cantWakeUp {
        #if canImport(AlarmKit)
        if #available(iOS 26.0, *) {
            let manager = AlarmManager.shared
            if manager.authorizationState == .authorized,
               AppState.shared.userProfile.useAlarmKitForCantWakeUp {
                if hour == 6 && minute == 0 {
                    await ProblemAlarmKitScheduler.shared.scheduleCantWakeUp(hour: hour, minute: minute)
                }
                return
            }
        }
        #endif
    }

    // NudgeContentSelectorã§ãƒãƒªã‚¢ãƒ³ãƒˆé¸æŠï¼ˆTask 7ã§å®Ÿè£…ï¼‰
    let variantIndex = await MainActor.run {
        NudgeContentSelector.shared.selectVariant(for: problem, scheduledHour: hour)
    }

    // ã‚­ãƒ¼ã‚’ç”Ÿæˆï¼ˆæ–‡å­—åˆ—ã§ã¯ãªãã‚­ãƒ¼ã‚’ä¿å­˜ï¼‰
    let notificationTextKey = "nudge_\(problem.rawValue)_notification_\(variantIndex + 1)"
    let detailTextKey = "nudge_\(problem.rawValue)_detail_\(variantIndex + 1)"
    let titleKey = "problem_\(problem.rawValue)_notification_title"

    let notificationContent = UNMutableNotificationContent()
    // é€šçŸ¥ã®title/bodyã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ™‚ã«è§£æ±ºï¼ˆiOSé€šçŸ¥ã‚»ãƒ³ã‚¿ãƒ¼ã«è¡¨ç¤ºã•ã‚Œã‚‹ãŸã‚ï¼‰
    notificationContent.title = NSLocalizedString(titleKey, comment: "")
    notificationContent.body = NSLocalizedString(notificationTextKey, comment: "")
    notificationContent.categoryIdentifier = Category.problemNudge.rawValue
    notificationContent.sound = .default

    // userInfo ã«ã‚­ãƒ¼ã‚’ä¿å­˜ï¼ˆè¡¨ç¤ºæ™‚ã«å†è§£æ±ºï¼‰
    notificationContent.userInfo = [
        "problemType": problem.rawValue,
        "notificationTextKey": notificationTextKey,
        "detailTextKey": detailTextKey,
        "variantIndex": variantIndex,
        "scheduledHour": hour,
        "scheduledMinute": minute
    ]

    if #available(iOS 15.0, *) {
        notificationContent.interruptionLevel = .active
    }

    var dateComponents = DateComponents()
    dateComponents.hour = hour
    dateComponents.minute = minute
    let trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)

    let identifier = "PROBLEM_\(problem.rawValue)_\(hour)_\(minute)"
    let request = UNNotificationRequest(
        identifier: identifier,
        content: notificationContent,
        trigger: trigger
    )

    do {
        try await center.add(request)
        logger.info("Scheduled problem notification: \(problem.rawValue) at \(hour):\(minute) variant:\(variantIndex)")

        // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æˆåŠŸæ™‚ã«NudgeStatsã«è¨˜éŒ²ï¼ˆTask 6ã§å®Ÿè£…ï¼‰
        await MainActor.run {
            NudgeStatsManager.shared.recordScheduled(
                problemType: problem.rawValue,
                variantIndex: variantIndex,
                scheduledHour: hour
            )
        }
    } catch {
        logger.error("Failed to schedule problem notification: \(error.localizedDescription)")
    }
}
```

### NudgeContent.swift ã®ä¿®æ­£

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Models/NudgeContent.swift`

```swift
// As-Is: nudgeContent(from:) ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆè¡Œ 210-225ï¼‰
static func nudgeContent(from userInfo: [AnyHashable: Any]) -> NudgeContent? {
    guard let problemRaw = userInfo["problemType"] as? String,
          let problem = ProblemType(rawValue: problemRaw),
          let notificationText = userInfo["notificationText"] as? String,
          let detailText = userInfo["detailText"] as? String,
          let variantIndex = userInfo["variantIndex"] as? Int else {
        return nil
    }

    return NudgeContent(
        problemType: problem,
        notificationText: notificationText,
        detailText: detailText,
        variantIndex: variantIndex
    )
}

// To-Be: ã‚­ãƒ¼ã‹ã‚‰è§£æ±ºã™ã‚‹ã‚ˆã†ã«ä¿®æ­£
static func nudgeContent(from userInfo: [AnyHashable: Any]) -> NudgeContent? {
    guard let problemRaw = userInfo["problemType"] as? String,
          let problem = ProblemType(rawValue: problemRaw),
          let variantIndex = userInfo["variantIndex"] as? Int else {
        return nil
    }

    // æ–°å½¢å¼: ã‚­ãƒ¼ã‹ã‚‰è§£æ±º
    if let notificationTextKey = userInfo["notificationTextKey"] as? String,
       let detailTextKey = userInfo["detailTextKey"] as? String {
        let notificationText = NSLocalizedString(notificationTextKey, comment: "")
        let detailText = NSLocalizedString(detailTextKey, comment: "")

        return NudgeContent(
            problemType: problem,
            notificationText: notificationText,
            detailText: detailText,
            variantIndex: variantIndex
        )
    }

    // å¾Œæ–¹äº’æ›: å¤ã„å½¢å¼ï¼ˆæ–‡å­—åˆ—ç›´æ¥ä¿å­˜ï¼‰
    if let notificationText = userInfo["notificationText"] as? String,
       let detailText = userInfo["detailText"] as? String {
        return NudgeContent(
            problemType: problem,
            notificationText: notificationText,
            detailText: detailText,
            variantIndex: variantIndex
        )
    }

    return nil
}
```

---

## Task 2: æ™‚åˆ»ç‰¹æœ‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ä¿®æ­£

### å•é¡Œ

`stayingUpLate`ã®variant_4ã€Œæ·±å¤œ0æ™‚ã‚’éãã¾ã—ãŸã€ã¨variant_5ã€Œæ·±å¤œ1æ™‚ã§ã™ã€ãŒã€æ—¥ä»˜ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§é–“é•ã£ãŸæ™‚åˆ»ã«é…ä¿¡ã•ã‚Œã‚‹ã€‚

### åŸå› ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Models/NudgeContent.swift`

**è¡Œ**: 26-31

```swift
// As-Is (ç¾çŠ¶)
static func contentForToday(for problem: ProblemType) -> NudgeContent {
    let dayOfYear = Calendar.current.ordinality(of: .day, in: .year, for: Date()) ?? 1
    let messages = notificationMessages(for: problem)
    let index = (dayOfYear - 1) % max(1, messages.count)  // â† æ™‚åˆ»ç„¡é–¢ä¿‚ï¼
    return content(for: problem, variantIndex: index)
}
```

### ä¿®æ­£æ–¹æ³•

ã“ã®ä¿®æ­£ã¯Task 7ï¼ˆNudgeContentSelectorï¼‰ã§å®Ÿè£…ã™ã‚‹ã€‚`contentForToday`ã¯å‰Šé™¤ã—ãªã„ãŒã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã¯NudgeContentSelectorã‚’ä½¿ç”¨ã™ã‚‹ã€‚

**æ™‚åˆ»ã¨ãƒãƒªã‚¢ãƒ³ãƒˆã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆstayingUpLateï¼‰**:

| scheduledHour | variantIndex | ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ |
|---------------|--------------|----------|
| 21 | 0, 1, 2 ã®ã„ãšã‚Œã‹ï¼ˆtapç‡ãƒ™ãƒ¼ã‚¹ï¼‰ | æ±ç”¨ |
| 22 | 0, 1, 2 ã®ã„ãšã‚Œã‹ï¼ˆtapç‡ãƒ™ãƒ¼ã‚¹ï¼‰ | æ±ç”¨ |
| 0 | **3 (å›ºå®š)** | ã€Œæ·±å¤œ0æ™‚ã‚’éãã¾ã—ãŸã€ |
| 1 | **4 (å›ºå®š)** | ã€Œæ·±å¤œ1æ™‚ã§ã™ã€ |

---

## Task 3: ã‚«ãƒƒã‚³å‰Šé™¤

### å•é¡Œ

NudgeCardViewã§é€šçŸ¥ãƒ†ã‚­ã‚¹ãƒˆãŒã€Œã€ã§å›²ã¾ã‚Œã¦ã„ã‚‹ã€‚

### ä¿®æ­£ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Views/NudgeCardView.swift`

**è¡Œ**: 58

```swift
// As-Is
Text("ã€Œ\(content.notificationText)ã€")
    .font(.system(size: 22, weight: .semibold))

// To-Be
Text(content.notificationText)
    .font(.system(size: 22, weight: .semibold))
```

---

## Task 4: nudge_tapped å®Ÿè£…

### ä¿®æ­£ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/AppDelegate.swift`

**è¡Œ**: 67-92 (didReceive ãƒ¡ã‚½ãƒƒãƒ‰å†…)

```swift
// As-Is
if ProblemNotificationScheduler.isProblemNudge(identifier: notificationIdentifier) {
    switch identifier {
    case UNNotificationDefaultActionIdentifier,
         NotificationScheduler.Action.startConversation.rawValue:
        if let nudgeContent = ProblemNotificationScheduler.nudgeContent(from: content.userInfo) {
            Task { @MainActor in
                AppState.shared.showNudgeCard(nudgeContent)
            }
        }
    // ...
    }
    return
}

// To-Be
if ProblemNotificationScheduler.isProblemNudge(identifier: notificationIdentifier) {
    switch identifier {
    case UNNotificationDefaultActionIdentifier,
         NotificationScheduler.Action.startConversation.rawValue:
        if let nudgeContent = ProblemNotificationScheduler.nudgeContent(from: content.userInfo) {
            // nudge_tapped ã‚’è¨˜éŒ²
            let scheduledHour = content.userInfo["scheduledHour"] as? Int ?? 0
            Task { @MainActor in
                // NudgeStats ã«è¨˜éŒ²
                NudgeStatsManager.shared.recordTapped(
                    problemType: nudgeContent.problemType.rawValue,
                    variantIndex: nudgeContent.variantIndex,
                    scheduledHour: scheduledHour
                )

                // Mixpanel ã«é€ä¿¡
                AnalyticsManager.shared.track(.nudgeTapped, properties: [
                    "problem_type": nudgeContent.problemType.rawValue,
                    "variant_index": nudgeContent.variantIndex,
                    "scheduled_hour": scheduledHour
                ])

                // NudgeCard ã‚’è¡¨ç¤º
                AppState.shared.showNudgeCard(nudgeContent)
            }
        }
    case NotificationScheduler.Action.dismissAll.rawValue,
         UNNotificationDismissActionIdentifier:
        break
    default:
        break
    }
    return
}
```

---

## Task 5: nudge_ignored æ¨å®š

### ä¿®æ­£ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/AppState.swift`

**init() å†…ã«è¿½åŠ ** (è¡Œ70-100ä»˜è¿‘)

```swift
// To-Be: init() ã®æœ€å¾Œã«è¿½åŠ 
private init() {
    // ... æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ ...

    // ã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã«ignoredåˆ¤å®šã‚’å®Ÿè¡Œ
    Task {
        await NudgeStatsManager.shared.checkAndRecordIgnored()
    }
}
```

**NudgeStatsManagerã«å®Ÿè£…** (Task 6ã§è©³ç´°)

---

## Task 6: NudgeStats ãƒ¢ãƒ‡ãƒ«

### æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/NudgeStatsManager.swift`

```swift
import Foundation
import OSLog

/// Nudgeçµ±è¨ˆãƒ‡ãƒ¼ã‚¿
struct NudgeStats: Codable, Equatable {
    let problemType: String
    let variantIndex: Int
    let scheduledHour: Int

    var tappedCount: Int = 0
    var ignoredCount: Int = 0
    var thumbsUpCount: Int = 0
    var thumbsDownCount: Int = 0
    var consecutiveIgnoredDays: Int = 0
    var lastTappedDate: Date?
    var lastScheduledDate: Date?

    /// tapç‡ã‚’è¨ˆç®—
    var tapRate: Double {
        let total = tappedCount + ignoredCount
        guard total > 0 else { return 0.5 }
        return Double(tappedCount) / Double(total)
    }

    /// ğŸ‘ç‡ã‚’è¨ˆç®—
    var thumbsUpRate: Double {
        let total = thumbsUpCount + thumbsDownCount
        guard total > 0 else { return 0.5 }
        return Double(thumbsUpCount) / Double(total)
    }

    /// ç·ã‚µãƒ³ãƒ—ãƒ«æ•°
    var totalSamples: Int {
        tappedCount + ignoredCount
    }

    /// ä¸€æ„ã‚­ãƒ¼
    var key: String {
        "\(problemType)_\(variantIndex)_\(scheduledHour)"
    }
}

/// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚ŒãŸNudgeï¼ˆignoredåˆ¤å®šç”¨ï¼‰
struct ScheduledNudge: Codable {
    let problemType: String
    let variantIndex: Int
    let scheduledHour: Int
    let scheduledDate: Date
    var wasTapped: Bool = false
}

/// Nudgeçµ±è¨ˆç®¡ç†
@MainActor
final class NudgeStatsManager {
    static let shared = NudgeStatsManager()

    private let logger = Logger(subsystem: "com.anicca.ios", category: "NudgeStats")
    private let queue = DispatchQueue(label: "com.anicca.nudgeStats", qos: .utility)

    // Storage keys
    private let statsKey = "com.anicca.nudgeStats"
    private let scheduledKey = "com.anicca.scheduledNudges"

    // In-memory cache
    private var stats: [String: NudgeStats] = [:]
    private var scheduledNudges: [String: ScheduledNudge] = [:]

    private init() {
        loadFromStorage()
    }

    // MARK: - Public API

    /// é€šçŸ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æˆåŠŸæ™‚ã«è¨˜éŒ²
    func recordScheduled(problemType: String, variantIndex: Int, scheduledHour: Int) {
        let key = "\(problemType)_\(variantIndex)_\(scheduledHour)"
        let nudge = ScheduledNudge(
            problemType: problemType,
            variantIndex: variantIndex,
            scheduledHour: scheduledHour,
            scheduledDate: Date()
        )
        scheduledNudges[key] = nudge

        // statsã‚‚æ›´æ–°
        var stat = stats[key] ?? NudgeStats(problemType: problemType, variantIndex: variantIndex, scheduledHour: scheduledHour)
        stat.lastScheduledDate = Date()
        stats[key] = stat

        saveToStorage()
        logger.info("Recorded scheduled: \(key)")
    }

    /// é€šçŸ¥ã‚¿ãƒƒãƒ—æ™‚ã«è¨˜éŒ²
    func recordTapped(problemType: String, variantIndex: Int, scheduledHour: Int) {
        let key = "\(problemType)_\(variantIndex)_\(scheduledHour)"

        // scheduledNudgesã‚’æ›´æ–°
        if var nudge = scheduledNudges[key] {
            nudge.wasTapped = true
            scheduledNudges[key] = nudge
        }

        // statsã‚’æ›´æ–°
        var stat = stats[key] ?? NudgeStats(problemType: problemType, variantIndex: variantIndex, scheduledHour: scheduledHour)
        stat.tappedCount += 1
        stat.consecutiveIgnoredDays = 0  // ãƒªã‚»ãƒƒãƒˆ
        stat.lastTappedDate = Date()
        stats[key] = stat

        saveToStorage()
        logger.info("Recorded tapped: \(key), tapRate: \(stat.tapRate)")
    }

    /// ignoredåˆ¤å®šï¼ˆã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã«å‘¼ã³å‡ºã™ï¼‰
    func checkAndRecordIgnored() async {
        let now = Date()
        let calendar = Calendar.current

        for (key, nudge) in scheduledNudges {
            // 24æ™‚é–“ä»¥ä¸Šå‰ & æœªtapped = ignored
            guard let scheduledDate = nudge.scheduledDate as Date?,
                  !nudge.wasTapped,
                  let hoursDiff = calendar.dateComponents([.hour], from: scheduledDate, to: now).hour,
                  hoursDiff >= 24 else {
                continue
            }

            recordIgnored(
                problemType: nudge.problemType,
                variantIndex: nudge.variantIndex,
                scheduledHour: nudge.scheduledHour
            )

            // Mixpanelã«é€ä¿¡
            AnalyticsManager.shared.track(.nudgeIgnored, properties: [
                "problem_type": nudge.problemType,
                "variant_index": nudge.variantIndex,
                "scheduled_hour": nudge.scheduledHour
            ])

            // scheduledNudgesã‹ã‚‰å‰Šé™¤
            scheduledNudges.removeValue(forKey: key)
        }

        saveToStorage()
    }

    /// ignoredè¨˜éŒ²
    private func recordIgnored(problemType: String, variantIndex: Int, scheduledHour: Int) {
        let key = "\(problemType)_\(variantIndex)_\(scheduledHour)"

        var stat = stats[key] ?? NudgeStats(problemType: problemType, variantIndex: variantIndex, scheduledHour: scheduledHour)
        stat.ignoredCount += 1
        stat.consecutiveIgnoredDays += 1
        stats[key] = stat

        logger.info("Recorded ignored: \(key), consecutiveIgnoredDays: \(stat.consecutiveIgnoredDays)")
    }

    /// ğŸ‘è¨˜éŒ²
    func recordThumbsUp(problemType: String, variantIndex: Int) {
        // scheduledHourã¯ä¸æ˜ãªã®ã§ã€å…¨æ™‚é–“å¸¯ã®åŒã˜variantã‚’æ›´æ–°
        for (key, var stat) in stats {
            if stat.problemType == problemType && stat.variantIndex == variantIndex {
                stat.thumbsUpCount += 1
                stats[key] = stat
            }
        }
        saveToStorage()

        AnalyticsManager.shared.track(.nudgeFeedback, properties: [
            "problem_type": problemType,
            "variant_index": variantIndex,
            "is_positive": true
        ])
    }

    /// ğŸ‘è¨˜éŒ²
    func recordThumbsDown(problemType: String, variantIndex: Int) {
        for (key, var stat) in stats {
            if stat.problemType == problemType && stat.variantIndex == variantIndex {
                stat.thumbsDownCount += 1
                stats[key] = stat
            }
        }
        saveToStorage()

        AnalyticsManager.shared.track(.nudgeFeedback, properties: [
            "problem_type": problemType,
            "variant_index": variantIndex,
            "is_positive": false
        ])
    }

    /// çµ±è¨ˆå–å¾—
    func getStats(problemType: String, variantIndex: Int, hour: Int) -> NudgeStats? {
        let key = "\(problemType)_\(variantIndex)_\(hour)"
        return stats[key]
    }

    /// å•é¡Œã‚¿ã‚¤ãƒ—ã®å…¨ãƒãƒªã‚¢ãƒ³ãƒˆçµ±è¨ˆå–å¾—
    func getAllStats(for problemType: String, hour: Int) -> [NudgeStats] {
        return stats.values.filter { $0.problemType == problemType && $0.scheduledHour == hour }
    }

    /// æ™‚é–“å¸¯ã®é€£ç¶šignoredæ—¥æ•°å–å¾—
    func getConsecutiveIgnoredDays(problemType: String, hour: Int) -> Int {
        let hourStats = stats.values.filter { $0.problemType == problemType && $0.scheduledHour == hour }
        return hourStats.map { $0.consecutiveIgnoredDays }.max() ?? 0
    }

    // MARK: - Storage

    private func loadFromStorage() {
        let defaults = UserDefaults.standard

        if let data = defaults.data(forKey: statsKey),
           let decoded = try? JSONDecoder().decode([String: NudgeStats].self, from: data) {
            stats = decoded
        }

        if let data = defaults.data(forKey: scheduledKey),
           let decoded = try? JSONDecoder().decode([String: ScheduledNudge].self, from: data) {
            scheduledNudges = decoded
        }
    }

    private func saveToStorage() {
        queue.async { [stats, scheduledNudges] in
            let defaults = UserDefaults.standard

            if let data = try? JSONEncoder().encode(stats) {
                defaults.set(data, forKey: self.statsKey)
            }

            if let data = try? JSONEncoder().encode(scheduledNudges) {
                defaults.set(data, forKey: self.scheduledKey)
            }
        }
    }

    // MARK: - Debug

    #if DEBUG
    func resetAllStats() {
        stats = [:]
        scheduledNudges = [:]
        saveToStorage()
        logger.info("All stats reset")
    }
    #endif
}
```

---

## Task 7: ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹é€šçŸ¥é¸æŠ

### æ–°è¦ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/NudgeContentSelector.swift`

```swift
import Foundation
import OSLog

/// Nudgeã‚³ãƒ³ãƒ†ãƒ³ãƒ„é¸æŠãƒ­ã‚¸ãƒƒã‚¯
@MainActor
final class NudgeContentSelector {
    static let shared = NudgeContentSelector()

    private let logger = Logger(subsystem: "com.anicca.ios", category: "NudgeContentSelector")

    private init() {}

    /// å•é¡Œã‚¿ã‚¤ãƒ—ã¨æ™‚åˆ»ã‹ã‚‰ãƒ™ã‚¹ãƒˆãªãƒãƒªã‚¢ãƒ³ãƒˆã‚’é¸æŠ
    func selectVariant(for problem: ProblemType, scheduledHour: Int) -> Int {
        // 1. æ™‚åˆ»å›ºå®šãƒãƒªã‚¢ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯
        if let fixedVariant = getTimeSpecificVariant(problem: problem, hour: scheduledHour) {
            logger.info("Selected time-specific variant \(fixedVariant) for \(problem.rawValue) at hour \(scheduledHour)")
            return fixedVariant
        }

        // 2. æ±ç”¨ãƒãƒªã‚¢ãƒ³ãƒˆã‹ã‚‰é¸æŠ
        let genericVariants = getGenericVariantIndices(for: problem)
        guard !genericVariants.isEmpty else {
            return 0
        }

        // 3. ãƒ‡ãƒ¼ã‚¿é‡ã«å¿œã˜ãŸé¸æŠæˆ¦ç•¥
        let selectedVariant = selectByDataLevel(
            variants: genericVariants,
            problem: problem,
            hour: scheduledHour
        )

        logger.info("Selected variant \(selectedVariant) for \(problem.rawValue) at hour \(scheduledHour)")
        return selectedVariant
    }

    // MARK: - Time-Specific Variants

    /// æ™‚åˆ»å›ºå®šãƒãƒªã‚¢ãƒ³ãƒˆã‚’è¿”ã™ï¼ˆè©²å½“ã—ãªã„å ´åˆã¯nilï¼‰
    private func getTimeSpecificVariant(problem: ProblemType, hour: Int) -> Int? {
        switch problem {
        case .stayingUpLate:
            // æ·±å¤œ0æ™‚ â†’ variant_4ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹3ï¼‰
            if hour == 0 { return 3 }
            // æ·±å¤œ1æ™‚ â†’ variant_5ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹4ï¼‰
            if hour == 1 { return 4 }
            return nil
        default:
            return nil
        }
    }

    /// æ±ç”¨ãƒãƒªã‚¢ãƒ³ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ã‚’è¿”ã™
    private func getGenericVariantIndices(for problem: ProblemType) -> [Int] {
        switch problem {
        case .stayingUpLate:
            // variant_1, 2, 3 (ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹0, 1, 2) ãŒæ±ç”¨
            return [0, 1, 2]
        case .cantWakeUp:
            return [0, 1, 2]
        case .selfLoathing:
            return [0, 1, 2]
        case .rumination:
            return [0, 1, 2]
        case .procrastination:
            return [0, 1, 2]
        case .anxiety:
            return [0, 1, 2]
        case .lying:
            return [0]  // 1ç¨®é¡ã®ã¿
        case .badMouthing:
            return [0, 1]
        case .pornAddiction:
            return [0, 1]
        case .alcoholDependency:
            return [0, 1]
        case .anger:
            return [0, 1]
        case .obsessive:
            return [0, 1, 2]
        case .loneliness:
            return [0, 1]
        }
    }

    // MARK: - Data-Level Selection

    /// ãƒ‡ãƒ¼ã‚¿é‡ã«å¿œã˜ãŸé¸æŠæˆ¦ç•¥
    private func selectByDataLevel(variants: [Int], problem: ProblemType, hour: Int) -> Int {
        // å„ãƒãƒªã‚¢ãƒ³ãƒˆã®ã‚µãƒ³ãƒ—ãƒ«æ•°ã‚’å–å¾—
        let variantSamples = variants.map { variantIndex -> (Int, Int) in
            let stats = NudgeStatsManager.shared.getStats(
                problemType: problem.rawValue,
                variantIndex: variantIndex,
                hour: hour
            )
            let samples = stats?.totalSamples ?? 0
            return (variantIndex, samples)
        }

        let minSamples = variantSamples.map { $0.1 }.min() ?? 0
        let totalSamples = variantSamples.map { $0.1 }.reduce(0, +)

        // Phase A: å…¨ãƒãƒªã‚¢ãƒ³ãƒˆãŒæœ€ä½3å›ãšã¤è©¦ã•ã‚Œã‚‹ã¾ã§
        // â†’ æœ€ã‚‚ã‚µãƒ³ãƒ—ãƒ«æ•°ãŒå°‘ãªã„ãƒãƒªã‚¢ãƒ³ãƒˆã‚’å„ªå…ˆ
        if minSamples < 3 {
            let leastTested = variantSamples.filter { $0.1 == minSamples }
            if let selected = leastTested.randomElement() {
                logger.info("Phase A (exploration): selected least tested variant \(selected.0)")
                return selected.0
            }
        }

        // Phase B: å…¨ãƒãƒªã‚¢ãƒ³ãƒˆãŒ3å›ä»¥ä¸Š & åˆè¨ˆ15å›æœªæº€
        // â†’ 50%æ´»ç”¨ / 50%æ¢ç´¢
        if totalSamples < 15 {
            if Double.random(in: 0...1) < 0.5 {
                logger.info("Phase B (50/50): exploitation")
                return selectByTapRate(variants: variants, problem: problem, hour: hour)
            } else {
                logger.info("Phase B (50/50): exploration")
                return variants.randomElement() ?? variants[0]
            }
        }

        // Phase C: åˆè¨ˆ15å›ä»¥ä¸Š
        // â†’ 80%æ´»ç”¨ / 20%æ¢ç´¢
        if Double.random(in: 0...1) < 0.8 {
            logger.info("Phase C (80/20): exploitation")
            return selectByTapRate(variants: variants, problem: problem, hour: hour)
        } else {
            logger.info("Phase C (80/20): exploration")
            return variants.randomElement() ?? variants[0]
        }
    }

    /// tapç‡ãƒ™ãƒ¼ã‚¹ã§é¸æŠ
    private func selectByTapRate(variants: [Int], problem: ProblemType, hour: Int) -> Int {
        let variantRates = variants.map { variantIndex -> (Int, Double) in
            let stats = NudgeStatsManager.shared.getStats(
                problemType: problem.rawValue,
                variantIndex: variantIndex,
                hour: hour
            )
            let tapRate = stats?.tapRate ?? 0.5
            return (variantIndex, tapRate)
        }

        // æœ€é«˜tapç‡ã®ãƒãƒªã‚¢ãƒ³ãƒˆã‚’é¸æŠ
        if let best = variantRates.max(by: { $0.1 < $1.1 }) {
            return best.0
        }

        return variants[0]
    }

    // MARK: - Content Selection (Task 8)

    /// ğŸ‘ç‡ãƒ™ãƒ¼ã‚¹ã§detailã‚’é¸æŠï¼ˆé€šçŸ¥ã¨ãƒšã‚¢ãªã®ã§åŒã˜variantIndexã‚’ä½¿ç”¨ï¼‰
    /// Phase 4ã§ã¯ãƒšã‚¢ã®ã¾ã¾é‹ç”¨ã€‚å°†æ¥çš„ã«åˆ†é›¢å¯èƒ½ã€‚
    func selectContentVariant(for problem: ProblemType, notificationVariant: Int) -> Int {
        // ç¾åœ¨ã¯notificationã¨detailã¯ãƒšã‚¢
        return notificationVariant
    }

    /// è¤‡åˆã‚¹ã‚³ã‚¢ã§é¸æŠï¼ˆtapç‡ 70% + ğŸ‘ç‡ 30%ï¼‰
    func selectByCompositeScore(variants: [Int], problem: ProblemType, hour: Int) -> Int {
        let variantScores = variants.map { variantIndex -> (Int, Double) in
            let stats = NudgeStatsManager.shared.getStats(
                problemType: problem.rawValue,
                variantIndex: variantIndex,
                hour: hour
            )
            let tapRate = stats?.tapRate ?? 0.5
            let thumbsUpRate = stats?.thumbsUpRate ?? 0.5
            let score = tapRate * 0.7 + thumbsUpRate * 0.3
            return (variantIndex, score)
        }

        if let best = variantScores.max(by: { $0.1 < $1.1 }) {
            return best.0
        }

        return variants[0]
    }
}
```

---

## Task 8: ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹Contenté¸æŠ

### ä¿®æ­£ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/MainTabView.swift`

NudgeCardè¡¨ç¤ºéƒ¨åˆ†ã‚’æ¢ã—ã€onFeedback ã®å‡¦ç†ã‚’è¿½åŠ ã€‚

Task 11 ã®å®Œå…¨ãª MainTabView ãƒ‘ãƒƒãƒã«å«ã¾ã‚Œã‚‹ã€‚

---

## Task 9: ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–

### ä¿®æ­£ç®‡æ‰€

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Notifications/ProblemNotificationScheduler.swift`

`scheduleNotifications` ãƒ¡ã‚½ãƒƒãƒ‰å†…ã§ã‚¿ã‚¤ãƒŸãƒ³ã‚°èª¿æ•´ã‚’è¿½åŠ ï¼š

```swift
// To-Be: scheduleNotifications ãƒ¡ã‚½ãƒƒãƒ‰å…¨ä½“

func scheduleNotifications(for problems: [String]) async {
    await removeAllProblemNotifications()

    // â˜… é‡è¦: Free ãƒ—ãƒ©ãƒ³ã‹ã¤æœˆé–“ä¸Šé™åˆ°é”æ¸ˆã¿ã®å ´åˆã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã—ãªã„
    let canSchedule = await MainActor.run { AppState.shared.canReceiveNudge }

    if !canSchedule {
        logger.info("Monthly nudge limit reached (Free plan). No notifications scheduled.")
        return
    }

    var allSchedules: [(time: (hour: Int, minute: Int), problem: ProblemType)] = []

    for problemRaw in problems {
        guard let problem = ProblemType(rawValue: problemRaw) else { continue }

        for time in problem.notificationSchedule {
            var adjustedHour = time.hour
            var adjustedMinute = time.minute

            // ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–: 2æ—¥é€£ç¶šignoredãªã‚‰ã‚·ãƒ•ãƒˆ
            let consecutiveIgnored = await MainActor.run {
                NudgeStatsManager.shared.getConsecutiveIgnoredDays(problemType: problemRaw, hour: time.hour)
            }

            if consecutiveIgnored >= 2 {
                // 30åˆ†å¾Œã‚ã«ã‚·ãƒ•ãƒˆ
                adjustedMinute += 30
                if adjustedMinute >= 60 {
                    adjustedMinute -= 60
                    adjustedHour = (adjustedHour + 1) % 24
                }
                logger.info("Shifted \(problemRaw) from \(time.hour):\(time.minute) to \(adjustedHour):\(adjustedMinute) due to \(consecutiveIgnored) consecutive ignored days")
            }

            allSchedules.append((time: (adjustedHour, adjustedMinute), problem: problem))
        }
    }

    // æ™‚åˆ»ã§ã‚½ãƒ¼ãƒˆ
    allSchedules.sort { $0.time.hour * 60 + $0.time.minute < $1.time.hour * 60 + $1.time.minute }

    // 30åˆ†ä»¥å†…ã«è¢«ã‚‹å ´åˆã¯15åˆ†ãšã‚‰ã—ã¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
    var lastScheduledMinutes: Int?
    var scheduledCount = 0

    for schedule in allSchedules {
        var hour = schedule.time.hour
        var minute = schedule.time.minute
        var currentMinutes = hour * 60 + minute

        if let last = lastScheduledMinutes {
            if currentMinutes < last + minimumIntervalMinutes {
                currentMinutes = last + 15
                hour = (currentMinutes / 60) % 24
                minute = currentMinutes % 60
                logger.info("Shifted \(schedule.problem.rawValue) to \(hour):\(minute) to avoid collision")
            }
        }

        guard schedule.problem.isValidTime(hour: hour, minute: minute) else {
            logger.info("Skipped \(schedule.problem.rawValue) at \(hour):\(minute) - outside valid time range")
            continue
        }

        await scheduleNotification(
            for: schedule.problem,
            hour: hour,
            minute: minute
        )

        lastScheduledMinutes = currentMinutes
        scheduledCount += 1
    }

    logger.info("Scheduled \(scheduledCount) problem notifications")
}
```

---

## Task 10: èª²é‡‘ãƒ­ã‚¸ãƒƒã‚¯

### èƒŒæ™¯ãƒ»ãªãœã“ã‚Œã‚’ã‚„ã‚‹ã‹

Aniccaã®æ–°ã—ã„èª²é‡‘ãƒ¢ãƒ‡ãƒ«ã¯ã€ŒNudgeCardå®Œäº†å›æ•°ãƒ™ãƒ¼ã‚¹ã€:

| ãƒ—ãƒ©ãƒ³ | æœˆé–“å›æ•° | ä¸Šé™åˆ°é”å¾Œ |
|--------|------------|-----------|
| Free | 10å›/æœˆ | **é€šçŸ¥è‡ªä½“ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œãªã„** |
| Pro | ç„¡åˆ¶é™ | - |

**é‡è¦ãªè¨­è¨ˆæ±ºå®š**:

1. é€šçŸ¥ã¨ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ï¼ˆNudgeCardï¼‰ã¯å®Œå…¨ã«ãƒšã‚¢
2. `monthlyNudgeCount` ã¯ **NudgeCardå®Œäº†æ™‚** ã«ã‚«ã‚¦ãƒ³ãƒˆï¼ˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ™‚ã§ã¯ãªã„ï¼‰
3. 10å›å®Œäº†å¾Œã€å…¨é€šçŸ¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã€å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ™‚ã«ãƒ–ãƒ­ãƒƒã‚¯

### ãƒ•ãƒ­ãƒ¼

```
ã€Freeãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æœˆé–“ãƒ•ãƒ­ãƒ¼ã€‘

æœˆåˆã‚:
  monthlyNudgeCount = 0
  canReceiveNudge = true
  â†’ é€šçŸ¥ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚Œã‚‹

1å›ç›®ã€œ9å›ç›®:
  é€šçŸ¥é…ä¿¡ â†’ ã‚¿ãƒƒãƒ— â†’ NudgeCardè¡¨ç¤º â†’ å®Œäº†
  monthlyNudgeCount += 1

10å›ç›®:
  é€šçŸ¥é…ä¿¡ â†’ ã‚¿ãƒƒãƒ— â†’ NudgeCardè¡¨ç¤º â†’ å®Œäº†
  monthlyNudgeCount = 10
  â†’ Paywallè¡¨ç¤º (nudge_card_complete_10)
  â†’ å…¨é€šçŸ¥ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  canReceiveNudge = false

11å›ç›®ä»¥é™:
  é€šçŸ¥ãŒæ—¢ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿
  æ¬¡å›ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ™‚ã‚‚ canReceiveNudge = false ã§ãƒ–ãƒ­ãƒƒã‚¯

æœˆãŒå¤‰ã‚ã‚‹:
  checkAndResetMonthlyNudgeCountIfNeeded() å®Ÿè¡Œ
  monthlyNudgeCount = 0
  canReceiveNudge = true
  â†’ é€šçŸ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«å†é–‹
```

### ä¿®æ­£ç®‡æ‰€ 1: AppState.swiftï¼ˆã‚«ã‚¦ãƒ³ã‚¿ãƒ¼è¿½åŠ ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/AppState.swift`

ä»¥ä¸‹ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã¨ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è¿½åŠ ï¼š

```swift
// MARK: - Nudge Card / Paywall / Review (Phase 4)

/// NudgeCardå®Œäº†å›æ•°ï¼ˆç´¯è¨ˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»Paywallè¡¨ç¤ºåˆ¤å®šç”¨ï¼‰
@Published private(set) var nudgeCardCompletedCount: Int = 0

/// æœˆé–“NudgeCardå®Œäº†å›æ•°ï¼ˆé€šçŸ¥åˆ¶é™ç”¨ã€æœˆåˆãƒªã‚»ãƒƒãƒˆï¼‰
@Published private(set) var monthlyNudgeCount: Int = 0

/// ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ¸ˆã¿ãƒ•ãƒ©ã‚°
@Published private(set) var hasRequestedReview: Bool = false

// UserDefaultsã‚­ãƒ¼
private let nudgeCardCompletedCountKey = "com.anicca.nudgeCardCompletedCount"
private let monthlyNudgeCountKey = "com.anicca.monthlyNudgeCount"
private let hasRequestedReviewKey = "com.anicca.hasRequestedReview"
private let lastNudgeResetMonthKey = "com.anicca.lastNudgeResetMonth"
private let lastNudgeResetYearKey = "com.anicca.lastNudgeResetYear"

// MARK: - Nudge Card / Paywall / Review Methods

/// NudgeCardå®Œäº†å›æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
func incrementNudgeCardCompletedCount() {
    nudgeCardCompletedCount += 1
    defaults.set(nudgeCardCompletedCount, forKey: nudgeCardCompletedCountKey)
}

/// æœˆé–“NudgeCardå®Œäº†å›æ•°ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
func incrementMonthlyNudgeCount() {
    monthlyNudgeCount += 1
    defaults.set(monthlyNudgeCount, forKey: monthlyNudgeCountKey)
}

/// ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆæ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
func markReviewRequested() {
    hasRequestedReview = true
    defaults.set(true, forKey: hasRequestedReviewKey)
}

/// æœˆé–“NudgeCardå®Œäº†å›æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
func resetMonthlyNudgeCount() {
    monthlyNudgeCount = 0
    defaults.set(0, forKey: monthlyNudgeCountKey)
}

/// Nudgeå—ä¿¡å¯èƒ½ã‹ã©ã†ã‹
var canReceiveNudge: Bool {
    if subscriptionInfo.plan == .pro { return true }
    return monthlyNudgeCount < 10
}

/// æœˆåˆãƒªã‚»ãƒƒãƒˆãƒã‚§ãƒƒã‚¯ï¼ˆã‚¢ãƒ—ãƒªèµ·å‹•æ™‚ã«å‘¼ã³å‡ºã™ï¼‰
func checkAndResetMonthlyNudgeCountIfNeeded() {
    let calendar = Calendar.current
    let now = Date()
    let currentMonth = calendar.component(.month, from: now)
    let currentYear = calendar.component(.year, from: now)

    let lastMonth = defaults.integer(forKey: lastNudgeResetMonthKey)
    let lastYear = defaults.integer(forKey: lastNudgeResetYearKey)

    if currentYear != lastYear || currentMonth != lastMonth {
        resetMonthlyNudgeCount()
        defaults.set(currentMonth, forKey: lastNudgeResetMonthKey)
        defaults.set(currentYear, forKey: lastNudgeResetYearKey)

        // æœˆãŒå¤‰ã‚ã£ãŸã‚‰é€šçŸ¥ã‚’å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        Task {
            await ProblemNotificationScheduler.shared.scheduleNotifications(for: userProfile.struggles)
        }
    }
}
```

**init() å†…ã«è¿½åŠ **ï¼š

```swift
// init() å†…ã«è¿½åŠ 
self.nudgeCardCompletedCount = defaults.integer(forKey: nudgeCardCompletedCountKey)
self.monthlyNudgeCount = defaults.integer(forKey: monthlyNudgeCountKey)
self.hasRequestedReview = defaults.bool(forKey: hasRequestedReviewKey)

// æœˆåˆãƒªã‚»ãƒƒãƒˆãƒã‚§ãƒƒã‚¯
checkAndResetMonthlyNudgeCountIfNeeded()
```

### ä¿®æ­£ç®‡æ‰€ 2: ProblemNotificationScheduler.swiftï¼ˆä¸Šé™åˆ°é”æ™‚ã®ãƒ–ãƒ­ãƒƒã‚¯ï¼‰

**ã“ã®ãƒ‘ãƒƒãƒã¯ Task 9 ã«çµ±åˆæ¸ˆã¿**ã€‚`scheduleNotifications` ãƒ¡ã‚½ãƒƒãƒ‰ã®å…ˆé ­ã§ `canReceiveNudge` ã‚’ãƒã‚§ãƒƒã‚¯ã€‚

---

## Task 11: Paywall Placementæ›´æ–°

### ä¿®æ­£ç®‡æ‰€ 1: SuperwallManager.swift

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Services/SuperwallManager.swift`

```swift
// As-Is (ç¾çŠ¶ã®enum)
enum SuperwallPlacement: String {
    case onboardingComplete = "onboarding_complete"
    case sessionComplete1 = "session_complete_1"
    case sessionComplete3 = "session_complete_3"
    case campaignAppLaunch = "campaign_app_launch"
    case profilePlanTap = "profile_plan_tap"
    case quotaExceeded = "quota_exceeded"
}

// To-Be
enum SuperwallPlacement: String {
    case onboardingComplete = "onboarding_complete"
    case nudgeCardComplete5 = "nudge_card_complete_5"
    case nudgeCardComplete10 = "nudge_card_complete_10"
    case profilePlanTap = "profile_plan_tap"
}
```

### ä¿®æ­£ç®‡æ‰€ 2: MainTabView.swiftï¼ˆå®Œå…¨ãªãƒ‘ãƒƒãƒï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/MainTabView.swift`

```swift
import SwiftUI
import UIKit
import Combine
import StoreKit

struct MainTabView: View {
    @EnvironmentObject private var appState: AppState

    var body: some View {
        Group {
            switch appState.selectedRootTab {
            case .myPath:
                MyPathTabView()
                    .environmentObject(appState)
            case .profile:
                ProfileView()
                    .environmentObject(appState)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        // Proactive Agent: NudgeCardè¡¨ç¤º
        .fullScreenCover(item: $appState.pendingNudgeCard) { content in
            NudgeCardView(
                content: content,
                onPositiveAction: {
                    handleNudgeCardCompletion(content: content)
                },
                onNegativeAction: {
                    handleNudgeCardCompletion(content: content)
                },
                onFeedback: { isPositive in
                    if isPositive {
                        NudgeStatsManager.shared.recordThumbsUp(
                            problemType: content.problemType.rawValue,
                            variantIndex: content.variantIndex
                        )
                    } else {
                        NudgeStatsManager.shared.recordThumbsDown(
                            problemType: content.problemType.rawValue,
                            variantIndex: content.variantIndex
                        )
                    }
                },
                onDismiss: {
                    appState.dismissNudgeCard()
                }
            )
        }
        .safeAreaInset(edge: .bottom) {
            FigmaTabBar(selectedTab: $appState.selectedRootTab)
        }
        .background(AppBackground())
        .ignoresSafeArea(.keyboard, edges: .bottom)
    }

    // MARK: - NudgeCard Completion Handler

    private func handleNudgeCardCompletion(content: NudgeContent) {
        // ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
        appState.incrementNudgeCardCompletedCount()

        // Freeãƒ—ãƒ©ãƒ³ã®å ´åˆã€æœˆé–“ã‚«ã‚¦ãƒ³ãƒˆã‚‚ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆ
        if appState.subscriptionInfo.plan != .pro {
            appState.incrementMonthlyNudgeCount()
        }

        let count = appState.nudgeCardCompletedCount
        let monthlyCount = appState.monthlyNudgeCount
        let plan = appState.subscriptionInfo.plan

        // NudgeCardã‚’é–‰ã˜ã‚‹
        appState.dismissNudgeCard()

        // 3å›ç›®: ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
        if count == 3 && !appState.hasRequestedReview {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                if let scene = UIApplication.shared.connectedScenes
                    .first(where: { $0.activationState == .foregroundActive }) as? UIWindowScene {
                    SKStoreReviewController.requestReview(in: scene)
                }
            }
            appState.markReviewRequested()
            return
        }

        // 5å›ç›®: Paywall
        if count == 5 && plan != .pro {
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                SuperwallManager.shared.register(placement: SuperwallPlacement.nudgeCardComplete5.rawValue)
            }
            return
        }

        // 10å›ç›®ï¼ˆæœˆé–“ï¼‰: Paywall + é€šçŸ¥ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        if monthlyCount >= 10 && plan != .pro {
            // å…¨é€šçŸ¥ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            Task {
                await ProblemNotificationScheduler.shared.cancelAllNotifications()
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                SuperwallManager.shared.register(placement: SuperwallPlacement.nudgeCardComplete10.rawValue)
            }
            return
        }
    }
}
```

---

## ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹

### Task 0: AnalyticsEvent

- [ ] ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ãªã—ï¼ˆ.nudgeTapped, .nudgeIgnored, .nudgeFeedback ãŒå­˜åœ¨ï¼‰

### Task 1: è¨€èªå•é¡Œ

- [ ] ç«¯æœ«ã‚’è‹±èªã«è¨­å®š â†’ é€šçŸ¥ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« â†’ ç«¯æœ«ã‚’æ—¥æœ¬èªã«å¤‰æ›´ â†’ é€šçŸ¥ã‚¿ãƒƒãƒ— â†’ NudgeCardè¡¨ç¤º â†’ **æ—¥æœ¬èªã§è¡¨ç¤ºã•ã‚Œã‚‹**

### Task 2: æ™‚åˆ»ç‰¹æœ‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

- [ ] stayingUpLate 21:00 â†’ variant 0, 1, 2 ã®ã„ãšã‚Œã‹
- [ ] stayingUpLate 0:00 â†’ **å¿…ãšvariant 3**ã€Œæ·±å¤œ0æ™‚ã‚’éãã¾ã—ãŸã€
- [ ] stayingUpLate 1:00 â†’ **å¿…ãšvariant 4**ã€Œæ·±å¤œ1æ™‚ã§ã™ã€

### Task 3: ã‚«ãƒƒã‚³å‰Šé™¤

- [ ] NudgeCardè¡¨ç¤º â†’ é€šçŸ¥ãƒ†ã‚­ã‚¹ãƒˆã«ã€Œã€ãŒãªã„

### Task 4-5: ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°

- [ ] é€šçŸ¥ã‚¿ãƒƒãƒ— â†’ NudgeStats.tappedCount +1
- [ ] 24æ™‚é–“çµŒé & æœªã‚¿ãƒƒãƒ— â†’ ã‚¢ãƒ—ãƒªèµ·å‹• â†’ NudgeStats.ignoredCount +1

### Task 6-8: ãƒ«ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹é¸æŠ

- [ ] åˆå›5å› â†’ å„ãƒãƒªã‚¢ãƒ³ãƒˆãŒå‡ç­‰ã«è©¦ã•ã‚Œã‚‹
- [ ] 15å›å¾Œ â†’ tapç‡ãŒé«˜ã„ãƒãƒªã‚¢ãƒ³ãƒˆãŒ80%é¸ã°ã‚Œã‚‹
- [ ] ğŸ‘ã‚¿ãƒƒãƒ— â†’ thumbsUpCount +1

### Task 9: ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–

- [ ] 2æ—¥é€£ç¶šignored â†’ æ¬¡å›ã¯30åˆ†å¾Œã‚ã«ã‚·ãƒ•ãƒˆ

### Task 10-11: èª²é‡‘

- [ ] NudgeCard 3å›ç›®å®Œäº† â†’ ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
- [ ] NudgeCard 5å›ç›®å®Œäº† (Free) â†’ Paywallè¡¨ç¤º
- [ ] NudgeCard 10å›ç›®å®Œäº† (Free) â†’ Paywallè¡¨ç¤º + é€šçŸ¥ã‚­ãƒ£ãƒ³ã‚»ãƒ«
- [ ] æœˆãŒå¤‰ã‚ã‚‹ â†’ monthlyNudgeCount ãƒªã‚»ãƒƒãƒˆ â†’ é€šçŸ¥å†ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

---

## å®Ÿè£…é †åº

1. **Task 0**: AnalyticsManager.swiftï¼ˆã‚¤ãƒ™ãƒ³ãƒˆã‚±ãƒ¼ã‚¹è¿½åŠ ï¼‰
2. **Task 6**: NudgeStatsManager.swift æ–°è¦ä½œæˆ
3. **Task 7**: NudgeContentSelector.swift æ–°è¦ä½œæˆ
4. **Task 10-a**: AppState.swift ä¿®æ­£ï¼ˆèª²é‡‘ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼è¿½åŠ ï¼‰
5. **Task 1 + Task 9**: ProblemNotificationScheduler.swift ä¿®æ­£ï¼ˆè¨€èªå•é¡Œ + ä¸Šé™ãƒã‚§ãƒƒã‚¯ + ã‚¿ã‚¤ãƒŸãƒ³ã‚°æœ€é©åŒ–ï¼‰
6. **Task 1**: NudgeContent.swift ä¿®æ­£
7. **Task 3**: NudgeCardView.swift ä¿®æ­£
8. **Task 4**: AppDelegate.swift ä¿®æ­£
9. **Task 5**: AppState.swift ä¿®æ­£ï¼ˆèµ·å‹•æ™‚ãƒã‚§ãƒƒã‚¯è¿½åŠ ï¼‰
10. **Task 11**: SuperwallManager.swift ä¿®æ­£
11. **Task 8 + Task 11**: MainTabView.swift ä¿®æ­£ï¼ˆå®Œå…¨ãªãƒ‘ãƒƒãƒï¼‰

---

## æ³¨æ„äº‹é …

### ãƒ­ãƒ¼ã‚«ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³

- `Localizable.strings` ã®å¤‰æ›´ã¯ä¸è¦
- æ—¢å­˜ã®ã‚­ãƒ¼ï¼ˆ`nudge_*_notification_*`, `nudge_*_detail_*`ï¼‰ã‚’ãã®ã¾ã¾ä½¿ç”¨
- ã‚­ãƒ¼ã¯ `nudge_{problem_rawValue}_notification_{variantIndex+1}` ã®å½¢å¼

### å¾Œæ–¹äº’æ›æ€§

- `NudgeContent.nudgeContent(from:)` ã¯å¤ã„å½¢å¼ï¼ˆæ–‡å­—åˆ—ç›´æ¥ä¿å­˜ï¼‰ã‚‚ã‚µãƒãƒ¼ãƒˆ
- æ—¢ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã•ã‚ŒãŸé€šçŸ¥ã¯å¤ã„å½¢å¼ã§å‹•ä½œã—ç¶šã‘ã‚‹

### Superwall Dashboard

å®Ÿè£…å¾Œã€ä»¥ä¸‹ã®è¨­å®šãŒå¿…è¦ï¼š

1. **æ–°è¦Placementè¿½åŠ **
   - `nudge_card_complete_5`
   - `nudge_card_complete_10`

2. **Placementå‰Šé™¤**ï¼ˆä½¿ç”¨ã•ã‚Œãªããªã‚‹ï¼‰
   - `session_complete_1`
   - `session_complete_3`
   - `campaign_app_launch`
   - `quota_exceeded`

---

## Superwall Dashboard è¨­å®šï¼ˆæ‰‹å‹•ä½œæ¥­ï¼‰

ã‚³ãƒ¼ãƒ‰å®Ÿè£…å¾Œã€ä»¥ä¸‹ã®GUIè¨­å®šãŒå¿…è¦ã€‚

### 1. æ–°è¦Placementè¿½åŠ 

**Dashboard â†’ Placements â†’ Create Placement**

| Placement Name | Identifier | ç”¨é€” |
|----------------|------------|------|
| NudgeCard Complete 5 | `nudge_card_complete_5` | 5å›ç›®å®Œäº†æ™‚ã«Paywallè¡¨ç¤º |
| NudgeCard Complete 10 | `nudge_card_complete_10` | 10å›ç›®å®Œäº†æ™‚ï¼ˆæœˆä¸Šé™ï¼‰ã«Paywallè¡¨ç¤º |

### 2. Campaignè¨­å®š

**Dashboard â†’ Campaigns â†’ Create Campaignï¼ˆã¾ãŸã¯æ—¢å­˜ã‚’ç·¨é›†ï¼‰**

#### nudge_card_complete_5 ç”¨

1. **Name**: NudgeCard 5 Paywall
2. **Trigger**: `nudge_card_complete_5`
3. **Paywall**: ä½¿ç”¨ã™ã‚‹Paywallã‚’é¸æŠ
4. **Audience**: All Users
5. **Save**

#### nudge_card_complete_10 ç”¨

1. **Name**: NudgeCard 10 Paywall
2. **Trigger**: `nudge_card_complete_10`
3. **Paywall**: ä½¿ç”¨ã™ã‚‹Paywallã‚’é¸æŠ
4. **Audience**: All Users
5. **Save**

### 3. Paywallæ–‡è¨€æ›´æ–°ï¼ˆæ¨å¥¨ï¼‰

**Dashboard â†’ Paywalls â†’ å¯¾è±¡Paywall â†’ Edit**

| é …ç›® | æ–°ã—ã„æ–‡è¨€ |
|------|----------|
| Headline | "Unlimited nudges, unlimited change." |
| Value Prop 1 | "Learns what hits you" |
| Value Prop 2 | "Catches you before you fall" |
| Value Prop 3 | "Stays one step ahead" |
| CTA Button | "Get unlimited nudges" |

### 4. å¤ã„Placementç„¡åŠ¹åŒ–

ä»¥ä¸‹ã®Placementã¯ã‚³ãƒ¼ãƒ‰ã‹ã‚‰å‘¼ã°ã‚Œãªããªã‚‹ã€‚Campaignã‹ã‚‰å¤–ã™ã‹å‰Šé™¤ï¼ˆä»»æ„ï¼‰ï¼š

- `session_complete_1`
- `session_complete_3`
- `campaign_app_launch`
- `quota_exceeded`

**æ³¨æ„**: å‰Šé™¤ã—ãªãã¦ã‚‚å‹•ä½œã«å½±éŸ¿ãªã—ã€‚ã‚³ãƒ¼ãƒ‰ã‹ã‚‰å‘¼ã°ã‚Œãªã„ã ã‘ã€‚

### 5. ãƒ†ã‚¹ãƒˆæ‰‹é †

1. Sandboxã‚¢ã‚«ã‚¦ãƒ³ãƒˆã§ã‚¢ãƒ—ãƒªèµ·å‹•
2. ã‚ªãƒ³ãƒœãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Œäº†
3. NudgeCard 5å›å®Œäº† â†’ **Paywallè¡¨ç¤ºã‚’ç¢ºèª**
4. Paywallé–‰ã˜ã‚‹
5. NudgeCard 10å›å®Œäº† â†’ **Paywallè¡¨ç¤ºã‚’ç¢ºèª** + **é€šçŸ¥ãŒæ¥ãªããªã‚‹ã“ã¨ã‚’ç¢ºèª**
6. èª²é‡‘å®Œäº† â†’ Paywalléè¡¨ç¤ºã‚’ç¢ºèª

---

## ä½œæ¥­åˆ†æ‹…ã¾ã¨ã‚

| æ‹…å½“ | ä½œæ¥­å†…å®¹ |
|------|---------|
| **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆã‚³ãƒ¼ãƒ‰ï¼‰** | å…¨12ã‚¿ã‚¹ã‚¯ã®å®Ÿè£…ï¼ˆTask 0ã€œ11ï¼‰ |
| **ã‚ãªãŸï¼ˆGUIï¼‰** | Superwall Dashboardè¨­å®šï¼ˆPlacementè¿½åŠ ã€Campaignè¨­å®šï¼‰ |

---

*ã“ã®æ–‡æ›¸ã¯ Phase 4 ã®å®Œå…¨ãªå®Ÿè£…ä»•æ§˜ã§ã‚ã‚‹ã€‚è¿½åŠ ã®è³ªå•ãªã—ã§å®Ÿè£…å¯èƒ½ã€‚*
