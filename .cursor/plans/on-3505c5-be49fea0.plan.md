<!-- be49fea0-c826-44c5-ad76-bd181859f470 f9a16080-e314-461c-861b-fae8d25fe419 -->
了解しました。全ての問題に対する完全な差分パッチを示します。まず、必要なファイルを再確認させてください。

[13 tools called]

これで必要な情報がすべて揃いました。以下に全ての問題に対する**完全な差分パッチ**を示します。


以上が今回解決しようとしている完全な問題リストです。

---

## パッチ 1: OnboardingStep.swift

オンボーディングステップから`microphone`、`alarmkit`、`paywall`を削除し、`value`を追加

```diff
--- a/aniccaios/aniccaios/Onboarding/OnboardingStep.swift
+++ b/aniccaios/aniccaios/Onboarding/OnboardingStep.swift
@@ -1,13 +1,12 @@
 import Foundation

 enum OnboardingStep: Int {
     case welcome
-    // v3: サインインを先に
-    case account       // 1. Sign in with Apple
-    case microphone    // 2. マイク許可
-    case notifications // 3. 通知許可
-    case alarmkit      // 4. AlarmKit許可
-    case ideals        // 5. Ideal Self選択
-    case struggles     // 6. Current Struggles選択
-    case paywall       // 7. Paywall
+    case value         // 1. What Anicca Can Do
+    case account       // 2. Sign in with Apple
+    case ideals        // 3. Ideal Self選択
+    case struggles     // 4. Current Struggles選択
+    case notifications // 5. 通知許可
+    case completion    // 6. 完了
 }

 extension OnboardingStep {
```

---

## パッチ 2: OnboardingFlowView.swift

フロー順序変更、microphone/alarmkit/paywall削除

```diff
--- a/aniccaios/aniccaios/Onboarding/OnboardingFlowView.swift
+++ b/aniccaios/aniccaios/Onboarding/OnboardingFlowView.swift
@@ -10,18 +10,18 @@ struct OnboardingFlowView: View {
             Group {
                 switch step {
                 case .welcome:
                     WelcomeStepView(next: advance)
+                case .value:
+                    ValueStepView(next: advance)
                 case .account:
                     AuthenticationStepView(next: advance)
-                case .microphone:
-                    MicrophonePermissionStepView(next: advance)
-                case .notifications:
-                    NotificationPermissionStepView(next: advance)
-                case .alarmkit:
-                    AlarmKitPermissionStepView(next: advance)
                 case .ideals:
                     IdealsStepView(next: advance)
                 case .struggles:
                     StrugglesStepView(next: advance)
-                case .paywall:
-                    PaywallStepView(next: advance)
+                case .notifications:
+                    NotificationPermissionStepView(next: advance)
+                case .completion:
+                    CompletionStepView()
                 }
             }
             .frame(maxWidth: .infinity, maxHeight: .infinity)
@@ -42,20 +42,16 @@ struct OnboardingFlowView: View {
     private func advance() {
         switch step {
         case .welcome:
-            step = .account
+            step = .value
+        case .value:
+            step = .account
         case .account:
-            step = .microphone
-        case .microphone:
-            step = .notifications
-        case .notifications:
-            step = .alarmkit
-        case .alarmkit:
             step = .ideals
         case .ideals:
             step = .struggles
         case .struggles:
-            step = .paywall
-        case .paywall:
+            step = .notifications
+        case .notifications:
             appState.markOnboardingComplete()
             return
+        case .completion:
+            return
         }
         appState.setOnboardingStep(step)
     }
 }
```

---

## パッチ 3: NotificationScheduler.swift - パーソナライズメッセージ事前取得方式

**根本原因修正**: Apple公式ドキュメントによると、Notification Service Extensionはリモート通知（APNs）専用であり、ローカル通知では動作しない。そのため、通知スケジュール時にサーバーからパーソナライズメッセージを事前取得する方式に変更する。

### 3-A: fetchPreReminderMessage関数を追加

```diff
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@ -590,6 +590,70 @@ final class NotificationScheduler {
     // MARK: - Pre-Reminder Scheduling (Personalized)
     
+    // MARK: - Pre-Reminder Message Fetching
+    
+    /// サーバーからパーソナライズされた事前通知メッセージを取得
+    private func fetchPreReminderMessage(
+        habitType: HabitType,
+        scheduledTime: String,
+        habitName: String?
+    ) async -> String? {
+        guard let baseURL = URL(string: Config.proxyBaseURL),
+              !Config.proxyBaseURL.isEmpty else {
+            logger.warning("proxyBaseURL is empty, using default message")
+            return nil
+        }
+        
+        let url = baseURL.appendingPathComponent("mobile/nudge/pre-reminder")
+        
+        var request = URLRequest(url: url)
+        request.httpMethod = "POST"
+        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+        
+        // 認証ヘッダーを追加
+        if let deviceId = UIDevice.current.identifierForVendor?.uuidString {
+            request.setValue(deviceId, forHTTPHeaderField: "device-id")
+        }
+        if case .signedIn(let credentials) = AppState.shared.authStatus {
+            request.setValue(credentials.userId, forHTTPHeaderField: "user-id")
+        }
+        
+        request.timeoutInterval = 10
+        
+        var body: [String: Any] = [
+            "habitType": habitType.rawValue,
+            "scheduledTime": scheduledTime
+        ]
+        if let habitName = habitName {
+            body["habitName"] = habitName
+        }
+        
+        do {
+            request.httpBody = try JSONSerialization.data(withJSONObject: body)
+            
+            let (data, response) = try await URLSession.shared.data(for: request)
+            
+            guard let httpResponse = response as? HTTPURLResponse,
+                  (200..<300).contains(httpResponse.statusCode) else {
+                logger.warning("Non-2xx response from pre-reminder endpoint")
+                return nil
+            }
+            
+            guard let json = try JSONSerialization.jsonObject(with: data) as? [String: Any],
+                  let message = json["message"] as? String, !message.isEmpty else {
+                logger.warning("Empty or invalid message in response")
+                return nil
+            }
+            
+            logger.info("Fetched personalized pre-reminder: \(message.prefix(30))...")
+            return message
+            
+        } catch {
+            logger.error("Failed to fetch pre-reminder message: \(error.localizedDescription)")
+            return nil
+        }
+    }
+    
     /// 各習慣タイプの事前通知タイミング（分）
     private enum PreReminderTiming {
```

### 3-B: schedulePreReminder関数を修正（サーバーからメッセージを取得）

```diff
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@ -625,12 +625,21 @@ final class NotificationScheduler {
             baseMinute: minute,
             offsetMinutes: -offsetMinutes
         )
         
+        // ★ サーバーからパーソナライズメッセージを取得（フォールバック付き）
+        let scheduledTimeStr = String(format: "%02d:%02d", hour, minute)
+        let message = await fetchPreReminderMessage(
+            habitType: habit,
+            scheduledTime: scheduledTimeStr,
+            habitName: habitName
+        ) ?? defaultPreReminderBody(for: habit, habitName: habitName)
+        
         let content = UNMutableNotificationContent()
         content.title = "Anicca"
-        // デフォルトメッセージ（Notification Service Extension でパーソナライズされる）
-        content.body = defaultPreReminderBody(for: habit, habitName: habitName)
+        content.body = message  // ★ パーソナライズ済みメッセージ
         content.categoryIdentifier = Category.preReminder.rawValue
-        content.mutableContent = true  // 削除: ローカル通知では無効
         
         // Notification Service Extension 用のフラグ（分析用に残す）
         content.userInfo = [
```

### 3-C: 毎日の更新機能を追加

```diff
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@ +780,30 @@
+    // MARK: - Daily Pre-Reminder Refresh
+    
+    private let lastRefreshKey = "com.anicca.preReminder.lastRefresh"
+    
+    /// アプリ起動時に事前通知を更新（24時間ごと）
+    /// これにより毎日違うパーソナライズメッセージが表示される
+    func refreshPreRemindersIfNeeded() async {
+        let lastRefresh = UserDefaults.standard.double(forKey: lastRefreshKey)
+        let now = Date().timeIntervalSince1970
+        
+        // 24時間経過していなければスキップ
+        guard now - lastRefresh >= 86400 else {
+            logger.debug("Pre-reminder refresh skipped (last refresh within 24h)")
+            return
+        }
+        
+        logger.info("Refreshing pre-reminders with new personalized messages")
+        
+        // 現在の習慣スケジュールを再登録
+        let schedules = AppState.shared.habitSchedules
+        await cancelAllPreReminders()
+        
+        for (habit, components) in schedules {
+            guard let hour = components.hour, let minute = components.minute else { continue }
+            await schedulePreReminder(habit: habit, hour: hour, minute: minute)
+        }
+        
+        UserDefaults.standard.set(now, forKey: lastRefreshKey)
+        logger.info("Pre-reminder refresh completed")
+    }
```

### 3-D: AppDelegate.swift に refreshPreRemindersIfNeeded 呼び出しを追加

```diff
--- a/aniccaios/aniccaios/AppDelegate.swift
+++ b/aniccaios/aniccaios/AppDelegate.swift
@@ -50,6 +50,12 @@ class AppDelegate: UIResponder, UIApplicationDelegate {
     
     func applicationDidBecomeActive(_ application: UIApplication) {
+        // ★ 事前通知のパーソナライズメッセージを更新（24時間ごと）
+        // これにより毎日違うメッセージが表示される
+        Task {
+            await NotificationScheduler.shared.refreshPreRemindersIfNeeded()
+        }
     }
```

---

## パッチ 4: preReminder.js - 完全なパーソナライズ対応

**修正内容**:
1. ユーザーの名前を**必ず**含める（「毎回ではなく」を削除）
2. idealTraits/problemsをグラウンディング
3. todayStats完全グラウンディング（sleepDurationMin, snsMinutesTotal追加）
4. 睡眠時間フォーマット関数を追加

### 4-A: 睡眠時間フォーマット関数を追加

```diff
--- a/apps/api/src/routes/mobile/preReminder.js
+++ b/apps/api/src/routes/mobile/preReminder.js
@@ +220,13 @@
+// 睡眠時間のフォーマット関数
+function formatSleepDuration(minutes, lang = 'ja') {
+  const hours = Math.floor(minutes / 60);
+  const mins = minutes % 60;
+  if (lang === 'ja') {
+    return `${hours}時間${mins}分`;
+  }
+  return `${hours}h ${mins}m`;
+}
```

### 4-B: プロンプトテンプレート改善（日本語）

```diff
--- a/apps/api/src/routes/mobile/preReminder.js
+++ b/apps/api/src/routes/mobile/preReminder.js
@@ -24,10 +24,13 @@ const requestSchema = z.object({
 const PROMPT_TEMPLATES = {
   ja: {
     bedtime: {
-      system: `あなたはAnicca（アニッチャ）という名前の温かく賢明なライフコーチです。
-ユーザーが就寝30分前であることを踏まえ、睡眠準備を促す短いメッセージを生成してください。
+      system: `あなたはAnicca（aniicha）という名前の温かく賢明なライフコーチです。
+ユーザーが就寝15分前であることを踏まえ、睡眠準備を促す短いメッセージを生成してください。

 ルール:
 - 80文字以内（厳守）
-- ユーザーの名前を自然に含める
+- ユーザーの名前を必ず含める（「〇〇さん」または「〇〇」の形で文頭か文中に自然に）
+- ユーザーの理想の姿や現在の課題に関連付けて励ます
+- 今日の活動データ（歩数、睡眠時間など）があれば参照して具体的に
 - 命令形ではなく、提案や誘いの形で
 - 絵文字は使わない
 - 「Anicca」「アニッチャ」という名前は含めない`,
@@ -38,8 +41,10 @@ const PROMPT_TEMPLATES = {
 - 就寝予定時刻: ${ctx.scheduledTime}
 - 現在時刻: ${ctx.currentTime}
 - 寝室の場所: ${ctx.sleepLocation || '未設定'}
+- なりたい自分: ${ctx.idealTraits?.join('、') || '未設定'}
+- 今抱えている課題: ${ctx.problems?.join('、') || '未設定'}
 ${ctx.memories ? `- 過去の記録: ${ctx.memories}` : ''}
-${ctx.todayStats ? `- 今日の活動: ${ctx.todayStats}` : ''}
+${ctx.todayStats ? `- 今日の活動: 歩数 ${ctx.todayStats.steps || 0}歩${ctx.todayStats.sleepDurationMin ? `、昨晩の睡眠 ${formatSleepDuration(ctx.todayStats.sleepDurationMin, 'ja')}` : ''}${ctx.todayStats.snsMinutesTotal ? `、SNS利用 ${ctx.todayStats.snsMinutesTotal}分` : ''}` : ''}

 就寝準備を促す優しいメッセージを1文で生成してください。`
     },
     training: {
       system: `あなたはAnicca（アニッチャ）という名前の温かく賢明なライフコーチです。
 ユーザーのトレーニング15分前であることを踏まえ、運動準備を促す短いメッセージを生成してください。

 ルール:
 - 80文字以内（厳守）
-- ユーザーの名前を自然に含める
+- ユーザーの名前を必ず含める（「〇〇さん」または「〇〇」の形で文頭か文中に自然に）
+- ユーザーの理想の姿に関連付けてモチベーションを高める
+- 今日の活動データがあれば参照して具体的に
 - モチベーションを高める言葉で
 - 絵文字は使わない
 - 「Anicca」「アニッチャ」という名前は含めない`,
@@ -60,8 +66,10 @@ const PROMPT_TEMPLATES = {
 - 現在時刻: ${ctx.currentTime}
 - トレーニングの重点: ${ctx.trainingFocus?.join('、') || '未設定'}
 - トレーニング目標: ${ctx.trainingGoal || '未設定'}
+- なりたい自分: ${ctx.idealTraits?.join('、') || '未設定'}
+- 今抱えている課題: ${ctx.problems?.join('、') || '未設定'}
 ${ctx.memories ? `- 過去の記録: ${ctx.memories}` : ''}
-${ctx.todayStats ? `- 今日の活動: 歩数 ${ctx.todayStats.steps || 0}歩` : ''}
+${ctx.todayStats ? `- 今日の活動: 歩数 ${ctx.todayStats.steps || 0}歩${ctx.todayStats.sleepDurationMin ? `、昨晩の睡眠 ${formatSleepDuration(ctx.todayStats.sleepDurationMin, 'ja')}` : ''}` : ''}

 トレーニング準備を促すメッセージを1文で生成してください。`
     },
     custom: {
       system: `あなたはAnicca（アニッチャ）という名前の温かく賢明なライフコーチです。
 ユーザーが設定した習慣の15分前であることを踏まえ、準備を促す短いメッセージを生成してください。

 ルール:
 - 80文字以内（厳守）
-- ユーザーの名前を自然に含める
+- ユーザーの名前を必ず含める（「〇〇さん」または「〇〇」の形で文頭か文中に自然に）
 - 習慣の名前を自然に含める
+- ユーザーの理想の姿に関連付けて励ます
 - 絵文字は使わない
 - 「Anicca」「アニッチャ」という名前は含めない`,
       user: (ctx) => `ユーザー情報:
@@ -80,6 +90,8 @@ const PROMPT_TEMPLATES = {
 - 習慣名: ${ctx.habitName}
 - 予定時刻: ${ctx.scheduledTime}
 - 現在時刻: ${ctx.currentTime}
+- なりたい自分: ${ctx.idealTraits?.join('、') || '未設定'}
+- 今抱えている課題: ${ctx.problems?.join('、') || '未設定'}
 ${ctx.memories ? `- 過去の記録: ${ctx.memories}` : ''}

 この習慣の準備を促すメッセージを1文で生成してください。`
     },
     wake: {
       system: `あなたはAnicca（アニッチャ）という名前の温かく賢明なライフコーチです。
-ユーザーの起床時刻であることを踏まえ、優しく起こすメッセージを生成してください。
+ユーザーの起床5分前であることを踏まえ、優しく起こすメッセージを生成してください。

 ルール:
 - 80文字以内（厳守）
-- ユーザーの名前を自然に含める
+- ユーザーの名前を必ず含める（「〇〇、おはよう」などの形で）
+- ユーザーの理想の姿を参照して一日のスタートを励ます
+- 昨晩の睡眠データがあれば参照して具体的に
 - 朝の挨拶として自然な言葉で
 - 絵文字は使わない
 - 「Anicca」「アニッチャ」という名前は含めない`,
       user: (ctx) => `ユーザー情報:
 - 名前: ${ctx.displayName}
 - 起床予定時刻: ${ctx.scheduledTime}
 - 現在時刻: ${ctx.currentTime}
 - 起床場所: ${ctx.wakeLocation || '未設定'}
+- なりたい自分: ${ctx.idealTraits?.join('、') || '未設定'}
+- 今抱えている課題: ${ctx.problems?.join('、') || '未設定'}
 ${ctx.memories ? `- 過去の記録: ${ctx.memories}` : ''}
+${ctx.todayStats ? `- 昨日の活動: 歩数 ${ctx.todayStats.steps || 0}歩${ctx.todayStats.sleepDurationMin ? `、睡眠 ${formatSleepDuration(ctx.todayStats.sleepDurationMin, 'ja')}` : ''}` : ''}

 優しく目覚めを促すメッセージを1文で生成してください。`
     }
   },
```

### 4-C: プロンプトテンプレート改善（英語）

```diff
@@ -112,7 +127,8 @@ const PROMPT_TEMPLATES = {
   en: {
     bedtime: {
       system: `You are Anicca, a warm and wise life coach.
-The user is 30 minutes before bedtime. Generate a short message to encourage sleep preparation.
+The user is 15 minutes before bedtime. Generate a short message to encourage sleep preparation.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Always include the user's name (e.g., "Name, it's time to..." or "Good night, Name")
+- Reference their ideal self or current struggles when relevant
+- If today's activity data is available, reference it specifically
 - Use suggestions, not commands
 - No emojis
 - Do not include "Anicca" in the message`,
       user: (ctx) => `User info:
 - Name: ${ctx.displayName}
 - Scheduled bedtime: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
 - Sleep location: ${ctx.sleepLocation || 'not set'}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}
-${ctx.todayStats ? `- Today's activity: ${ctx.todayStats}` : ''}
+${ctx.todayStats ? `- Today's activity: ${ctx.todayStats.steps || 0} steps${ctx.todayStats.sleepDurationMin ? `, last night ${formatSleepDuration(ctx.todayStats.sleepDurationMin, 'en')} sleep` : ''}${ctx.todayStats.snsMinutesTotal ? `, ${ctx.todayStats.snsMinutesTotal}min SNS` : ''}` : ''}

 Generate a gentle one-sentence message encouraging bedtime preparation.`
     },
     training: {
       system: `You are Anicca, a warm and wise life coach.
 The user is 15 minutes before training. Generate a short motivational message.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Always include the user's name (e.g., "Name, let's..." or "Ready, Name?")
+- Connect to their ideal self when relevant to motivate
+- If today's activity data is available, reference it
 - Be encouraging and motivating
 - No emojis
 - Do not include "Anicca" in the message`,
       user: (ctx) => `User info:
 - Name: ${ctx.displayName}
 - Scheduled time: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
 - Training focus: ${ctx.trainingFocus?.join(', ') || 'not set'}
 - Training goal: ${ctx.trainingGoal || 'not set'}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}
-${ctx.todayStats ? `- Today: ${ctx.todayStats.steps || 0} steps` : ''}
+${ctx.todayStats ? `- Today: ${ctx.todayStats.steps || 0} steps${ctx.todayStats.sleepDurationMin ? `, ${formatSleepDuration(ctx.todayStats.sleepDurationMin, 'en')} sleep` : ''}` : ''}

 Generate a one-sentence message to encourage workout preparation.`
     },
     custom: {
       system: `You are Anicca, a warm and wise life coach.
 The user is 15 minutes before a custom habit. Generate a short reminder message.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Always include the user's name
 - Include the habit name naturally
+- Connect to their ideal self when relevant
 - No emojis
 - Do not include "Anicca" in the message`,
       user: (ctx) => `User info:
 - Name: ${ctx.displayName}
 - Habit name: ${ctx.habitName}
 - Scheduled time: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}

 Generate a one-sentence reminder for this habit.`
     },
     wake: {
       system: `You are Anicca, a warm and wise life coach.
-It's the user's wake-up time. Generate a gentle wake-up message.
+It's 5 minutes before the user's wake-up time. Generate a gentle wake-up message.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Always include the user's name (e.g., "Good morning, Name" or "Name, rise and shine")
+- Reference their ideal self to inspire the start of the day
+- If sleep data is available, reference it
 - Use a warm morning greeting tone
 - No emojis
 - Do not include "Anicca" in the message`,
       user: (ctx) => `User info:
 - Name: ${ctx.displayName}
 - Wake time: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
 - Wake location: ${ctx.wakeLocation || 'not set'}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}
+${ctx.todayStats ? `- Yesterday: ${ctx.todayStats.steps || 0} steps${ctx.todayStats.sleepDurationMin ? `, ${formatSleepDuration(ctx.todayStats.sleepDurationMin, 'en')} sleep` : ''}` : ''}

 Generate a gentle one-sentence wake-up message.`
     }
   }
 };
```

### 4-D: generatePersonalizedMessage関数の修正

```diff
@@ -218,6 +245,10 @@ async function generatePersonalizedMessage({ profileId, habitType, habitName, sc
   const wakeLocation = profile?.wakeLocation || '';
   const trainingFocus = profile?.trainingFocus || [];
   const trainingGoal = profile?.trainingGoal || '';
+
+  // ★ idealTraits と problems を追加
+  const idealTraits = profile?.idealTraits || profile?.ideals || [];
+  const problems = profile?.problems || profile?.struggles || [];

   // 2. mem0から関連記憶を検索
   // ...（既存コード）

@@ -281,6 +312,8 @@ async function generatePersonalizedMessage({ profileId, habitType, habitName, sc
     trainingGoal,
     habitName: habitName || '',
     memories: memories || null,
+    idealTraits,
+    problems,
     todayStats
   };
```
 - Use suggestions, not commands
 - No emojis
 - Do not include "Anicca" in the message`,
@@ -122,9 +138,11 @@ Rules:
 - Scheduled bedtime: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
 - Sleep location: ${ctx.sleepLocation || 'not set'}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}
 ${ctx.todayStats ? `- Today's activity: ${ctx.todayStats}` : ''}

-Generate a gentle one-sentence message encouraging bedtime preparation.`
+Generate a gentle one-sentence message encouraging bedtime preparation. Reference their goals when relevant.`
     },
     training: {
       system: `You are Anicca, a warm and wise life coach.
@@ -132,7 +150,8 @@ The user is 15 minutes before training. Generate a short motivational message.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Include the user's name naturally (but not every time - vary the approach)
+- Connect to their ideal self when relevant to motivate
 - Be encouraging and motivating
 - No emojis
 - Do not include "Anicca" in the message`,
@@ -142,10 +161,12 @@ Rules:
 - Current time: ${ctx.currentTime}
 - Training focus: ${ctx.trainingFocus?.join(', ') || 'not set'}
 - Training goal: ${ctx.trainingGoal || 'not set'}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}
 ${ctx.todayStats ? `- Today: ${ctx.todayStats.steps || 0} steps` : ''}

-Generate a one-sentence message to encourage workout preparation.`
+Generate a one-sentence message to encourage workout preparation. Connect to their goals when relevant.`
     },
     custom: {
       system: `You are Anicca, a warm and wise life coach.
@@ -153,8 +174,9 @@ The user is 15 minutes before a custom habit. Generate a short reminder message.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Include the user's name naturally (but not every time - vary the approach)
 - Include the habit name naturally
+- Connect to their ideal self when relevant
 - No emojis
 - Do not include "Anicca" in the message`,
       user: (ctx) => `User info:
@@ -162,9 +184,11 @@ Rules:
 - Habit name: ${ctx.habitName}
 - Scheduled time: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}

-Generate a one-sentence reminder for this habit.`
+Generate a one-sentence reminder for this habit. Be personal and encouraging.`
     },
     wake: {
       system: `You are Anicca, a warm and wise life coach.
@@ -172,7 +196,8 @@ It's the user's wake-up time. Generate a gentle wake-up message.

 Rules:
 - Maximum 80 characters (strict)
-- Include the user's name naturally
+- Include the user's name naturally (but not every time - vary the approach)
+- Reference their ideal self to inspire the start of the day when relevant
 - Use a warm morning greeting tone
 - No emojis
 - Do not include "Anicca" in the message`,
@@ -181,9 +206,11 @@ Rules:
 - Wake time: ${ctx.scheduledTime}
 - Current time: ${ctx.currentTime}
 - Wake location: ${ctx.wakeLocation || 'not set'}
+- Ideal self: ${ctx.idealTraits?.join(', ') || 'not set'}
+- Current struggles: ${ctx.problems?.join(', ') || 'not set'}
 ${ctx.memories ? `- Past notes: ${ctx.memories}` : ''}

-Generate a gentle one-sentence wake-up message.`
+Generate a gentle one-sentence wake-up message. Inspire them with their goals when appropriate.`
     }
   }
 };
@@ -218,6 +245,10 @@ async function generatePersonalizedMessage({ profileId, habitType, habitName, sc
   const wakeLocation = profile?.wakeLocation || '';
   const trainingFocus = profile?.trainingFocus || [];
   const trainingGoal = profile?.trainingGoal || '';
+
+  // ★ idealTraits と problems を追加
+  const idealTraits = profile?.idealTraits || [];
+  const problems = profile?.problems || [];

   // 2. mem0から関連記憶を検索
   let memories = '';
@@ -281,6 +312,8 @@ async function generatePersonalizedMessage({ profileId, habitType, habitName, sc
     trainingGoal,
     habitName: habitName || '',
     memories: memories || null,
+    idealTraits,
+    problems,
     todayStats
   };
```

---

## パッチ 5: TalkView.swift - アラームからセッション画面への遷移

```diff
--- a/aniccaios/aniccaios/Views/Talk/TalkView.swift
+++ b/aniccaios/aniccaios/Views/Talk/TalkView.swift
@@ -3,6 +3,10 @@ import SwiftUI
 struct TalkView: View {
     @EnvironmentObject private var appState: AppState
     @State private var selectedTopic: FeelingTopic?
+    
+    // ★ アラームからのセッション起動用
+    @State private var habitSessionActive = false
+    @State private var pendingHabit: HabitType?

     // v3-ux: 上3つは動的。v0.3 ではまず「固定 + 軽い並べ替え」→ tool/context 導入後に差し替え。
     private var topics: [FeelingTopic] {
@@ -55,6 +59,26 @@ struct TalkView: View {
             .fullScreenCover(item: $selectedTopic) { topic in
                 SessionView(topic: topic)
                     .environmentObject(appState)
             }
+            // ★ 習慣セッション用のfullScreenCover
+            .fullScreenCover(isPresented: $habitSessionActive) {
+                if let habit = pendingHabit {
+                    HabitSessionView(habit: habit)
+                        .environmentObject(appState)
+                }
+            }
+            .onAppear {
+                checkPendingHabitTrigger()
+            }
+            .onChange(of: appState.pendingHabitTrigger) { _ in
+                checkPendingHabitTrigger()
+            }
         }
     }
+    
+    private func checkPendingHabitTrigger() {
+        guard let trigger = appState.pendingHabitTrigger,
+              appState.shouldStartSessionImmediately else { return }
+        pendingHabit = trigger.habit
+        habitSessionActive = true
+        appState.shouldStartSessionImmediately = false
+    }

     @ViewBuilder
     private func feelingCard(for topic: FeelingTopic) -> some View {
```

---

## パッチ 6: 新規ファイル HabitSessionView.swift

`aniccaios/aniccaios/Views/Session/HabitSessionView.swift` を新規作成:

```swift
import SwiftUI
import AVFoundation

struct HabitSessionView: View {
    @EnvironmentObject private var appState: AppState
    @Environment(\.dismiss) private var dismiss
    @ObservedObject private var controller = VoiceSessionController.shared

    let habit: HabitType

    @State private var showMicAlert = false

    var body: some View {
        VStack(spacing: 0) {
            // ナビゲーションバー
            HStack {
                Button {
                    controller.stop()
                    dismiss()
                } label: {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 20, weight: .medium))
                        .foregroundStyle(AppTheme.Colors.label)
                }
                .frame(width: 44, height: 44)
                
                Spacer()
            }
            .padding(.horizontal, 16)
            .frame(height: 69)
            .overlay(alignment: .bottom) {
                Rectangle()
                    .fill(Color(red: 200/255, green: 198/255, blue: 191/255, opacity: 0.2))
                    .frame(height: 1)
            }
            
            // メインコンテンツ
            VStack(spacing: 0) {
                habitPill
                    .padding(.top, 30.5)
                    .padding(.bottom, 48)
                
                OrbView()
                    .padding(.bottom, 48)
                
                Text(statusText)
                    .font(.system(size: 20, weight: .medium))
                    .foregroundStyle(Color(red: 57/255, green: 54/255, blue: 52/255, opacity: 0.7))
                    .padding(.bottom, 64)
                
                Spacer()
                
                controlsRow
                    .padding(.bottom, 48)
            }
            .padding(.horizontal, 24)
        }
        .background(Color(hex: "#F8F5ED"))
        .onAppear {
            ensureMicrophonePermissionAndStart()
        }
        .onDisappear {
            if controller.connectionStatus != .disconnected {
                controller.stop()
            }
        }
        .alert(String(localized: "session_mic_permission_title"), isPresented: $showMicAlert) {
            Button(String(localized: "common_open_settings")) {
                if let url = URL(string: UIApplication.openSettingsURLString) {
                    UIApplication.shared.open(url)
                }
            }
            Button(String(localized: "common_cancel"), role: .cancel) {
                dismiss()
            }
        } message: {
            Text(String(localized: "session_mic_permission_message"))
        }
    }

    private var habitPill: some View {
        Text(habit.title)
            .font(.system(size: 20, weight: .medium))
            .foregroundStyle(AppTheme.Colors.secondaryLabel)
            .padding(.horizontal, 31)
            .padding(.vertical, 17)
            .background(
                Capsule()
                    .fill(Color(hex: "#F2F0ED"))
            )
    }

    private var statusText: String {
        if controller.connectionStatus == .connecting { return String(localized: "session_status_connecting") }
        if controller.isModelSpeaking { return String(localized: "session_status_speaking") }
        if controller.connectionStatus == .connected { return String(localized: "session_status_listening") }
        return String(localized: "session_status_disconnected")
    }

    private var controlsRow: some View {
        HStack {
            Button {
                controller.toggleMicMuted()
            } label: {
                Image(systemName: controller.isMicMuted ? "mic.slash.fill" : "mic.fill")
                    .font(.system(size: 32, weight: .semibold))
                    .foregroundStyle(AppTheme.Colors.label)
                    .frame(width: 80, height: 80)
                    .background(Circle().fill(AppTheme.Colors.cardBackground))
                    .overlay(Circle().stroke(AppTheme.Colors.border.opacity(0.2), lineWidth: 1))
                    .shadow(color: .black.opacity(0.08), radius: 12, x: 0, y: 6)
            }

            Spacer()

            Button {
                controller.stop()
                dismiss()
            } label: {
                Image(systemName: "xmark")
                    .font(.system(size: 32, weight: .semibold))
                    .foregroundStyle(Color.white)
                    .frame(width: 80, height: 80)
                    .background(Circle().fill(Color.red))
                    .shadow(color: .black.opacity(0.08), radius: 12, x: 0, y: 6)
            }
        }
        .padding(.horizontal, 24)
    }

    private func ensureMicrophonePermissionAndStart() {
        if #available(iOS 17.0, *) {
            switch AVAudioApplication.shared.recordPermission {
            case .granted:
                controller.start(shouldResumeImmediately: true)
            case .undetermined:
                AVAudioApplication.requestRecordPermission { granted in
                    DispatchQueue.main.async {
                        if granted {
                            controller.start(shouldResumeImmediately: true)
                        } else {
                            showMicAlert = true
                        }
                    }
                }
            default:
                showMicAlert = true
            }
        } else {
            switch AVAudioSession.sharedInstance().recordPermission {
            case .granted:
                controller.start(shouldResumeImmediately: true)
            case .undetermined:
                AVAudioSession.sharedInstance().requestRecordPermission { granted in
                    DispatchQueue.main.async {
                        if granted {
                            controller.start(shouldResumeImmediately: true)
                        } else {
                            showMicAlert = true
                        }
                    }
                }
            default:
                showMicAlert = true
            }
        }
    }
}
```

---

## パッチ 7: ProfileView.swift - chevron削除 + Language行削除

```diff
--- a/aniccaios/aniccaios/Views/Profile/ProfileView.swift
+++ b/aniccaios/aniccaios/Views/Profile/ProfileView.swift
@@ -80,8 +80,6 @@ struct ProfileView: View {
                     row(label: String(localized: "profile_row_plan"), value: appState.subscriptionInfo.displayPlanName, showsChevron: true)
                 }
                 .buttonStyle(.plain)
-                divider
-                row(label: String(localized: "profile_row_language"), value: appState.userProfile.preferredLanguage.languageLine, showsChevron: false)
             }
         }
     }
@@ -111,9 +109,6 @@ struct ProfileView: View {
             } else {
                 Text(appState.userProfile.displayName.isEmpty ? "-" : appState.userProfile.displayName)
                     .font(.system(size: 16))
                     .foregroundStyle(AppTheme.Colors.secondaryLabel)
-                Image(systemName: "chevron.right")
-                    .font(.system(size: 14, weight: .semibold))
-                    .foregroundStyle(AppTheme.Colors.tertiaryLabel)
             }
         }
         .padding(.horizontal, 18)
```

---

## パッチ 8: HabitsTabView.swift - 歯車アイコン削除

```diff
--- a/aniccaios/aniccaios/Habits/HabitsTabView.swift
+++ b/aniccaios/aniccaios/Habits/HabitsTabView.swift
@@ -3,21 +3,11 @@ import SwiftUI
 struct HabitsTabView: View {
     @EnvironmentObject private var appState: AppState
-    @State private var showingSettings = false
     
     var body: some View {
         NavigationStack {
             HabitsSectionView()
                 .navigationTitle(String(localized: "settings_habits"))
-                .toolbar {
-                    ToolbarItem(placement: .navigationBarTrailing) {
-                        Button(action: { showingSettings = true }) {
-                            Image(systemName: "gearshape")
-                        }
-                    }
-                }
-        }
-        .sheet(isPresented: $showingSettings) {
-            SettingsView()
-                .environmentObject(appState)
         }
         .background(AppBackground())
     }
 }
```

---

## パッチ 9: NotificationPermissionStepView.swift - 許可/拒否後の自動遷移

```diff
--- a/aniccaios/aniccaios/Onboarding/NotificationPermissionStepView.swift
+++ b/aniccaios/aniccaios/Onboarding/NotificationPermissionStepView.swift
@@ -32,12 +32,15 @@ struct NotificationPermissionStepView: View {

             PrimaryButton(
                 title: isRequesting
                     ? String(localized: "common_requesting")
-                    : (notificationGranted ? String(localized: "common_continue") : String(localized: "onboarding_notifications_allow")),
+                    : (hasAttemptedPermission ? String(localized: "common_continue") : String(localized: "onboarding_notifications_allow")),
                 isEnabled: !isRequesting,
                 isLoading: isRequesting,
-                style: notificationGranted ? .selected : .primary
+                style: hasAttemptedPermission ? .selected : .primary
             ) {
-                if notificationGranted || hasAttemptedPermission {
+                if hasAttemptedPermission {
+                    // 許可/拒否に関わらず次へ進める
                     next()
                 } else {
                     requestNotifications()
@@ -62,8 +65,9 @@ struct NotificationPermissionStepView: View {
                 notificationGranted = granted
                 notificationDenied = !granted
                 isRequesting = false
                 hasAttemptedPermission = true
-                // v3: 自動遷移しない
+                // ★ 許可/拒否後に自動で次へ遷移
+                next()
             }
-            await refreshAuthorizationState(autoAdvance: false)
         }
     }
```

---

## パッチ 10: IdealsStepView.swift - レイアウト修正（スクショ準拠）

```diff
--- a/aniccaios/aniccaios/Onboarding/IdealsStepView.swift
+++ b/aniccaios/aniccaios/Onboarding/IdealsStepView.swift
@@ -5,24 +5,31 @@ struct IdealsStepView: View {
     @EnvironmentObject private var appState: AppState

-    // profile.md (Figma) 準拠: kind, altruistic, confident, mindful, honest, open, courageous
-    private let rows: [[String]] = [
-        ["kind", "altruistic", "confident", "mindful"],
-        ["honest", "open", "courageous"]
+    // スクショ準拠: Kind, Confident, Early Riser, Runner, Creative, Mindful, Organized, Calm, Healthy, Patient, Focused, Grateful, Brave
+    private let options: [String] = [
+        "kind", "confident", "early_riser",
+        "runner", "creative",
+        "mindful", "organized", "calm",
+        "healthy", "patient",
+        "focused", "grateful", "brave"
     ]

     @State private var selected: Set<String> = []

     var body: some View {
         VStack(spacing: 24) {
             Text(String(localized: "onboarding_ideals_title"))
-                .font(AppTheme.Typography.onboardingTitle)
+                .font(.system(size: 36, weight: .bold))
                 .fontWeight(.heavy)
-                .lineLimit(2)
+                .lineSpacing(4) // line-height 40px
                 .minimumScaleFactor(0.8)
                 .multilineTextAlignment(.center)
                 .foregroundStyle(AppTheme.Colors.label)
                 .padding(.top, 40)
+                .padding(.horizontal, 24)

             Text(String(localized: "onboarding_ideals_subtitle"))
-                .font(.subheadline)
+                .font(.system(size: 16))
                 .foregroundStyle(.secondary)
                 .multilineTextAlignment(.center)
-                .padding(.horizontal)
+                .padding(.horizontal, 24)

             ScrollView {
-                VStack(alignment: .leading, spacing: 12) {
-                    ForEach(Array(rows.enumerated()), id: \.offset) { _, row in
-                        HStack(spacing: 12) {
-                            ForEach(row, id: \.self) { key in
-                                chipButton(kind: "ideal_trait", key: key)
-                            }
-                            Spacer(minLength: 0)
-                        }
+                FlowLayout(spacing: 12) {
+                    ForEach(options, id: \.self) { key in
+                        chipButton(kind: "ideal_trait", key: key)
                     }
                 }
-                .padding(.horizontal, 16)
+                .padding(.horizontal, 24)
                 .padding(.top, 8)
             }

             Spacer()

-            PrimaryButton(
-                title: String(localized: "common_next"),
-                isEnabled: !selected.isEmpty,
-                style: .large
-            ) {
-                appState.updateIdealTraits(Array(selected))
-                next()
+            VStack(spacing: 12) {
+                PrimaryButton(
+                    title: String(localized: "common_next"),
+                    isEnabled: !selected.isEmpty,
+                    style: .large
+                ) {
+                    appState.updateIdealTraits(Array(selected))
+                    next()
+                }
+                
+                Button(String(localized: "common_skip")) {
+                    next()
+                }
+                .font(.system(size: 16, weight: .medium))
+                .foregroundStyle(AppTheme.Colors.secondaryLabel)
             }
             .padding(.horizontal, 24)
             .padding(.bottom, 64)
         }
         .background(AppBackground())
         .onAppear {
             selected = Set(appState.userProfile.idealTraits)
         }
     }

     @ViewBuilder
     private func chipButton(kind: String, key: String) -> some View {
         let isSelected = selected.contains(key)
         Button {
             if isSelected {
                 selected.remove(key)
             } else {
                 selected.insert(key)
             }
         } label: {
             Text(NSLocalizedString("\(kind)_\(key)", comment: ""))
                 .font(.system(size: 16, weight: .medium))
                 .fixedSize(horizontal: true, vertical: false)
-                .padding(.horizontal, 24)
-                .padding(.vertical, 12)
+                .padding(.horizontal, 20)
+                .padding(.vertical, 14)
                 .background(isSelected ? AppTheme.Colors.buttonSelected : AppTheme.Colors.buttonUnselected)
                 .foregroundStyle(isSelected ? AppTheme.Colors.buttonTextSelected : AppTheme.Colors.label)
                 .clipShape(Capsule())
         }
         .buttonStyle(.plain)
     }
 }
+
+// FlowLayout for natural wrapping
+private struct FlowLayout: Layout {
+    var spacing: CGFloat = 12
+    
+    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
+        let result = arrangeSubviews(proposal: proposal, subviews: subviews)
+        return result.size
+    }
+    
+    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
+        let result = arrangeSubviews(proposal: proposal, subviews: subviews)
+        for (index, position) in result.positions.enumerated() {
+            subviews[index].place(at: CGPoint(x: bounds.minX + position.x, y: bounds.minY + position.y), proposal: .unspecified)
+        }
+    }
+    
+    private func arrangeSubviews(proposal: ProposedViewSize, subviews: Subviews) -> (size: CGSize, positions: [CGPoint]) {
+        let maxWidth = proposal.width ?? .infinity
+        var positions: [CGPoint] = []
+        var currentX: CGFloat = 0
+        var currentY: CGFloat = 0
+        var lineHeight: CGFloat = 0
+        var totalHeight: CGFloat = 0
+        
+        for subview in subviews {
+            let size = subview.sizeThatFits(.unspecified)
+            
+            if currentX + size.width > maxWidth && currentX > 0 {
+                currentX = 0
+                currentY += lineHeight + spacing
+                lineHeight = 0
+            }
+            
+            positions.append(CGPoint(x: currentX, y: currentY))
+            currentX += size.width + spacing
+            lineHeight = max(lineHeight, size.height)
+            totalHeight = max(totalHeight, currentY + lineHeight)
+        }
+        
+        return (CGSize(width: maxWidth, height: totalHeight), positions)
+    }
+}
```

---

## パッチ 11: StrugglesStepView.swift - レイアウト修正（スクショ準拠）

```diff
--- a/aniccaios/aniccaios/Onboarding/StrugglesStepView.swift
+++ b/aniccaios/aniccaios/Onboarding/StrugglesStepView.swift
@@ -5,24 +5,26 @@ struct StrugglesStepView: View {
     @EnvironmentObject private var appState: AppState

-    // profile.md (Figma) 準拠: rumination, jealousy, self_criticism, anxiety, loneliness, irritation
-    private let rows: [[String]] = [
-        ["rumination", "jealousy", "self_criticism"],
-        ["anxiety", "loneliness", "irritation"]
+    // スクショ準拠: Procrastination, Anxiety, Poor Sleep, Stress, Focus, Motivation, Self-doubt, Time Management, Burnout, Relationships, Energy, Work-Life Balance
+    private let options: [String] = [
+        "procrastination", "anxiety", "poor_sleep",
+        "stress", "focus", "motivation",
+        "self_doubt", "time_management", "burnout",
+        "relationships", "energy", "work_life_balance"
     ]

     @State private var selected: Set<String> = []

     var body: some View {
         VStack(spacing: 24) {
             Text(String(localized: "onboarding_struggles_title"))
-                .font(AppTheme.Typography.onboardingTitle)
+                .font(.system(size: 36, weight: .bold))
                 .fontWeight(.heavy)
-                .lineLimit(3)
+                .lineSpacing(4) // line-height 40px
                 .minimumScaleFactor(0.8)
                 .multilineTextAlignment(.center)
                 .foregroundStyle(AppTheme.Colors.label)
                 .padding(.top, 40)
+                .padding(.horizontal, 24)

             Text(String(localized: "onboarding_struggles_subtitle"))
-                .font(.subheadline)
+                .font(.system(size: 16))
                 .foregroundStyle(.secondary)
                 .multilineTextAlignment(.center)
-                .padding(.horizontal)
+                .padding(.horizontal, 24)

             ScrollView {
-                VStack(alignment: .leading, spacing: 12) {
-                    ForEach(Array(rows.enumerated()), id: \.offset) { _, row in
-                        HStack(spacing: 12) {
-                            ForEach(row, id: \.self) { key in
-                                chipButton(kind: "problem", key: key)
-                            }
-                            Spacer(minLength: 0)
-                        }
+                FlowLayout(spacing: 12) {
+                    ForEach(options, id: \.self) { key in
+                        chipButton(kind: "problem", key: key)
                     }
                 }
-                .padding(.horizontal, 16)
+                .padding(.horizontal, 24)
                 .padding(.top, 8)
             }

             Spacer()

-            PrimaryButton(
-                title: String(localized: "common_next"),
-                isEnabled: !selected.isEmpty,
-                style: .large
-            ) {
-                var profile = appState.userProfile
-                profile.problems = Array(selected)
-                appState.updateUserProfile(profile, sync: true)
-                next()
+            VStack(spacing: 12) {
+                PrimaryButton(
+                    title: String(localized: "common_next"),
+                    isEnabled: !selected.isEmpty,
+                    style: .large
+                ) {
+                    var profile = appState.userProfile
+                    profile.problems = Array(selected)
+                    appState.updateUserProfile(profile, sync: true)
+                    next()
+                }
+                
+                Button(String(localized: "common_skip")) {
+                    next()
+                }
+                .font(.system(size: 16, weight: .medium))
+                .foregroundStyle(AppTheme.Colors.secondaryLabel)
             }
             .padding(.horizontal, 24)
             .padding(.bottom, 64)
         }
         .background(AppBackground())
         .onAppear {
             selected = Set(appState.userProfile.problems)
         }
     }

     @ViewBuilder
     private func chipButton(kind: String, key: String) -> some View {
         let isSelected = selected.contains(key)
         Button {
             if isSelected {
                 selected.remove(key)
             } else {
                 selected.insert(key)
             }
         } label: {
             Text(NSLocalizedString("\(kind)_\(key)", comment: ""))
                 .font(.system(size: 16, weight: .medium))
                 .fixedSize(horizontal: true, vertical: false)
-                .padding(.horizontal, 24)
-                .padding(.vertical, 12)
+                .padding(.horizontal, 20)
+                .padding(.vertical, 14)
                 .background(isSelected ? AppTheme.Colors.buttonSelected : AppTheme.Colors.buttonUnselected)
                 .foregroundStyle(isSelected ? AppTheme.Colors.buttonTextSelected : AppTheme.Colors.label)
                 .clipShape(Capsule())
         }
         .buttonStyle(.plain)
     }
 }
+
+// FlowLayout for natural wrapping
+private struct FlowLayout: Layout {
+    var spacing: CGFloat = 12
+    
+    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
+        let result = arrangeSubviews(proposal: proposal, subviews: subviews)
+        return result.size
+    }
+    
+    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
+        let result = arrangeSubviews(proposal: proposal, subviews: subviews)
+        for (index, position) in result.positions.enumerated() {
+            subviews[index].place(at: CGPoint(x: bounds.minX + position.x, y: bounds.minY + position.y), proposal: .unspecified)
+        }
+    }
+    
+    private func arrangeSubviews(proposal: ProposedViewSize, subviews: Subviews) -> (size: CGSize, positions: [CGPoint]) {
+        let maxWidth = proposal.width ?? .infinity
+        var positions: [CGPoint] = []
+        var currentX: CGFloat = 0
+        var currentY: CGFloat = 0
+        var lineHeight: CGFloat = 0
+        var totalHeight: CGFloat = 0
+        
+        for subview in subviews {
+            let size = subview.sizeThatFits(.unspecified)
+            
+            if currentX + size.width > maxWidth && currentX > 0 {
+                currentX = 0
+                currentY += lineHeight + spacing
+                lineHeight = 0
+            }
+            
+            positions.append(CGPoint(x: currentX, y: currentY))
+            currentX += size.width + spacing
+            lineHeight = max(lineHeight, size.height)
+            totalHeight = max(totalHeight, currentY + lineHeight)
+        }
+        
+        return (CGSize(width: maxWidth, height: totalHeight), positions)
+    }
+}
```

---

## パッチ 12: Localizable.strings (en) - 新しいキーを追加

```diff
--- a/aniccaios/aniccaios/Resources/en.lproj/Localizable.strings
+++ b/aniccaios/aniccaios/Resources/en.lproj/Localizable.strings
+// Ideals - new options
+"ideal_trait_early_riser" = "Early Riser";
+"ideal_trait_runner" = "Runner";
+"ideal_trait_creative" = "Creative";
+"ideal_trait_organized" = "Organized";
+"ideal_trait_calm" = "Calm";
+"ideal_trait_healthy" = "Healthy";
+"ideal_trait_patient" = "Patient";
+"ideal_trait_focused" = "Focused";
+"ideal_trait_grateful" = "Grateful";
+"ideal_trait_brave" = "Brave";

+// Problems - new options
+"problem_procrastination" = "Procrastination";
+"problem_poor_sleep" = "Poor Sleep";
+"problem_stress" = "Stress";
+"problem_focus" = "Focus";
+"problem_motivation" = "Motivation";
+"problem_self_doubt" = "Self-doubt";
+"problem_time_management" = "Time Management";
+"problem_burnout" = "Burnout";
+"problem_relationships" = "Relationships";
+"problem_energy" = "Energy";
+"problem_work_life_balance" = "Work-Life Balance";

+"common_skip" = "Skip";
```

---

## パッチ 13: Localizable.strings (ja) - 新しいキーを追加

```diff
--- a/aniccaios/aniccaios/Resources/ja.lproj/Localizable.strings
+++ b/aniccaios/aniccaios/Resources/ja.lproj/Localizable.strings
+// Ideals - new options
+"ideal_trait_early_riser" = "早起き";
+"ideal_trait_runner" = "ランナー";
+"ideal_trait_creative" = "クリエイティブ";
+"ideal_trait_organized" = "整理整頓";
+"ideal_trait_calm" = "穏やか";
+"ideal_trait_healthy" = "健康的";
+"ideal_trait_patient" = "忍耐強い";
+"ideal_trait_focused" = "集中力";
+"ideal_trait_grateful" = "感謝";
+"ideal_trait_brave" = "勇敢";

+// Problems - new options
+"problem_procrastination" = "先延ばし";
+"problem_poor_sleep" = "睡眠不足";
+"problem_stress" = "ストレス";
+"problem_focus" = "集中力不足";
+"problem_motivation" = "モチベーション";
+"problem_self_doubt" = "自己不信";
+"problem_time_management" = "時間管理";
+"problem_burnout" = "燃え尽き";
+"problem_relationships" = "人間関係";
+"problem_energy" = "エネルギー不足";
+"problem_work_life_balance" = "ワークライフバランス";

+"common_skip" = "スキップ";
```

---

## パッチ 14: HabitsSectionView.swift - AlarmKit JIT許可

起床トグルON時にAlarmKit許可をリクエスト:

```diff
--- a/aniccaios/aniccaios/Habits/HabitsSectionView.swift
+++ b/aniccaios/aniccaios/Habits/HabitsSectionView.swift
@@ -28,6 +28,9 @@ struct HabitsSectionView: View {
     @State private var activeSheet: SheetRoute?
     @State private var newCustomHabitName = ""
     @State private var isAdding = false
+    
+    // AlarmKit JIT許可用
+    @State private var showingAlarmKitExplanation = false
     // 削除確認を廃止（即時削除）
     
@@ -312,6 +315,12 @@ struct HabitsSectionView: View {
                 set: { isOn in
                     if isOn {
                         if let date = date {
+                            // ★ 起床の場合、AlarmKit許可をリクエスト
+                            if habit == .wake {
+                                Task {
+                                    await requestAlarmKitPermissionIfNeeded()
+                                }
+                            }
                             activeHabits.insert(habit)
                             habitTimes[habit] = date
                         } else {
@@ -330,6 +339,30 @@ struct HabitsSectionView: View {
         }
     }
     
+    private func requestAlarmKitPermissionIfNeeded() async {
+#if canImport(AlarmKit)
+        if #available(iOS 26.0, *) {
+            let store = AlarmStore.shared
+            let status = await store.authorizationStatus
+            switch status {
+            case .notDetermined:
+                do {
+                    try await store.requestAuthorization()
+                    // 許可された場合、プロファイルのAlarmKit設定をON
+                    await MainActor.run {
+                        var profile = appState.userProfile
+                        profile.useAlarmKitForWake = true
+                        appState.updateUserProfile(profile, sync: true)
+                    }
+                } catch {
+                    // 拒否された場合は何もしない（通常の通知を使用）
+                }
+            default:
+                break
+            }
+        }
+#endif
+    }
+    
     @ViewBuilder
     private func customHabitRow(id: UUID, name: String, time: DateComponents?) -> some View {
```

これで全ての問題に対する完全なパッチを示しました。

**修正項目まとめ:**

1. **オンボーディングフロー再構成** - welcome→value→account→ideals→struggles→notifications→completion
2. **mutableContent追加** - 事前通知がパーソナライズされない根本原因を修正
3. **preReminder.jsプロンプト改善** - idealTraits/problems追加、名前のバリエーション
4. **TalkView** - アラームからのセッション起動を追加
5. **HabitSessionView** - 習慣セッション用の新規View
6. **ProfileView** - chevron削除、Language行削除
7. **HabitsTabView** - 歯車アイコン削除
8. **NotificationPermissionStepView** - 許可/拒否後の自動遷移
9. **IdealsStepView** - スクショ準拠のレイアウト、FlowLayout、Skipボタン
10. **StrugglesStepView** - スクショ準拠のレイアウト、FlowLayout、Skipボタン
11. **Localizable.strings** - 新しいキー追加
12. **HabitsSectionView** - AlarmKit JIT許可

実装に進みましょうか？


ValueStepViewと関連ファイルを確認します。

[3 tools called]

**ValueStepView は既に存在しています！** 「What Anicca Can Do」画面です。

CompletionStepViewも確認します。

[3 tools called]

**確認結果:**

1. **ValueStepView** - ✅ 既に存在しています！ローカライズも完了済み。パッチ不要。

2. **CompletionStepView** - ✅ 既に存在しますが、これは「All Set」画面です。オンボーディング完了後すぐにメイン画面に遷移するなら不要ですね。

**フローの修正**: CompletionStepViewは使わず、notifications完了後に`markOnboardingComplete()`を呼んでそのままメイン画面へ遷移させます。

では、未カバーの問題のパッチを作成するために残りのファイルを確認します。

[3 tools called]

問題を確認しました。続けて残りの問題に関するファイルを確認します。

[3 tools called]

いくつかの問題を確認しました。続けてHabitsSectionViewを確認します。

[6 tools called]

確認が完了しました。結論をお伝えします：

---

## 確認結果

### ValueStepView
**✅ 既に存在しています！** `/Users/cbns03/Downloads/anicca-project/aniccaios/aniccaios/Onboarding/ValueStepView.swift` に「What Anicca Can Do」画面があり、ローカライズも完了しています。**パッチ不要です。**

### CompletionStepView
**存在しますが、おそらく不要です。** 「All Set」的な完了画面ですが、オンボーディング後すぐにメイン画面に遷移させたいなら、このステップを使わず `notifications` 完了後に直接 `markOnboardingComplete()` を呼んでメイン画面へ遷移すればOKです。

---

## 元パッチの修正

**パッチ1,2の修正**: `case completion` は追加せず、`notifications` 完了後に直接 `markOnboardingComplete()` を呼ぶようにします。

---

## 未カバーの問題一覧と完全なパッチ

以下、未カバーだった問題の**完全なパッチ**を示します。

---

### パッチ A: OnboardingStep.swift（修正版）- completion削除

```diff
--- a/aniccaios/aniccaios/Onboarding/OnboardingStep.swift
+++ b/aniccaios/aniccaios/Onboarding/OnboardingStep.swift
@@ -1,13 +1,11 @@
 import Foundation

 enum OnboardingStep: Int {
     case welcome
-    // v3: サインインを先に
-    case account       // 1. Sign in with Apple
-    case microphone    // 2. マイク許可
-    case notifications // 3. 通知許可
-    case alarmkit      // 4. AlarmKit許可
-    case ideals        // 5. Ideal Self選択
-    case struggles     // 6. Current Struggles選択
-    case paywall       // 7. Paywall
+    case value         // 1. What Anicca Can Do
+    case account       // 2. Sign in with Apple
+    case ideals        // 3. Ideal Self選択
+    case struggles     // 4. Current Struggles選択
+    case notifications // 5. 通知許可（最終ステップ）
 }

 extension OnboardingStep {
```

---

### パッチ B: OnboardingFlowView.swift（修正版）- completionなし

```diff
--- a/aniccaios/aniccaios/Onboarding/OnboardingFlowView.swift
+++ b/aniccaios/aniccaios/Onboarding/OnboardingFlowView.swift
@@ -10,18 +10,14 @@ struct OnboardingFlowView: View {
             Group {
                 switch step {
                 case .welcome:
                     WelcomeStepView(next: advance)
+                case .value:
+                    ValueStepView(next: advance)
                 case .account:
                     AuthenticationStepView(next: advance)
-                case .microphone:
-                    MicrophonePermissionStepView(next: advance)
-                case .notifications:
-                    NotificationPermissionStepView(next: advance)
-                case .alarmkit:
-                    AlarmKitPermissionStepView(next: advance)
                 case .ideals:
                     IdealsStepView(next: advance)
                 case .struggles:
                     StrugglesStepView(next: advance)
-                case .paywall:
-                    PaywallStepView(next: advance)
+                case .notifications:
+                    NotificationPermissionStepView(next: advance)
                 }
             }
             .frame(maxWidth: .infinity, maxHeight: .infinity)
@@ -42,20 +38,15 @@ struct OnboardingFlowView: View {
     private func advance() {
         switch step {
         case .welcome:
-            step = .account
+            step = .value
+        case .value:
+            step = .account
         case .account:
-            step = .microphone
-        case .microphone:
-            step = .notifications
-        case .notifications:
-            step = .alarmkit
-        case .alarmkit:
             step = .ideals
         case .ideals:
             step = .struggles
         case .struggles:
-            step = .paywall
-        case .paywall:
+            step = .notifications
+        case .notifications:
+            // 最終ステップ: オンボーディング完了
             appState.markOnboardingComplete()
             return
         }
         appState.setOnboardingStep(step)
     }
 }
```

---

### パッチ C: NotificationScheduler.swift - 通知タイミング変更

就寝を30分前→15分前に変更、起床に5分前の事前通知を追加:

```diff
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@ -590,9 +590,10 @@ final class NotificationScheduler {
     // MARK: - Pre-Reminder Scheduling (Personalized)
     
     /// 各習慣タイプの事前通知タイミング（分）
     private enum PreReminderTiming {
-        static let bedtime = 30    // 就寝30分前
+        static let bedtime = 15    // 就寝15分前
         static let training = 15   // トレーニング15分前
         static let custom = 15     // カスタム習慣15分前
+        static let wake = 5        // 起床5分前
     }

@@ -617,8 +618,8 @@ final class NotificationScheduler {
         case .training:
             offsetMinutes = PreReminderTiming.training
         case .custom:
             offsetMinutes = PreReminderTiming.custom
         case .wake:
-            return  // 起床は事前通知なし
+            offsetMinutes = PreReminderTiming.wake
         }
```

---

### パッチ D: HabitPromptBuilder.swift - IDEAL_TRAITSローカライズ

```diff
--- a/aniccaios/aniccaios/WakePromptBuilder.swift
+++ b/aniccaios/aniccaios/WakePromptBuilder.swift
@@ -151,9 +151,11 @@ struct HabitPromptBuilder {
         }
         
         // 理想の姿（全習慣で使用）
         if !profile.idealTraits.isEmpty {
-            replacements["IDEAL_TRAITS"] = "理想の姿として設定されている特性: " + profile.idealTraits.joined(separator: "、")
+            // ★ ローカライズして表示
+            let localizedTraits = profile.idealTraits.map { NSLocalizedString("ideal_trait_\($0)", comment: "") }
+            replacements["IDEAL_TRAITS"] = "理想の姿として設定されている特性: " + localizedTraits.joined(separator: "、")
         } else {
             replacements["IDEAL_TRAITS"] = ""
         }
```

---

### パッチ E: ProfileView.swift - Toggle tint追加 + 2回目ON問題修正

```diff
--- a/aniccaios/aniccaios/Views/Profile/ProfileView.swift
+++ b/aniccaios/aniccaios/Views/Profile/ProfileView.swift
@@ -83,8 +83,6 @@ struct ProfileView: View {
                 }
                 .buttonStyle(.plain)
-                divider
-                row(label: String(localized: "profile_row_language"), value: appState.userProfile.preferredLanguage.languageLine, showsChevron: false)
             }
         }
     }
@@ -112,9 +110,6 @@ struct ProfileView: View {
             } else {
                 Text(appState.userProfile.displayName.isEmpty ? "-" : appState.userProfile.displayName)
                     .font(.system(size: 16))
                     .foregroundStyle(AppTheme.Colors.secondaryLabel)
-                Image(systemName: "chevron.right")
-                    .font(.system(size: 14, weight: .semibold))
-                    .foregroundStyle(AppTheme.Colors.tertiaryLabel)
             }
         }
 
@@ -330,12 +325,16 @@ struct ProfileView: View {
         Toggle(title, isOn: Binding(
             get: { isOn.wrappedValue },
             set: { newValue in
-                // OFFにする場合は即座に反映
-                if !newValue {
+                // OFFにする場合はアニメーション付きで反映
+                if !newValue && isOn.wrappedValue {
+                    withAnimation(.easeInOut(duration: 0.2)) {
                     onDisable()
+                    }
                     return
                 }
-                // ONにする場合は、許可リクエストの結果を待ってから反映
+                // ONにする場合
+                // 既にONの場合は何もしない
+                guard !isOn.wrappedValue else { return }
                 if newValue && !isOn.wrappedValue {
                     onEnable()
                 }
@@ -507,6 +506,10 @@ struct ProfileView: View {
     
     // v3: SleepとStepsを完全に独立
     private func requestSleepOnly() async {
+        // 既にauthorizedの場合はトグルをONにするだけ
+        if HealthKitManager.shared.isSleepAuthorized() {
+            await MainActor.run { appState.setSleepEnabled(true) }
+            return
+        }
         let granted = await HealthKitManager.shared.requestSleepAuthorization()
         await MainActor.run {
             if granted {
@@ -519,6 +522,10 @@ struct ProfileView: View {
     }
     
     private func requestStepsOnly() async {
+        // 既にauthorizedの場合はトグルをONにするだけ
+        if HealthKitManager.shared.isStepsAuthorized() {
+            await MainActor.run { appState.setStepsEnabled(true) }
+            return
+        }
         let granted = await HealthKitManager.shared.requestStepsAuthorization()
         await MainActor.run {
             if granted {
```

---

### パッチ F: HealthKitManager.swift - 認可状態チェック関数追加

```swift
// HealthKitManager.swift に追加

/// 睡眠データが既に認可されているかチェック
func isSleepAuthorized() -> Bool {
    guard HKHealthStore.isHealthDataAvailable() else { return false }
    let sleepType = HKObjectType.categoryType(forIdentifier: .sleepAnalysis)!
    return healthStore.authorizationStatus(for: sleepType) == .sharingAuthorized
}

/// 歩数データが既に認可されているかチェック
func isStepsAuthorized() -> Bool {
    guard HKHealthStore.isHealthDataAvailable() else { return false }
    let stepsType = HKObjectType.quantityType(forIdentifier: .stepCount)!
    return healthStore.authorizationStatus(for: stepsType) == .sharingAuthorized
}
```

---

### パッチ G: FutureScenarioView.swift - 2行問題・横幅修正

```diff
--- a/aniccaios/aniccaios/Views/Behavior/FutureScenarioView.swift
+++ b/aniccaios/aniccaios/Views/Behavior/FutureScenarioView.swift
@@ -5,6 +5,12 @@ struct FutureScenarioView: View {
     let future: BehaviorSummary.FutureScenario

     var body: some View {
+        // 両方とも空の場合は「Not enough data」を1行だけ表示
+        let isEmpty = future.ifContinue.isEmpty && future.ifImprove.isEmpty
+        if isEmpty {
+            return AnyView(emptyState)
+        }
+        
         CardView {
             VStack(alignment: .leading, spacing: 12) {
                 Text(String(localized: "behavior_title_future"))
@@ -12,12 +18,25 @@ struct FutureScenarioView: View {
                     .foregroundStyle(AppTheme.Colors.label)

                 VStack(alignment: .leading, spacing: 8) {
-                    // migration-patch-v3.md 6.1 の JSON 順（ifContinue → ifImprove）に合わせて表示順を固定
-                    Text(future.ifContinue)
-                        .font(AppTheme.Typography.subheadlineDynamic)
-                        .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
-                    Text(future.ifImprove)
-                        .font(AppTheme.Typography.subheadlineDynamic)
-                        .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
+                    if !future.ifContinue.isEmpty {
+                        Text(future.ifContinue)
+                            .font(AppTheme.Typography.subheadlineDynamic)
+                            .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
+                    }
+                    if !future.ifImprove.isEmpty {
+                        Text(future.ifImprove)
+                            .font(AppTheme.Typography.subheadlineDynamic)
+                            .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
+                    }
                 }
             }
         }
+        .frame(maxWidth: .infinity) // TimelineViewと同じ横幅
     }
+    
+    private var emptyState: some View {
+        CardView {
+            Text(String(localized: "behavior_not_enough_data"))
+                .font(AppTheme.Typography.subheadlineDynamic)
+                .foregroundStyle(AppTheme.Colors.secondaryLabel)
+                .frame(maxWidth: .infinity, alignment: .center)
+        }
+        .frame(maxWidth: .infinity)
+    }
 }
```

---

### パッチ H: HabitsSectionView.swift - トグルにtint追加

```diff
--- a/aniccaios/aniccaios/Habits/HabitsSectionView.swift
+++ b/aniccaios/aniccaios/Habits/HabitsSectionView.swift
@@ -328,6 +328,7 @@ struct HabitsSectionView: View {
                 }
             ))
             .labelsHidden()
+            .tint(AppTheme.Colors.accent)
         }
     }
     
@@ -381,6 +382,7 @@ struct HabitsSectionView: View {
                 }
             ))
             .labelsHidden()
+            .tint(AppTheme.Colors.accent)
         }
     }
```

---

### パッチ I: feeling_*.txtのローカライズについて

**確認結果**: `[Feeling: xxx]` はプロンプトファイル内の**識別子/メタデータ**であり、LLMに渡されるコンテキストの一部です。これはユーザーには表示されないため、**ローカライズは不要**です。

ただし、TalkViewで表示されるFeelingTopicの**タイトル**がローカライズされているか確認が必要です：

```swift
// FeelingTopic.swift に title プロパティがあるか確認
```

現状 `FeelingTopic` にはタイトルプロパティがないので、TalkView側でローカライズキーを使用していれば問題ありません。

---

## 最終まとめ

| # | 問題 | 状態 |
|---|------|------|
| 1 | ValueStepView | ✅ 既存（パッチ不要） |
| 2 | CompletionStepView | ✅ 不使用（フローから除外） |
| 3 | 通知タイミング変更 | ✅ パッチC |
| 4 | IDEAL_TRAITSローカライズ | ✅ パッチD |
| 5 | feeling_*.txtローカライズ | ✅ 不要（内部識別子） |
| 6 | Habitsトグルtint | ✅ パッチH |
| 7 | FutureScenarioView | ✅ パッチG |
| 8 | Sleep/Stepsトグル2回目ON | ✅ パッチE,F |
| 9-14 | 元のパッチ1-14 | ✅ カバー済み |

**これで全問題に対するパッチが揃いました。** 実装を進めましょうか？



## 追加パッチ（チェックリスト未カバー分 + 実装上の問題修正）

---

## 追加パッチ X1: NotificationScheduler.swift - 起床5分前の事前通知を有効化

**問題**: チェックリスト#14で「起床5分前」の事前通知を追加する仕様だが、現在のコードでは起床は事前通知がスキップされている。

```diff
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@ -592,8 +592,9 @@ final class NotificationScheduler {
     /// 各習慣タイプの事前通知タイミング（分）
     private enum PreReminderTiming {
-        static let bedtime = 30    // 就寝30分前
+        static let bedtime = 15    // 就寝15分前 ★変更
         static let training = 15   // トレーニング15分前
         static let custom = 15     // カスタム習慣15分前
-        // wake は設定時刻ジャスト（事前通知なし、メインアラームのみ）
+        static let wake = 5        // 起床5分前 ★追加
     }
     
     /// 習慣の事前通知をスケジュール
@@ -611,16 +612,14 @@ final class NotificationScheduler {
         habitName: String? = nil,
         customHabitId: UUID? = nil
     ) async {
-        // 起床は事前通知なし（メインアラームとして動作）
-        guard habit != .wake else { return }
-        
         let offsetMinutes: Int
         switch habit {
         case .bedtime:
             offsetMinutes = PreReminderTiming.bedtime
         case .training:
             offsetMinutes = PreReminderTiming.training
         case .custom:
             offsetMinutes = PreReminderTiming.custom
         case .wake:
-            return  // 起床は事前通知なし
+            offsetMinutes = PreReminderTiming.wake  // ★5分前の事前通知を追加
         }
         
         // 事前通知の時刻を計算
```

---

## 追加パッチ X2: NotificationScheduler.swift - mutableContent追加（全箇所）

**問題**: Notification Service Extensionが動作するには`mutableContent = true`が必要。現在は設定されていない。

```diff
--- a/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
+++ b/aniccaios/aniccaios/Notifications/NotificationScheduler.swift
@@ -636,6 +636,7 @@ final class NotificationScheduler {
         let content = UNMutableNotificationContent()
         content.title = "Anicca"
         content.body = defaultPreReminderBody(for: habit, habitName: habitName)
         content.categoryIdentifier = Category.preReminder.rawValue
+        content.mutableContent = true  // ★ Service Extension を有効化
         
         // Notification Service Extension 用のフラグ
         content.userInfo = [
@@ -688,6 +689,7 @@ final class NotificationScheduler {
         let content = UNMutableNotificationContent()
         content.title = "Anicca"
         content.body = String(format: localizedString("pre_reminder_custom_body_format"), minutesBefore, name)
         content.categoryIdentifier = Category.preReminder.rawValue
+        content.mutableContent = true  // ★ Service Extension を有効化
         content.userInfo = [
             "customHabitId": id.uuidString,
             "habitType": "custom",
```

---

## 追加パッチ X3: HealthKitManager.swift - 認可状態チェック関数追加

**問題**: トグル2回目ONで`Authorization not determined`が出る。既に認可済みかをチェックする関数がない。

```diff
--- a/aniccaios/aniccaios/Services/HealthKitManager.swift
+++ b/aniccaios/aniccaios/Services/HealthKitManager.swift
@@ -73,6 +73,22 @@ final class HealthKitManager {
         }
     }
     
+    // MARK: - Authorization Status Check
+    
+    /// 睡眠データが既に認可されているかチェック
+    func isSleepAuthorized() -> Bool {
+        guard HKHealthStore.isHealthDataAvailable() else { return false }
+        guard let sleepType = HKObjectType.categoryType(forIdentifier: .sleepAnalysis) else { return false }
+        return healthStore.authorizationStatus(for: sleepType) == .sharingAuthorized
+    }
+    
+    /// 歩数データが既に認可されているかチェック
+    func isStepsAuthorized() -> Bool {
+        guard HKHealthStore.isHealthDataAvailable() else { return false }
+        guard let stepsType = HKObjectType.quantityType(forIdentifier: .stepCount) else { return false }
+        return healthStore.authorizationStatus(for: stepsType) == .sharingAuthorized
+    }
+    
     func fetchDailySummary() async -> DailySummary {
         var summary = DailySummary()
```

---

## 追加パッチ X4: ProfileView.swift - Sleep/Stepsトグル2回目ON修正

**問題**: 既に認可済みの場合、再度許可リクエストを送ると`notDetermined`エラーが出る。

```diff
--- a/aniccaios/aniccaios/Views/Profile/ProfileView.swift
+++ b/aniccaios/aniccaios/Views/Profile/ProfileView.swift
@@ -507,6 +507,12 @@ struct ProfileView: View {
     
     // v3: SleepとStepsを完全に独立
     private func requestSleepOnly() async {
+        // ★ 既にauthorizedの場合はトグルをONにするだけ
+        if HealthKitManager.shared.isSleepAuthorized() {
+            await MainActor.run { appState.setSleepEnabled(true) }
+            await MetricsUploader.shared.runUploadIfDue(force: true)
+            return
+        }
         let granted = await HealthKitManager.shared.requestSleepAuthorization()
         await MainActor.run {
             if granted {
@@ -519,6 +525,12 @@ struct ProfileView: View {
     }
     
     private func requestStepsOnly() async {
+        // ★ 既にauthorizedの場合はトグルをONにするだけ
+        if HealthKitManager.shared.isStepsAuthorized() {
+            await MainActor.run { appState.setStepsEnabled(true) }
+            await MetricsUploader.shared.runUploadIfDue(force: true)
+            return
+        }
         let granted = await HealthKitManager.shared.requestStepsAuthorization()
         await MainActor.run {
             if granted {
```

---

## 追加パッチ X5: HabitPromptBuilder.swift - IDEAL_TRAITSローカライズ

**問題**: `IDEAL_TRAITS`にはキー（kind, confidentなど）がそのまま埋め込まれ、ローカライズされていない。

```diff
--- a/aniccaios/aniccaios/WakePromptBuilder.swift
+++ b/aniccaios/aniccaios/WakePromptBuilder.swift
@@ -153,7 +153,8 @@ struct HabitPromptBuilder {
         
         // 理想の姿（全習慣で使用）
         if !profile.idealTraits.isEmpty {
-            replacements["IDEAL_TRAITS"] = "理想の姿として設定されている特性: " + profile.idealTraits.joined(separator: "、")
+            let localizedTraits = profile.idealTraits.map { NSLocalizedString("ideal_trait_\($0)", comment: "") }
+            replacements["IDEAL_TRAITS"] = "理想の姿として設定されている特性: " + localizedTraits.joined(separator: "、")
         } else {
             replacements["IDEAL_TRAITS"] = ""
         }
```

---

## 追加パッチ X6: preReminder.js - idealTraits/problems追加（既にパッチ4に含まれているが、完全版として再掲）

**問題**: 通知文言にユーザーの理想や課題が反映されていない。

```diff
--- a/apps/api/src/routes/mobile/preReminder.js
+++ b/apps/api/src/routes/mobile/preReminder.js
@@ -217,6 +227,10 @@ async function generatePersonalizedMessage({ profileId, habitType, habitName, sc
   const wakeLocation = profile?.wakeLocation || '';
   const trainingFocus = profile?.trainingFocus || [];
   const trainingGoal = profile?.trainingGoal || '';
+  
+  // ★ idealTraits と problems を追加
+  const idealTraits = profile?.idealTraits || [];
+  const problems = profile?.problems || [];

   // 2. mem0から関連記憶を検索
   // ...（既存コード）

@@ -281,6 +295,8 @@ async function generatePersonalizedMessage({ profileId, habitType, habitName, sc
     trainingGoal,
     habitName: habitName || '',
     memories: memories || null,
+    idealTraits,
+    problems,
     todayStats
   };
```

**注意**: パッチ4で既にプロンプトテンプレートへの追加は完了しているため、このパッチX6は`generatePersonalizedMessage`関数内での変数追加とコンテキストへの注入のみ。

---

## 追加パッチ X7: FlowLayout共通化

**問題**: パッチ10,11でFlowLayoutを両ファイルに重複定義している。共通化すべき。

**新規ファイル作成**: `aniccaios/aniccaios/Components/FlowLayout.swift`

```swift
import SwiftUI

/// 自然な折り返しを行うFlowLayout
struct FlowLayout: Layout {
    var spacing: CGFloat = 12
    
    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        let result = arrangeSubviews(proposal: proposal, subviews: subviews)
        return result.size
    }
    
    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        let result = arrangeSubviews(proposal: proposal, subviews: subviews)
        for (index, position) in result.positions.enumerated() {
            subviews[index].place(
                at: CGPoint(x: bounds.minX + position.x, y: bounds.minY + position.y),
                proposal: .unspecified
            )
        }
    }
    
    private func arrangeSubviews(proposal: ProposedViewSize, subviews: Subviews) -> (size: CGSize, positions: [CGPoint]) {
        let maxWidth = proposal.width ?? .infinity
        var positions: [CGPoint] = []
        var currentX: CGFloat = 0
        var currentY: CGFloat = 0
        var lineHeight: CGFloat = 0
        var totalHeight: CGFloat = 0
        
        for subview in subviews {
            let size = subview.sizeThatFits(.unspecified)
            
            if currentX + size.width > maxWidth && currentX > 0 {
                currentX = 0
                currentY += lineHeight + spacing
                lineHeight = 0
            }
            
            positions.append(CGPoint(x: currentX, y: currentY))
            currentX += size.width + spacing
            lineHeight = max(lineHeight, size.height)
            totalHeight = max(totalHeight, currentY + lineHeight)
        }
        
        return (CGSize(width: maxWidth, height: totalHeight), positions)
    }
}
```

そして`IdealsStepView.swift`と`StrugglesStepView.swift`から`private struct FlowLayout`を削除し、代わりに共通の`FlowLayout`をインポート。

---

## 追加パッチ X8: FutureScenarioView.swift - 2行問題・横幅修正

**問題**: 両方空の場合に「Not enough data」が2行出る。横幅がTimelineViewと一致していない。

```diff
--- a/aniccaios/aniccaios/Views/Behavior/FutureScenarioView.swift
+++ b/aniccaios/aniccaios/Views/Behavior/FutureScenarioView.swift
@@ -4,21 +4,38 @@ import SwiftUI
 struct FutureScenarioView: View {
     let future: BehaviorSummary.FutureScenario

+    private var isEmpty: Bool {
+        future.ifContinue.isEmpty && future.ifImprove.isEmpty
+    }
+
     var body: some View {
+        if isEmpty {
+            // ★ データなし時は1行のみ表示
+            CardView {
+                Text(String(localized: "behavior_not_enough_data"))
+                    .font(AppTheme.Typography.subheadlineDynamic)
+                    .foregroundStyle(AppTheme.Colors.secondaryLabel)
+                    .frame(maxWidth: .infinity, alignment: .center)
+            }
+            .frame(maxWidth: .infinity)  // ★ TimelineViewと同じ横幅
+        } else {
             CardView {
                 VStack(alignment: .leading, spacing: 12) {
                     Text(String(localized: "behavior_title_future"))
                         .font(.system(size: 20, weight: .bold))
                         .foregroundStyle(AppTheme.Colors.label)

                     VStack(alignment: .leading, spacing: 8) {
-                        // migration-patch-v3.md 6.1 の JSON 順（ifContinue → ifImprove）に合わせて表示順を固定
-                        Text(future.ifContinue)
-                            .font(AppTheme.Typography.subheadlineDynamic)
-                            .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
-                        Text(future.ifImprove)
-                            .font(AppTheme.Typography.subheadlineDynamic)
-                            .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
+                        if !future.ifContinue.isEmpty {
+                            Text(future.ifContinue)
+                                .font(AppTheme.Typography.subheadlineDynamic)
+                                .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
+                        }
+                        if !future.ifImprove.isEmpty {
+                            Text(future.ifImprove)
+                                .font(AppTheme.Typography.subheadlineDynamic)
+                                .foregroundStyle(AppTheme.Colors.label.opacity(0.8))
+                        }
                     }
                 }
             }
+            .frame(maxWidth: .infinity)  // ★ TimelineViewと同じ横幅
+        }
     }
 }
```

---

## 追加パッチ X9: ProfileView.swift - Language行削除 + chevron削除（パッチ7と重複だが完全版として再掲）

**問題**: チェックリスト#12でLanguage行とchevronを削除する仕様。

```diff
--- a/aniccaios/aniccaios/Views/Profile/ProfileView.swift
+++ b/aniccaios/aniccaios/Views/Profile/ProfileView.swift
@@ -81,8 +81,6 @@ struct ProfileView: View {
                     row(label: String(localized: "profile_row_plan"), value: appState.subscriptionInfo.displayPlanName, showsChevron: true)
                 }
                 .buttonStyle(.plain)
-                divider
-                row(label: String(localized: "profile_row_language"), value: appState.userProfile.preferredLanguage.languageLine, showsChevron: false)
             }
         }
     }
@@ -111,9 +109,6 @@ struct ProfileView: View {
             } else {
                 Text(appState.userProfile.displayName.isEmpty ? "-" : appState.userProfile.displayName)
                     .font(.system(size: 16))
                     .foregroundStyle(AppTheme.Colors.secondaryLabel)
-                Image(systemName: "chevron.right")
-                    .font(.system(size: 14, weight: .semibold))
-                    .foregroundStyle(AppTheme.Colors.tertiaryLabel)
             }
         }
```

---

## 追加パッチ X10: HabitsTabView.swift - 歯車アイコン削除（パッチ8と重複だが完全版として再掲）

**問題**: チェックリスト#19でHabits画面の歯車を削除する仕様。

```diff
--- a/aniccaios/aniccaios/Habits/HabitsTabView.swift
+++ b/aniccaios/aniccaios/Habits/HabitsTabView.swift
@@ -3,21 +3,11 @@ import SwiftUI
 struct HabitsTabView: View {
     @EnvironmentObject private var appState: AppState
-    @State private var showingSettings = false
     
     var body: some View {
         NavigationStack {
             HabitsSectionView()
                 .navigationTitle(String(localized: "settings_habits"))
-                .toolbar {
-                    ToolbarItem(placement: .navigationBarTrailing) {
-                        Button(action: { showingSettings = true }) {
-                            Image(systemName: "gearshape")
-                        }
-                    }
-                }
-        }
-        .sheet(isPresented: $showingSettings) {
-            SettingsView()
-                .environmentObject(appState)
         }
         .background(AppBackground())
     }
 }
```

---

## 追加パッチ X11: NotificationPermissionStepView.swift - 許可/拒否後の自動遷移（パッチ9と重複だが完全版として再掲）

**問題**: 許可ダイアログで「許可」を押しても、さらにContinueを押さないと進めない。

```diff
--- a/aniccaios/aniccaios/Onboarding/NotificationPermissionStepView.swift
+++ b/aniccaios/aniccaios/Onboarding/NotificationPermissionStepView.swift
@@ -33,12 +33,12 @@ struct NotificationPermissionStepView: View {
             PrimaryButton(
                 title: isRequesting
                     ? String(localized: "common_requesting")
-                    : (notificationGranted ? String(localized: "common_continue") : String(localized: "onboarding_notifications_allow")),
+                    : (hasAttemptedPermission ? String(localized: "common_continue") : String(localized: "onboarding_notifications_allow")),
                 isEnabled: !isRequesting,
                 isLoading: isRequesting,
-                style: notificationGranted ? .selected : .primary
+                style: hasAttemptedPermission ? .selected : .primary
             ) {
-                if notificationGranted || hasAttemptedPermission {
+                if hasAttemptedPermission {
                     next()
                 } else {
                     requestNotifications()
@@ -62,8 +62,9 @@ struct NotificationPermissionStepView: View {
                 notificationGranted = granted
                 notificationDenied = !granted
                 isRequesting = false
                 hasAttemptedPermission = true
-                // v3: 自動遷移しない
+                // ★ 許可/拒否後に自動で次へ遷移
+                next()
             }
-            await refreshAuthorizationState(autoAdvance: false)
         }
     }
```

---

## 完全なパッチ一覧まとめ

| パッチ | 対象ファイル | 内容 | 状態 |
|--------|------------|------|------|
| 1 | OnboardingStep.swift | オンボーディングステップ順序変更 | ✅ |
| 2 | OnboardingFlowView.swift | フロー順序変更 | ✅ |
| **3** | **NotificationScheduler.swift** | **パーソナライズメッセージ事前取得方式に変更** | ✅ |
| **4** | **preReminder.js** | **完全パーソナライズ対応（名前必須、todayStats完全）** | ✅ |
| 5 | TalkView.swift | アラームからセッション画面への遷移 | ✅ |
| 6 | HabitSessionView.swift | 新規ファイル作成 | ✅ |
| 7 | ProfileView.swift | chevron削除、Language行削除 | ✅ |
| 8 | HabitsTabView.swift | 歯車アイコン削除 | ✅ |
| 9 | NotificationPermissionStepView.swift | 許可/拒否後の自動遷移 | ✅ |
| 10 | IdealsStepView.swift | レイアウト修正 | ✅ |
| 11 | StrugglesStepView.swift | レイアウト修正 | ✅ |
| 12 | Localizable.strings (en) | 新しいキー追加 | ✅ |
| 13 | Localizable.strings (ja) | 新しいキー追加 | ✅ |
| 14 | HabitsSectionView.swift | AlarmKit JIT許可 | ✅ |
| A | OnboardingStep.swift | completion削除（修正版） | ✅ |
| B | OnboardingFlowView.swift | completionなし（修正版） | ✅ |
| C | NotificationScheduler.swift | 通知タイミング変更 | ✅ |
| D | HabitPromptBuilder.swift | IDEAL_TRAITSローカライズ | ✅ |
| E | ProfileView.swift | Sleep/Stepsトグル2回目ON修正 | ✅ |
| F | HealthKitManager.swift | 認可状態チェック関数追加 | ✅ |
| G | FutureScenarioView.swift | 2行問題・横幅修正 | ✅ |
| H | HabitsSectionView.swift | トグルにtint追加 | ✅ |
| X1 | NotificationScheduler.swift | 起床5分前の事前通知を有効化 | ✅ |
| X3 | HealthKitManager.swift | 認可状態チェック関数追加 | ✅ |
| X4 | ProfileView.swift | Sleep/Stepsトグル2回目ON修正 | ✅ |
| X5 | HabitPromptBuilder.swift | IDEAL_TRAITSローカライズ | ✅ |
| X7 | FlowLayout.swift | FlowLayout共通化（新規ファイル） | ✅ |
| X8 | FutureScenarioView.swift | 2行問題・横幅修正 | ✅ |
| X9 | ProfileView.swift | Language行削除 + chevron削除 | ✅ |
| X10 | HabitsTabView.swift | 歯車アイコン削除 | ✅ |
| X11 | NotificationPermissionStepView.swift | 許可/拒否後の自動遷移 | ✅ |

---

## パーソナライズ通知で実現するユーザー体験

### Before（修正前）
- 事前通知は常に「起床5分前です」「就寝15分前です」などの**固定メッセージ**
- ユーザーの名前は含まれない
- 毎日同じメッセージ
- Notification Service Extensionが動作しないため、パーソナライズ不可能

### After（修正後）

**毎日違う、あなただけのメッセージが届く**

| 習慣 | 通知タイミング | メッセージ例 |
|------|--------------|-------------|
| **起床** | 5分前 | 「大助、おはよう。昨晩7時間眠れましたね、今日も自信を持って始めましょう」 |
| **就寝** | 15分前 | 「大助さん、今日は8000歩も歩きましたね。ゆっくり休んで明日に備えましょう」 |
| **トレーニング** | 15分前 | 「大助、トレーニングの時間です。ランナーを目指すあなたなら、今日も乗り越えられます」 |
| **カスタム** | 15分前 | 「大助、瞑想の時間が近づいています。穏やかな自分に一歩近づきましょう」 |

### グラウンディングされる情報（全て活用）

| データ | 説明 | 使用例 |
|--------|------|-------|
| **displayName** | ユーザー名 | 「大助、おはよう」 |
| **idealTraits** | なりたい自分 | 「ランナーを目指すあなた」 |
| **problems** | 今抱えている課題 | 「先延ばしを克服するために」 |
| **memories** | 過去の会話記録（mem0） | 「昨日の瞑想、良かったですね」 |
| **todayStats.steps** | 今日の歩数 | 「今日は8000歩も歩きました」 |
| **todayStats.sleepDurationMin** | 昨晩の睡眠時間 | 「昨晩7時間眠れましたね」 |
| **todayStats.snsMinutesTotal** | 今日のSNS利用時間 | 「SNSを控えめにできましたね」 |
| **sleepLocation/wakeLocation** | 場所 | コンテキストに応じて活用 |
| **trainingFocus** | トレーニング重点 | 「筋力強化に集中しましょう」 |

### 毎日更新される仕組み

1. **アプリ起動時**（24時間ごと）: 新しいパーソナライズメッセージを取得して通知を再登録
2. **習慣設定変更時**: 即座に新しいメッセージを取得
3. **サーバー失敗時**: デフォルトメッセージにフォールバック（通知は必ず届く）

### 言語対応

- **OSの言語設定に連動**: 日本語 → 日本語で通知、英語 → 英語で通知
- iOS側で`Locale.preferredLanguages`から検出し、サーバーに同期済み

---

### To-dos

- [ ] OnboardingStep.swift/OnboardingFlowView.swiftのフロー順序変更（value追加、paywall削除）
- [ ] マイク/通知/AlarmKit許可画面で許可・拒否後に自動遷移
- [ ] IdealsStepViewのレイアウト・選択肢をスクショ通りに修正
- [ ] StrugglesStepViewのレイアウト・選択肢をスクショ通りに修正
- [ ] ProfileViewからLanguage行を削除
- [ ] HabitsTabViewから歯車アイコンを削除
- [ ] 通知タイミング変更（就寝15分前、起床5分前追加）
- [ ] NotificationScheduler.swift - fetchPreReminderMessage関数追加
- [ ] NotificationScheduler.swift - refreshPreRemindersIfNeeded関数追加
- [ ] AppDelegate.swift - refreshPreRemindersIfNeeded呼び出し追加
- [ ] preReminder.js - 名前必須＋todayStats完全グラウンディング
- [ ] preReminder.js - formatSleepDuration関数追加
- [ ] プロンプトのIDEAL_TRAITS/PROBLEMSローカライズ修正
- [ ] FutureScenarioViewの2行表示・横幅修正
- [ ] Sleep/Stepsトグル2回目ONのエラー修正