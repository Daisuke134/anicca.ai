# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

platform :ios do
  # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
  PROJECT_NAME = "aniccaios"
  SCHEME = "aniccaios"
  BUNDLE_ID = "ai.anicca.app.ios"
  TEAM_ID = "S5U8UH3JLJ"
  APP_ID = "6755129214"
  
  # App Store Connect API èªè¨¼è¨­å®š
  API_KEY_ID = "D637C7RGFN"
  API_ISSUER_ID = "f53272d9-c12d-4d9d-811c-4eb658284e74"
  API_KEY_PATH = File.expand_path("~/Downloads/AuthKey_D637C7RGFN.p8")
  
  # API ã‚­ãƒ¼ã‚’å–å¾—
  def get_api_key
    app_store_connect_api_key(
      key_id: API_KEY_ID,
      issuer_id: API_ISSUER_ID,
      key_filepath: API_KEY_PATH,
      duration: 1200,
      in_house: false
    )
  end
  
  desc "Build and install on connected device"
  lane :build_for_device do |options|
    retry_count = options[:retry_count] || 0
    max_retries = 3
    
    begin
      # å®Ÿæ©Ÿç”¨Developmentãƒ“ãƒ«ãƒ‰
      build_app(
        scheme: SCHEME,
        export_method: "development",
        export_options: {
          method: "development",
          teamID: TEAM_ID
        },
        clean: true,
        output_directory: "./build",
        buildlog_path: "./build/logs"
      )
      
      # å®Ÿæ©Ÿã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
      install_on_device(
        ipa: lane_context[SharedValues::IPA_OUTPUT_PATH]
      )
      
      # ã‚¢ãƒ—ãƒªã‚’èµ·å‹•ï¼ˆTikTokè¦‹ã¦ã¦ã‚‚è‡ªå‹•é·ç§»ã€ãƒ‡ãƒã‚¤ã‚¹ãƒ­ãƒƒã‚¯è§£é™¤å¿…é ˆï¼‰
      begin
        json_output = sh("xcrun devicectl list devices --json-output /dev/stdout 2>/dev/null", log: false)
        require 'json'
        devices_data = JSON.parse(json_output)
        connected_devices = devices_data.dig("result", "devices")&.select { |d| d.dig("connectionProperties", "tunnelState") == "connected" }
        if connected_devices && !connected_devices.empty?
          device_id = connected_devices.first["identifier"]
          UI.message("ğŸ“± Launching app on device: #{device_id}")
          sh("xcrun devicectl device process launch --device '#{device_id}' #{BUNDLE_ID} || true")
        else
          UI.message("âš ï¸ No connected device found for auto-launch. Please open the app manually.")
        end
      rescue => e
        UI.message("âš ï¸ Could not auto-launch app: #{e.message}")
      end
      
      UI.success("âœ… Build completed, installed, and launched on device!")
      
      # macOSé€šçŸ¥
      notification(
        title: "Anicca iOS",
        message: "Build installed and launched!",
        sound: "default"
      )
      
    rescue => ex
      UI.error("âŒ Build failed: #{ex.message}")
      
      # ãƒ“ãƒ«ãƒ‰ãƒ­ã‚°ã‚’è§£æ
      log_path = lane_context[SharedValues::XCODEBUILD_BUILDLOG_PATH] || "./build/logs"
      if Dir.exist?(log_path)
        latest_log = Dir.glob("#{log_path}/**/*.log").max_by { |f| File.mtime(f) }
        if latest_log
          UI.important("ğŸ“‹ Analyzing build log: #{latest_log}")
          # ãƒ­ã‚°ã‹ã‚‰ã‚¨ãƒ©ãƒ¼ã‚’æŠ½å‡ºã—ã¦è¡¨ç¤º
          error_summary = extract_build_errors(latest_log)
          if error_summary && !error_summary[:errors].empty?
            display_error_analysis(error_summary)
            suggest_fixes(error_summary)
          end
        end
      end
      
      # ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯å†è©¦è¡Œ
      if retry_count < max_retries && retryable_error?(ex)
        UI.important("ğŸ”„ Retrying build (attempt #{retry_count + 1}/#{max_retries})...")
        sleep(2)
        build_for_device(retry_count: retry_count + 1)
      else
        UI.user_error!("Build failed after #{retry_count + 1} attempts. Please check the errors above.")
      end
    end
  end
  
  # ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ã‚’æŠ½å‡º
  def extract_build_errors(log_path)
    return nil unless File.exist?(log_path)
    
    log_content = File.read(log_path)
    errors = []
    
    # Swiftã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    log_content.scan(/error:.*$/i) do |error_line|
      error_line = error_line.strip
      
      # ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸è¶³
      if error_line.match?(/cannot find|no such module|use of undeclared type/i)
        if match = error_line.match(/['"]([^'"]+)['"]/)
          errors << {
            type: :missing_import,
            message: error_line,
            module: match[1],
            suggestion: "Add 'import #{match[1]}' at the top of the file"
          }
        end
      # ã‚¹ã‚³ãƒ¼ãƒ—ä¸è¶³
      elsif error_line.match?(/cannot find|value of type.*has no member/i)
        if match = error_line.match(/['"]([^'"]+)['"]/)
          errors << {
            type: :missing_scope,
            message: error_line,
            symbol: match[1],
            suggestion: "Check if '#{match[1]}' is accessible in the current scope"
          }
        end
      # æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
      elsif error_line.match?(/expected|unexpected|invalid token/i)
        errors << {
          type: :syntax_error,
          message: error_line,
          suggestion: "Check syntax around the error location"
        }
      end
    end
    
    # ãƒ•ã‚¡ã‚¤ãƒ«åã¨è¡Œç•ªå·ã‚’æŠ½å‡º
    errors.each do |error|
      if match = log_content.match(/([^:]+):(\d+):(\d+):.*#{Regexp.escape(error[:message])}/)
        error[:file] = match[1]
        error[:line] = match[2].to_i
        error[:column] = match[3].to_i
      end
    end
    
    { errors: errors, has_errors: !errors.empty? }
  end
  
  # ã‚¨ãƒ©ãƒ¼åˆ†æã‚’è¡¨ç¤º
  def display_error_analysis(error_summary)
    return unless error_summary && error_summary[:has_errors]
    
    UI.important("=" * 80)
    UI.important("ğŸ” BUILD ERROR ANALYSIS")
    UI.important("=" * 80)
    
    error_summary[:errors].each_with_index do |error, index|
      UI.error("\n[Error #{index + 1}] #{error[:type].to_s.upcase}")
      UI.error("  Message: #{error[:message]}")
      if error[:file]
        UI.error("  File: #{error[:file]}:#{error[:line]}:#{error[:column]}")
      end
      if error[:suggestion]
        UI.important("  ğŸ’¡ Suggestion: #{error[:suggestion]}")
      end
    end
    
    UI.important("=" * 80)
  end
  
  # ä¿®æ­£æ¡ˆã‚’æç¤º
  def suggest_fixes(error_summary)
    return unless error_summary && error_summary[:has_errors]
    
    UI.important("\nğŸ“ SUGGESTED FIXES:")
    
    missing_imports = error_summary[:errors].select { |e| e[:type] == :missing_import }
    if missing_imports.any?
      UI.important("\n  Missing imports detected:")
      missing_imports.each do |error|
        UI.important("    - Add 'import #{error[:module]}' to #{error[:file] || 'the file'}")
      end
    end
    
    missing_scopes = error_summary[:errors].select { |e| e[:type] == :missing_scope }
    if missing_scopes.any?
      UI.important("\n  Scope issues detected:")
      missing_scopes.each do |error|
        UI.important("    - Check accessibility of '#{error[:symbol]}' in #{error[:file] || 'the file'}")
      end
    end
    
    UI.important("\n  After fixing, run: fastlane build_for_device")
  end
  
  # ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
  def retryable_error?(error)
    error_message = error.message.downcase
    # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚„ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã¯ãƒªãƒˆãƒ©ã‚¤å¯èƒ½
    retryable_patterns = [
      /network/i,
      /timeout/i,
      /temporary/i,
      /connection/i
    ]
    
    retryable_patterns.any? { |pattern| error_message.match?(pattern) }
  end

  desc "Build, archive, and export IPA for App Store"
  lane :build do
    build_app(
      scheme: SCHEME,
      export_method: "app-store",
      export_options: {
        method: "app-store",
        teamID: TEAM_ID,
        signingStyle: "automatic",
        uploadBitcode: false,
        uploadSymbols: true,
        stripSwiftSymbols: true,
        generateAppStoreInformation: true
      },
      clean: true
    )
    
    UI.success("âœ… Build completed! IPA: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}")
  end

  desc "Upload IPA to App Store Connect"
  lane :upload do
    api_key = get_api_key
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    
    unless ipa_path
      UI.user_error!("No IPA found. Run 'fastlane build' first.")
    end
    
    upload_to_app_store(
      api_key: api_key,
      ipa: ipa_path,
      skip_metadata: true,
      skip_screenshots: true,
      force: true
    )
    
    UI.success("âœ… Upload completed! Build will appear in App Store Connect within a few minutes.")
  end

  desc "Build and upload only (use full_release for complete automation)"
  lane :release do
    # 1. ãƒ“ãƒ«ãƒ‰ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    build
    
    # 2. App Store Connectã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    upload
    
    UI.success("âœ… Build uploaded to App Store Connect!")
    UI.important("")
    UI.important("ğŸ“‹ For complete automation (including review submission), use:")
    UI.important("   fastlane full_release")
  end

  desc "Wait for build processing to complete"
  lane :wait_for_processing do |options|
    api_key = get_api_key
    
    # ç¾åœ¨ã®ãƒ“ãƒ«ãƒ‰ç•ªå·ã‚’å–å¾—ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‰ã®æœ€æ–° + 1ï¼‰
    current_build = options[:build_number]
    unless current_build
      # æœ€æ–°ã®TestFlightãƒ“ãƒ«ãƒ‰ç•ªå·ã‚’å–å¾—ã—ã¦1ã‚’è¶³ã™
      current_build = latest_testflight_build_number(api_key: api_key).to_i
    end
    
    UI.important("â³ Waiting for build #{current_build} to finish processing...")
    
    # Spaceship APIã‚’åˆæœŸåŒ–
    Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(
      key_id: API_KEY_ID,
      issuer_id: API_ISSUER_ID,
      filepath: API_KEY_PATH
    )
    
    max_attempts = 60  # æœ€å¤§30åˆ†å¾…æ©Ÿï¼ˆ30ç§’é–“éš” Ã— 60å›ï¼‰
    attempts = 0
    
    loop do
      attempts += 1
      
      begin
        # ã‚¢ãƒ—ãƒªã®ãƒ“ãƒ«ãƒ‰ä¸€è¦§ã‚’å–å¾—
        app = Spaceship::ConnectAPI::App.find(BUNDLE_ID)
        builds = app.get_builds(
          filter: { version: current_build.to_s },
          includes: "preReleaseVersion"
        )
        
        if builds.any?
          build = builds.first
          processing_state = build.processing_state
          
          UI.message("  Attempt #{attempts}/#{max_attempts}: Build #{current_build} state = #{processing_state}")
          
          if processing_state == "VALID"
            UI.success("âœ… Build #{current_build} processing complete!")
            return build
          elsif processing_state == "INVALID"
            UI.user_error!("âŒ Build #{current_build} failed processing!")
          end
        else
          UI.message("  Attempt #{attempts}/#{max_attempts}: Build #{current_build} not yet visible...")
        end
      rescue => e
        UI.message("  Attempt #{attempts}/#{max_attempts}: Error checking build: #{e.message}")
      end
      
      if attempts >= max_attempts
        UI.user_error!("âŒ Timeout waiting for build #{current_build} to process")
      end
      
      sleep(30)
    end
  end

  desc "Submit the latest build for App Store review"
  lane :submit_review do |options|
    api_key = get_api_key
    
    # æœ€æ–°ã®ãƒ“ãƒ«ãƒ‰ç•ªå·ã‚’å–å¾—
    build_number = options[:build_number] || latest_testflight_build_number(api_key: api_key)
    version = options[:version] || get_version_number(target: PROJECT_NAME)
    
    UI.important("ğŸ“¤ Submitting build #{build_number} (v#{version}) for App Store review...")
    
    deliver(
      api_key: api_key,
      app_identifier: BUNDLE_ID,
      skip_metadata: true,
      skip_screenshots: true,
      skip_binary_upload: true,
      build_number: build_number.to_s,
      submit_for_review: true,
      automatic_release: true,
      force: true,
      submission_information: {
        add_id_info_serves_ads: false,
        add_id_info_tracks_action: false,
        add_id_info_tracks_install: false,
        add_id_info_uses_idfa: false,
        content_rights_contains_third_party_content: false,
        content_rights_has_rights: true,
        export_compliance_uses_encryption: false,
        export_compliance_is_exempt: true
      }
    )
    
    UI.success("âœ… Build #{build_number} submitted for App Store review!")
    
    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "Build #{build_number} submitted for App Store review!",
      sound: "default"
    )
  end

  desc "Complete automated release: build, upload, wait, and submit for review"
  lane :full_release do
    UI.important("ğŸš€ Starting full automated release...")
    start_time = Time.now
    
    # 1. ãƒ“ãƒ«ãƒ‰ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    UI.important("[1/4] Building and archiving...")
    build
    
    # 2. App Store Connectã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    UI.important("[2/4] Uploading to App Store Connect...")
    upload
    
    # 3. ãƒ“ãƒ«ãƒ‰å‡¦ç†å¾…æ©Ÿ
    UI.important("[3/4] Waiting for build processing...")
    wait_for_processing
    
    # 4. å¯©æŸ»æå‡º
    UI.important("[4/4] Submitting for App Store review...")
    submit_review
    
    elapsed = ((Time.now - start_time) / 60).round(1)
    UI.success("ğŸ‰ Full release completed in #{elapsed} minutes!")
    
    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS Release Complete",
      message: "Full release completed in #{elapsed} minutes!",
      sound: "Glass"
    )
  end

  desc "Build and run on simulator"
  lane :build_for_simulator do
    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ç”¨ãƒ“ãƒ«ãƒ‰
    build_app(
      scheme: SCHEME,
      configuration: "Debug",
      destination: "generic/platform=iOS Simulator",
      derived_data_path: "./build/DerivedData",
      skip_archive: true,
      skip_codesigning: true,
      output_directory: "./build"
    )

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’èµ·å‹•ã—ã¦ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    sh("xcrun simctl boot 'iPhone 16 Pro' 2>/dev/null || true")

    # ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆ.appãƒãƒ³ãƒ‰ãƒ«ã‚’æ¢ã™ï¼‰
    app_path = Dir.glob("./build/DerivedData/Build/Products/Debug-iphonesimulator/*.app").first
    if app_path
      sh("xcrun simctl install booted '#{app_path}'")
      sh("xcrun simctl launch booted #{BUNDLE_ID}")
      UI.success("âœ… App installed and launched on simulator!")
    else
      UI.error("âŒ Could not find .app bundle")
    end

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚¢ãƒ—ãƒªã‚’å‰é¢ã«
    sh("open -a Simulator")

    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "App launched on simulator!",
      sound: "default"
    )
  end

  desc "Run unit tests on simulator"
  lane :test do
    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    run_tests(
      project: "aniccaios.xcodeproj",
      scheme: "aniccaios-staging",
      device: "iPhone 16 Pro",
      clean: false,
      code_coverage: true,
      output_directory: "./build/test_output",
      output_types: "html,junit"
    )

    UI.success("âœ… All tests passed!")

    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS Tests",
      message: "All tests passed!",
      sound: "default"
    )
  end

  desc "Quick test: build and install on device, then notify"
  lane :test_on_device do
    start_time = Time.now
    
    build_for_device
    
    elapsed = ((Time.now - start_time) / 60).round(1)
    
    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "Build installed on device in #{elapsed} minutes!",
      sound: "default"
    )
  end
end

