# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

default_platform(:ios)

platform :ios do
  # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
  PROJECT_NAME = "aniccaios"
  SCHEME = "aniccaios"
  BUNDLE_ID = "ai.anicca.app.ios"
  TEAM_ID = "S5U8UH3JLJ"
  APP_ID = "6755129214"
  
  # App Store Connect API èªè¨¼è¨­å®š
  API_KEY_ID = "D637C7RGFN"
  API_ISSUER_ID = "f53272d9-c12d-4d9d-811c-4eb658284e74"
  API_KEY_PATH = File.expand_path("~/Downloads/AuthKey_D637C7RGFN.p8")
  
  # API ã‚­ãƒ¼ã‚’å–å¾—
  def get_api_key
    app_store_connect_api_key(
      key_id: API_KEY_ID,
      issuer_id: API_ISSUER_ID,
      key_filepath: API_KEY_PATH,
      duration: 1200,
      in_house: false
    )
  end
  
  desc "Build and install on connected device"
  lane :build_for_device do |options|
    selected_scheme = options[:scheme] || SCHEME
    project_path = File.expand_path("../aniccaios.xcodeproj", __dir__)
    derived_data = File.expand_path("./build/DerivedData")

    # æ¥ç¶šãƒ‡ãƒã‚¤ã‚¹ã‚’æ¤œå‡ºï¼ˆxctrace ã® UDID ã‚’ä½¿ç”¨ â€” xcodebuild ã¨äº’æ›æ€§ã‚ã‚Šï¼‰
    device_lines = sh("xcrun xctrace list devices 2>&1", log: false)
      .split("\n")
      .select { |l| l.include?("(") && !l.include?("Simulator") && !l.include?("MacBook") && !l.include?("== ") }
      .reject { |l| l.strip.empty? }
    UI.user_error!("âŒ No connected device found. Please connect your iPhone.") if device_lines.empty?
    # ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: "Device Name  (OS) (UDID)"
    match = device_lines.first.match(/^(.+?)\s+\([\d.]+\)\s+\(([A-F0-9\-]+)\)$/i)
    UI.user_error!("âŒ Could not parse device info: #{device_lines.first}") unless match
    device_name = match[1].strip
    device_id = match[2]
    UI.important("ğŸ“± Target device: #{device_name} (#{device_id})")

    # xcodebuild build ã§ç›´æ¥ãƒ‡ãƒã‚¤ã‚¹å‘ã‘ã«ãƒ“ãƒ«ãƒ‰ï¼ˆXcode 26 å¯¾å¿œ: archive+export ã‚’å›é¿ï¼‰
    UI.important("ğŸ”¨ Building #{selected_scheme} for device...")
    build_log = "#{derived_data}/build_for_device.log"
    FileUtils.mkdir_p(derived_data)
    sh(
      "xcodebuild build " \
      "-scheme '#{selected_scheme}' " \
      "-project '#{project_path}' " \
      "-destination 'platform=iOS,id=#{device_id}' " \
      "-derivedDataPath '#{derived_data}' " \
      "-allowProvisioningUpdates " \
      "ONLY_ACTIVE_ARCH=YES " \
      "2>&1 | tee '#{build_log}' | xcpretty"
    )

    # ãƒ“ãƒ«ãƒ‰æˆæœç‰©ã® .app ã‚’æ¢ã™
    app_path = Dir.glob("#{derived_data}/Build/Products/*-iphoneos/#{PROJECT_NAME}.app").first
    UI.user_error!("âŒ Could not find .app bundle in #{derived_data}") unless app_path
    UI.message("ğŸ“¦ Built app: #{app_path}")

    # ios-deploy ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ« & èµ·å‹•
    UI.important("ğŸ“² Installing on device...")
    sh("ios-deploy --bundle '#{app_path}' --justlaunch --no-wifi 2>&1 || true")

    UI.success("âœ… Build completed, installed, and launched on device!")

    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "Build installed and launched on #{device_name}!",
      sound: "default"
    )
  end
  
  # ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼ã‚’æŠ½å‡º
  def extract_build_errors(log_path)
    return nil unless File.exist?(log_path)
    
    log_content = File.read(log_path)
    errors = []
    
    # Swiftã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
    log_content.scan(/error:.*$/i) do |error_line|
      error_line = error_line.strip
      
      # ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸è¶³
      if error_line.match?(/cannot find|no such module|use of undeclared type/i)
        if match = error_line.match(/['"]([^'"]+)['"]/)
          errors << {
            type: :missing_import,
            message: error_line,
            module: match[1],
            suggestion: "Add 'import #{match[1]}' at the top of the file"
          }
        end
      # ã‚¹ã‚³ãƒ¼ãƒ—ä¸è¶³
      elsif error_line.match?(/cannot find|value of type.*has no member/i)
        if match = error_line.match(/['"]([^'"]+)['"]/)
          errors << {
            type: :missing_scope,
            message: error_line,
            symbol: match[1],
            suggestion: "Check if '#{match[1]}' is accessible in the current scope"
          }
        end
      # æ§‹æ–‡ã‚¨ãƒ©ãƒ¼
      elsif error_line.match?(/expected|unexpected|invalid token/i)
        errors << {
          type: :syntax_error,
          message: error_line,
          suggestion: "Check syntax around the error location"
        }
      end
    end
    
    # ãƒ•ã‚¡ã‚¤ãƒ«åã¨è¡Œç•ªå·ã‚’æŠ½å‡º
    errors.each do |error|
      if match = log_content.match(/([^:]+):(\d+):(\d+):.*#{Regexp.escape(error[:message])}/)
        error[:file] = match[1]
        error[:line] = match[2].to_i
        error[:column] = match[3].to_i
      end
    end
    
    { errors: errors, has_errors: !errors.empty? }
  end
  
  # ã‚¨ãƒ©ãƒ¼åˆ†æã‚’è¡¨ç¤º
  def display_error_analysis(error_summary)
    return unless error_summary && error_summary[:has_errors]
    
    UI.important("=" * 80)
    UI.important("ğŸ” BUILD ERROR ANALYSIS")
    UI.important("=" * 80)
    
    error_summary[:errors].each_with_index do |error, index|
      UI.error("\n[Error #{index + 1}] #{error[:type].to_s.upcase}")
      UI.error("  Message: #{error[:message]}")
      if error[:file]
        UI.error("  File: #{error[:file]}:#{error[:line]}:#{error[:column]}")
      end
      if error[:suggestion]
        UI.important("  ğŸ’¡ Suggestion: #{error[:suggestion]}")
      end
    end
    
    UI.important("=" * 80)
  end
  
  # ä¿®æ­£æ¡ˆã‚’æç¤º
  def suggest_fixes(error_summary)
    return unless error_summary && error_summary[:has_errors]
    
    UI.important("\nğŸ“ SUGGESTED FIXES:")
    
    missing_imports = error_summary[:errors].select { |e| e[:type] == :missing_import }
    if missing_imports.any?
      UI.important("\n  Missing imports detected:")
      missing_imports.each do |error|
        UI.important("    - Add 'import #{error[:module]}' to #{error[:file] || 'the file'}")
      end
    end
    
    missing_scopes = error_summary[:errors].select { |e| e[:type] == :missing_scope }
    if missing_scopes.any?
      UI.important("\n  Scope issues detected:")
      missing_scopes.each do |error|
        UI.important("    - Check accessibility of '#{error[:symbol]}' in #{error[:file] || 'the file'}")
      end
    end
    
    UI.important("\n  After fixing, run: fastlane build_for_device")
  end
  
  # ãƒªãƒˆãƒ©ã‚¤å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ã‹ãƒã‚§ãƒƒã‚¯
  def retryable_error?(error)
    error_message = error.message.downcase
    # ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã‚„ä¸€æ™‚çš„ãªã‚¨ãƒ©ãƒ¼ã¯ãƒªãƒˆãƒ©ã‚¤å¯èƒ½
    retryable_patterns = [
      /network/i,
      /timeout/i,
      /temporary/i,
      /connection/i
    ]
    
    retryable_patterns.any? { |pattern| error_message.match?(pattern) }
  end

  desc "Build, archive, and export IPA for App Store"
  lane :build do
    build_app(
      scheme: SCHEME,
      export_method: "app-store",
      export_options: {
        method: "app-store",
        teamID: TEAM_ID,
        signingStyle: "automatic",
        uploadBitcode: false,
        uploadSymbols: true,
        stripSwiftSymbols: true,
        generateAppStoreInformation: true
      },
      clean: true
    )
    
    UI.success("âœ… Build completed! IPA: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}")
  end

  desc "Upload IPA to App Store Connect"
  lane :upload do
    api_key = get_api_key
    ipa_path = lane_context[SharedValues::IPA_OUTPUT_PATH]
    
    unless ipa_path
      UI.user_error!("No IPA found. Run 'fastlane build' first.")
    end
    
    upload_to_app_store(
      api_key: api_key,
      ipa: ipa_path,
      skip_metadata: true,
      skip_screenshots: true,
      force: true
    )
    
    UI.success("âœ… Upload completed! Build will appear in App Store Connect within a few minutes.")
  end

  desc "Build and upload only (use full_release for complete automation)"
  lane :release do
    # 1. ãƒ“ãƒ«ãƒ‰ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    build
    
    # 2. App Store Connectã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    upload
    
    UI.success("âœ… Build uploaded to App Store Connect!")
    UI.important("")
    UI.important("ğŸ“‹ For complete automation (including review submission), use:")
    UI.important("   fastlane full_release")
  end

  desc "Wait for build processing to complete"
  lane :wait_for_processing do |options|
    api_key = get_api_key
    
    # ç¾åœ¨ã®ãƒ“ãƒ«ãƒ‰ç•ªå·ã‚’å–å¾—ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‰ã®æœ€æ–° + 1ï¼‰
    current_build = options[:build_number]
    unless current_build
      # æœ€æ–°ã®TestFlightãƒ“ãƒ«ãƒ‰ç•ªå·ã‚’å–å¾—ã—ã¦1ã‚’è¶³ã™
      current_build = latest_testflight_build_number(api_key: api_key).to_i
    end
    
    UI.important("â³ Waiting for build #{current_build} to finish processing...")
    
    # Spaceship APIã‚’åˆæœŸåŒ–
    Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(
      key_id: API_KEY_ID,
      issuer_id: API_ISSUER_ID,
      filepath: API_KEY_PATH
    )
    
    max_attempts = 60  # æœ€å¤§30åˆ†å¾…æ©Ÿï¼ˆ30ç§’é–“éš” Ã— 60å›ï¼‰
    attempts = 0
    
    loop do
      attempts += 1
      
      begin
        # ã‚¢ãƒ—ãƒªã®ãƒ“ãƒ«ãƒ‰ä¸€è¦§ã‚’å–å¾—
        app = Spaceship::ConnectAPI::App.find(BUNDLE_ID)
        builds = app.get_builds(
          filter: { version: current_build.to_s },
          includes: "preReleaseVersion"
        )
        
        if builds.any?
          build = builds.first
          processing_state = build.processing_state
          
          UI.message("  Attempt #{attempts}/#{max_attempts}: Build #{current_build} state = #{processing_state}")
          
          if processing_state == "VALID"
            UI.success("âœ… Build #{current_build} processing complete!")
            return build
          elsif processing_state == "INVALID"
            UI.user_error!("âŒ Build #{current_build} failed processing!")
          end
        else
          UI.message("  Attempt #{attempts}/#{max_attempts}: Build #{current_build} not yet visible...")
        end
      rescue => e
        UI.message("  Attempt #{attempts}/#{max_attempts}: Error checking build: #{e.message}")
      end
      
      if attempts >= max_attempts
        UI.user_error!("âŒ Timeout waiting for build #{current_build} to process")
      end
      
      sleep(30)
    end
  end

  desc "Submit the latest build for App Store review"
  lane :submit_review do |options|
    api_key = get_api_key
    
    # æœ€æ–°ã®ãƒ“ãƒ«ãƒ‰ç•ªå·ã‚’å–å¾—
    build_number = options[:build_number] || latest_testflight_build_number(api_key: api_key)
    version = options[:version] || get_version_number(target: PROJECT_NAME)
    
    UI.important("ğŸ“¤ Submitting build #{build_number} (v#{version}) for App Store review...")
    
    deliver(
      api_key: api_key,
      app_identifier: BUNDLE_ID,
      skip_metadata: true,
      skip_screenshots: true,
      skip_binary_upload: true,
      build_number: build_number.to_s,
      submit_for_review: true,
      automatic_release: true,
      force: true,
      submission_information: {
        add_id_info_serves_ads: false,
        add_id_info_tracks_action: false,
        add_id_info_tracks_install: false,
        add_id_info_uses_idfa: false,
        content_rights_contains_third_party_content: false,
        content_rights_has_rights: true,
        export_compliance_uses_encryption: false,
        export_compliance_is_exempt: true
      }
    )
    
    UI.success("âœ… Build #{build_number} submitted for App Store review!")
    
    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "Build #{build_number} submitted for App Store review!",
      sound: "default"
    )
  end

  desc "Complete automated release: build, upload, wait, and submit for review"
  lane :full_release do
    UI.important("ğŸš€ Starting full automated release...")
    start_time = Time.now
    
    # 1. ãƒ“ãƒ«ãƒ‰ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    UI.important("[1/4] Building and archiving...")
    build
    
    # 2. App Store Connectã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    UI.important("[2/4] Uploading to App Store Connect...")
    upload
    
    # 3. ãƒ“ãƒ«ãƒ‰å‡¦ç†å¾…æ©Ÿ
    UI.important("[3/4] Waiting for build processing...")
    wait_for_processing
    
    # 4. å¯©æŸ»æå‡º
    UI.important("[4/4] Submitting for App Store review...")
    submit_review
    
    elapsed = ((Time.now - start_time) / 60).round(1)
    UI.success("ğŸ‰ Full release completed in #{elapsed} minutes!")
    
    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS Release Complete",
      message: "Full release completed in #{elapsed} minutes!",
      sound: "Glass"
    )
  end

  desc "Build and run on simulator"
  lane :build_for_simulator do
    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ç”¨ãƒ“ãƒ«ãƒ‰
    build_app(
      scheme: SCHEME,
      configuration: "Debug",
      destination: "generic/platform=iOS Simulator",
      derived_data_path: "./build/DerivedData",
      skip_archive: true,
      skip_codesigning: true,
      output_directory: "./build"
    )

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚’èµ·å‹•ã—ã¦ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
    sh("xcrun simctl boot 'iPhone 16 Pro' 2>/dev/null || true")

    # ã‚¢ãƒ—ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆ.appãƒãƒ³ãƒ‰ãƒ«ã‚’æ¢ã™ï¼‰
    app_path = Dir.glob("./build/DerivedData/Build/Products/Debug-iphonesimulator/*.app").first
    if app_path
      sh("xcrun simctl install booted '#{app_path}'")
      sh("xcrun simctl launch booted #{BUNDLE_ID}")
      UI.success("âœ… App installed and launched on simulator!")
    else
      UI.error("âŒ Could not find .app bundle")
    end

    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã‚¢ãƒ—ãƒªã‚’å‰é¢ã«
    sh("open -a Simulator")

    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "App launched on simulator!",
      sound: "default"
    )
  end

  desc "Run unit tests on simulator"
  lane :test do
    # ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ã§ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    run_tests(
      project: "aniccaios.xcodeproj",
      scheme: "aniccaios-staging",
      device: "iPhone 16 Pro",
      clean: false,
      code_coverage: true,
      output_directory: "./build/test_output",
      output_types: "html,junit"
    )

    UI.success("âœ… All tests passed!")

    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS Tests",
      message: "All tests passed!",
      sound: "default"
    )
  end

  desc "Set MARKETING_VERSION across all targets"
  lane :set_version do |options|
    version = options[:version]
    UI.user_error!("Usage: fastlane set_version version:X.Y.Z") unless version
    UI.user_error!("Invalid format. Expected X.Y.Z, got: #{version}") unless version.match?(/^\d+\.\d+\.\d+$/)

    pbxproj = File.expand_path("../aniccaios.xcodeproj/project.pbxproj", __dir__)
    UI.user_error!("#{pbxproj} not found") unless File.exist?(pbxproj)

    content = File.read(pbxproj)
    count = content.scan(/MARKETING_VERSION = [0-9]+\.[0-9]+\.[0-9]+;/).length
    updated = content.gsub(/MARKETING_VERSION = [0-9]+\.[0-9]+\.[0-9]+;/, "MARKETING_VERSION = #{version};")
    File.write(pbxproj, updated)

    UI.success("âœ… MARKETING_VERSION updated to #{version} (#{count} occurrences)")
  end

  desc "Quick test: build and install on device, then notify"
  lane :test_on_device do
    start_time = Time.now
    
    build_for_device
    
    elapsed = ((Time.now - start_time) / 60).round(1)
    
    # macOSé€šçŸ¥
    notification(
      title: "Anicca iOS",
      message: "Build installed on device in #{elapsed} minutes!",
      sound: "default"
    )
  end
end

