
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model MobileProfile
 * 
 */
export type MobileProfile = $Result.DefaultSelection<Prisma.$MobileProfilePayload>
/**
 * Model UserSubscription
 * 
 */
export type UserSubscription = $Result.DefaultSelection<Prisma.$UserSubscriptionPayload>
/**
 * Model SubscriptionEvent
 * 
 */
export type SubscriptionEvent = $Result.DefaultSelection<Prisma.$SubscriptionEventPayload>
/**
 * Model MonthlyVcGrant
 * 
 */
export type MonthlyVcGrant = $Result.DefaultSelection<Prisma.$MonthlyVcGrantPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model UserSetting
 * 
 */
export type UserSetting = $Result.DefaultSelection<Prisma.$UserSettingPayload>
/**
 * Model UserTrait
 * 
 */
export type UserTrait = $Result.DefaultSelection<Prisma.$UserTraitPayload>
/**
 * Model DailyMetric
 * 
 */
export type DailyMetric = $Result.DefaultSelection<Prisma.$DailyMetricPayload>
/**
 * Model NudgeEvent
 * 
 */
export type NudgeEvent = $Result.DefaultSelection<Prisma.$NudgeEventPayload>
/**
 * Model NudgeOutcome
 * 
 */
export type NudgeOutcome = $Result.DefaultSelection<Prisma.$NudgeOutcomePayload>
/**
 * Model FeelingSession
 * 
 */
export type FeelingSession = $Result.DefaultSelection<Prisma.$FeelingSessionPayload>
/**
 * Model BanditModel
 * 
 */
export type BanditModel = $Result.DefaultSelection<Prisma.$BanditModelPayload>
/**
 * Model UserTypeEstimate
 * 
 */
export type UserTypeEstimate = $Result.DefaultSelection<Prisma.$UserTypeEstimatePayload>
/**
 * Model TypeStats
 * 
 */
export type TypeStats = $Result.DefaultSelection<Prisma.$TypeStatsPayload>
/**
 * Model HookCandidate
 * 
 */
export type HookCandidate = $Result.DefaultSelection<Prisma.$HookCandidatePayload>
/**
 * Model TiktokPost
 * 
 */
export type TiktokPost = $Result.DefaultSelection<Prisma.$TiktokPostPayload>
/**
 * Model WisdomPattern
 * 
 */
export type WisdomPattern = $Result.DefaultSelection<Prisma.$WisdomPatternPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tokens
 * const tokens = await prisma.token.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tokens
   * const tokens = await prisma.token.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.mobileProfile`: Exposes CRUD operations for the **MobileProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobileProfiles
    * const mobileProfiles = await prisma.mobileProfile.findMany()
    * ```
    */
  get mobileProfile(): Prisma.MobileProfileDelegate<ExtArgs>;

  /**
   * `prisma.userSubscription`: Exposes CRUD operations for the **UserSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSubscriptions
    * const userSubscriptions = await prisma.userSubscription.findMany()
    * ```
    */
  get userSubscription(): Prisma.UserSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.subscriptionEvent`: Exposes CRUD operations for the **SubscriptionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionEvents
    * const subscriptionEvents = await prisma.subscriptionEvent.findMany()
    * ```
    */
  get subscriptionEvent(): Prisma.SubscriptionEventDelegate<ExtArgs>;

  /**
   * `prisma.monthlyVcGrant`: Exposes CRUD operations for the **MonthlyVcGrant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthlyVcGrants
    * const monthlyVcGrants = await prisma.monthlyVcGrant.findMany()
    * ```
    */
  get monthlyVcGrant(): Prisma.MonthlyVcGrantDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.userSetting`: Exposes CRUD operations for the **UserSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSetting.findMany()
    * ```
    */
  get userSetting(): Prisma.UserSettingDelegate<ExtArgs>;

  /**
   * `prisma.userTrait`: Exposes CRUD operations for the **UserTrait** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTraits
    * const userTraits = await prisma.userTrait.findMany()
    * ```
    */
  get userTrait(): Prisma.UserTraitDelegate<ExtArgs>;

  /**
   * `prisma.dailyMetric`: Exposes CRUD operations for the **DailyMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyMetrics
    * const dailyMetrics = await prisma.dailyMetric.findMany()
    * ```
    */
  get dailyMetric(): Prisma.DailyMetricDelegate<ExtArgs>;

  /**
   * `prisma.nudgeEvent`: Exposes CRUD operations for the **NudgeEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NudgeEvents
    * const nudgeEvents = await prisma.nudgeEvent.findMany()
    * ```
    */
  get nudgeEvent(): Prisma.NudgeEventDelegate<ExtArgs>;

  /**
   * `prisma.nudgeOutcome`: Exposes CRUD operations for the **NudgeOutcome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NudgeOutcomes
    * const nudgeOutcomes = await prisma.nudgeOutcome.findMany()
    * ```
    */
  get nudgeOutcome(): Prisma.NudgeOutcomeDelegate<ExtArgs>;

  /**
   * `prisma.feelingSession`: Exposes CRUD operations for the **FeelingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeelingSessions
    * const feelingSessions = await prisma.feelingSession.findMany()
    * ```
    */
  get feelingSession(): Prisma.FeelingSessionDelegate<ExtArgs>;

  /**
   * `prisma.banditModel`: Exposes CRUD operations for the **BanditModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BanditModels
    * const banditModels = await prisma.banditModel.findMany()
    * ```
    */
  get banditModel(): Prisma.BanditModelDelegate<ExtArgs>;

  /**
   * `prisma.userTypeEstimate`: Exposes CRUD operations for the **UserTypeEstimate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTypeEstimates
    * const userTypeEstimates = await prisma.userTypeEstimate.findMany()
    * ```
    */
  get userTypeEstimate(): Prisma.UserTypeEstimateDelegate<ExtArgs>;

  /**
   * `prisma.typeStats`: Exposes CRUD operations for the **TypeStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypeStats
    * const typeStats = await prisma.typeStats.findMany()
    * ```
    */
  get typeStats(): Prisma.TypeStatsDelegate<ExtArgs>;

  /**
   * `prisma.hookCandidate`: Exposes CRUD operations for the **HookCandidate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HookCandidates
    * const hookCandidates = await prisma.hookCandidate.findMany()
    * ```
    */
  get hookCandidate(): Prisma.HookCandidateDelegate<ExtArgs>;

  /**
   * `prisma.tiktokPost`: Exposes CRUD operations for the **TiktokPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TiktokPosts
    * const tiktokPosts = await prisma.tiktokPost.findMany()
    * ```
    */
  get tiktokPost(): Prisma.TiktokPostDelegate<ExtArgs>;

  /**
   * `prisma.wisdomPattern`: Exposes CRUD operations for the **WisdomPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WisdomPatterns
    * const wisdomPatterns = await prisma.wisdomPattern.findMany()
    * ```
    */
  get wisdomPattern(): Prisma.WisdomPatternDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Token: 'Token',
    RefreshToken: 'RefreshToken',
    MobileProfile: 'MobileProfile',
    UserSubscription: 'UserSubscription',
    SubscriptionEvent: 'SubscriptionEvent',
    MonthlyVcGrant: 'MonthlyVcGrant',
    Profile: 'Profile',
    UserSetting: 'UserSetting',
    UserTrait: 'UserTrait',
    DailyMetric: 'DailyMetric',
    NudgeEvent: 'NudgeEvent',
    NudgeOutcome: 'NudgeOutcome',
    FeelingSession: 'FeelingSession',
    BanditModel: 'BanditModel',
    UserTypeEstimate: 'UserTypeEstimate',
    TypeStats: 'TypeStats',
    HookCandidate: 'HookCandidate',
    TiktokPost: 'TiktokPost',
    WisdomPattern: 'WisdomPattern'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "token" | "refreshToken" | "mobileProfile" | "userSubscription" | "subscriptionEvent" | "monthlyVcGrant" | "profile" | "userSetting" | "userTrait" | "dailyMetric" | "nudgeEvent" | "nudgeOutcome" | "feelingSession" | "banditModel" | "userTypeEstimate" | "typeStats" | "hookCandidate" | "tiktokPost" | "wisdomPattern"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      MobileProfile: {
        payload: Prisma.$MobileProfilePayload<ExtArgs>
        fields: Prisma.MobileProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobileProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobileProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>
          }
          findFirst: {
            args: Prisma.MobileProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobileProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>
          }
          findMany: {
            args: Prisma.MobileProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>[]
          }
          create: {
            args: Prisma.MobileProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>
          }
          createMany: {
            args: Prisma.MobileProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MobileProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>[]
          }
          delete: {
            args: Prisma.MobileProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>
          }
          update: {
            args: Prisma.MobileProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>
          }
          deleteMany: {
            args: Prisma.MobileProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MobileProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MobileProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileProfilePayload>
          }
          aggregate: {
            args: Prisma.MobileProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMobileProfile>
          }
          groupBy: {
            args: Prisma.MobileProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MobileProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobileProfileCountArgs<ExtArgs>
            result: $Utils.Optional<MobileProfileCountAggregateOutputType> | number
          }
        }
      }
      UserSubscription: {
        payload: Prisma.$UserSubscriptionPayload<ExtArgs>
        fields: Prisma.UserSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.UserSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          findMany: {
            args: Prisma.UserSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          create: {
            args: Prisma.UserSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          createMany: {
            args: Prisma.UserSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.UserSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          update: {
            args: Prisma.UserSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.UserSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.UserSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSubscription>
          }
          groupBy: {
            args: Prisma.UserSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionEvent: {
        payload: Prisma.$SubscriptionEventPayload<ExtArgs>
        fields: Prisma.SubscriptionEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          findMany: {
            args: Prisma.SubscriptionEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>[]
          }
          create: {
            args: Prisma.SubscriptionEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          createMany: {
            args: Prisma.SubscriptionEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          update: {
            args: Prisma.SubscriptionEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionEvent>
          }
          groupBy: {
            args: Prisma.SubscriptionEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionEventCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionEventCountAggregateOutputType> | number
          }
        }
      }
      MonthlyVcGrant: {
        payload: Prisma.$MonthlyVcGrantPayload<ExtArgs>
        fields: Prisma.MonthlyVcGrantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthlyVcGrantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthlyVcGrantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>
          }
          findFirst: {
            args: Prisma.MonthlyVcGrantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthlyVcGrantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>
          }
          findMany: {
            args: Prisma.MonthlyVcGrantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>[]
          }
          create: {
            args: Prisma.MonthlyVcGrantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>
          }
          createMany: {
            args: Prisma.MonthlyVcGrantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthlyVcGrantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>[]
          }
          delete: {
            args: Prisma.MonthlyVcGrantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>
          }
          update: {
            args: Prisma.MonthlyVcGrantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>
          }
          deleteMany: {
            args: Prisma.MonthlyVcGrantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthlyVcGrantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonthlyVcGrantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyVcGrantPayload>
          }
          aggregate: {
            args: Prisma.MonthlyVcGrantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthlyVcGrant>
          }
          groupBy: {
            args: Prisma.MonthlyVcGrantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthlyVcGrantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthlyVcGrantCountArgs<ExtArgs>
            result: $Utils.Optional<MonthlyVcGrantCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      UserSetting: {
        payload: Prisma.$UserSettingPayload<ExtArgs>
        fields: Prisma.UserSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findFirst: {
            args: Prisma.UserSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          findMany: {
            args: Prisma.UserSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          create: {
            args: Prisma.UserSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          createMany: {
            args: Prisma.UserSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>[]
          }
          delete: {
            args: Prisma.UserSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          update: {
            args: Prisma.UserSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingPayload>
          }
          aggregate: {
            args: Prisma.UserSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSetting>
          }
          groupBy: {
            args: Prisma.UserSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingCountAggregateOutputType> | number
          }
        }
      }
      UserTrait: {
        payload: Prisma.$UserTraitPayload<ExtArgs>
        fields: Prisma.UserTraitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTraitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTraitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>
          }
          findFirst: {
            args: Prisma.UserTraitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTraitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>
          }
          findMany: {
            args: Prisma.UserTraitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>[]
          }
          create: {
            args: Prisma.UserTraitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>
          }
          createMany: {
            args: Prisma.UserTraitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTraitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>[]
          }
          delete: {
            args: Prisma.UserTraitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>
          }
          update: {
            args: Prisma.UserTraitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>
          }
          deleteMany: {
            args: Prisma.UserTraitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTraitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTraitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTraitPayload>
          }
          aggregate: {
            args: Prisma.UserTraitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTrait>
          }
          groupBy: {
            args: Prisma.UserTraitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTraitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTraitCountArgs<ExtArgs>
            result: $Utils.Optional<UserTraitCountAggregateOutputType> | number
          }
        }
      }
      DailyMetric: {
        payload: Prisma.$DailyMetricPayload<ExtArgs>
        fields: Prisma.DailyMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          findFirst: {
            args: Prisma.DailyMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          findMany: {
            args: Prisma.DailyMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>[]
          }
          create: {
            args: Prisma.DailyMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          createMany: {
            args: Prisma.DailyMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>[]
          }
          delete: {
            args: Prisma.DailyMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          update: {
            args: Prisma.DailyMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          deleteMany: {
            args: Prisma.DailyMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyMetricPayload>
          }
          aggregate: {
            args: Prisma.DailyMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyMetric>
          }
          groupBy: {
            args: Prisma.DailyMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyMetricCountArgs<ExtArgs>
            result: $Utils.Optional<DailyMetricCountAggregateOutputType> | number
          }
        }
      }
      NudgeEvent: {
        payload: Prisma.$NudgeEventPayload<ExtArgs>
        fields: Prisma.NudgeEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NudgeEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NudgeEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>
          }
          findFirst: {
            args: Prisma.NudgeEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NudgeEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>
          }
          findMany: {
            args: Prisma.NudgeEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>[]
          }
          create: {
            args: Prisma.NudgeEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>
          }
          createMany: {
            args: Prisma.NudgeEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NudgeEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>[]
          }
          delete: {
            args: Prisma.NudgeEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>
          }
          update: {
            args: Prisma.NudgeEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>
          }
          deleteMany: {
            args: Prisma.NudgeEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NudgeEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NudgeEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeEventPayload>
          }
          aggregate: {
            args: Prisma.NudgeEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNudgeEvent>
          }
          groupBy: {
            args: Prisma.NudgeEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<NudgeEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.NudgeEventCountArgs<ExtArgs>
            result: $Utils.Optional<NudgeEventCountAggregateOutputType> | number
          }
        }
      }
      NudgeOutcome: {
        payload: Prisma.$NudgeOutcomePayload<ExtArgs>
        fields: Prisma.NudgeOutcomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NudgeOutcomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NudgeOutcomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>
          }
          findFirst: {
            args: Prisma.NudgeOutcomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NudgeOutcomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>
          }
          findMany: {
            args: Prisma.NudgeOutcomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>[]
          }
          create: {
            args: Prisma.NudgeOutcomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>
          }
          createMany: {
            args: Prisma.NudgeOutcomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NudgeOutcomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>[]
          }
          delete: {
            args: Prisma.NudgeOutcomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>
          }
          update: {
            args: Prisma.NudgeOutcomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>
          }
          deleteMany: {
            args: Prisma.NudgeOutcomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NudgeOutcomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NudgeOutcomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NudgeOutcomePayload>
          }
          aggregate: {
            args: Prisma.NudgeOutcomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNudgeOutcome>
          }
          groupBy: {
            args: Prisma.NudgeOutcomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NudgeOutcomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NudgeOutcomeCountArgs<ExtArgs>
            result: $Utils.Optional<NudgeOutcomeCountAggregateOutputType> | number
          }
        }
      }
      FeelingSession: {
        payload: Prisma.$FeelingSessionPayload<ExtArgs>
        fields: Prisma.FeelingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeelingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeelingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>
          }
          findFirst: {
            args: Prisma.FeelingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeelingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>
          }
          findMany: {
            args: Prisma.FeelingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>[]
          }
          create: {
            args: Prisma.FeelingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>
          }
          createMany: {
            args: Prisma.FeelingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeelingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>[]
          }
          delete: {
            args: Prisma.FeelingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>
          }
          update: {
            args: Prisma.FeelingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>
          }
          deleteMany: {
            args: Prisma.FeelingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeelingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeelingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeelingSessionPayload>
          }
          aggregate: {
            args: Prisma.FeelingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeelingSession>
          }
          groupBy: {
            args: Prisma.FeelingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeelingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeelingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<FeelingSessionCountAggregateOutputType> | number
          }
        }
      }
      BanditModel: {
        payload: Prisma.$BanditModelPayload<ExtArgs>
        fields: Prisma.BanditModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BanditModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BanditModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>
          }
          findFirst: {
            args: Prisma.BanditModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BanditModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>
          }
          findMany: {
            args: Prisma.BanditModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>[]
          }
          create: {
            args: Prisma.BanditModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>
          }
          createMany: {
            args: Prisma.BanditModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BanditModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>[]
          }
          delete: {
            args: Prisma.BanditModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>
          }
          update: {
            args: Prisma.BanditModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>
          }
          deleteMany: {
            args: Prisma.BanditModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BanditModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BanditModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BanditModelPayload>
          }
          aggregate: {
            args: Prisma.BanditModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBanditModel>
          }
          groupBy: {
            args: Prisma.BanditModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<BanditModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.BanditModelCountArgs<ExtArgs>
            result: $Utils.Optional<BanditModelCountAggregateOutputType> | number
          }
        }
      }
      UserTypeEstimate: {
        payload: Prisma.$UserTypeEstimatePayload<ExtArgs>
        fields: Prisma.UserTypeEstimateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTypeEstimateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTypeEstimateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>
          }
          findFirst: {
            args: Prisma.UserTypeEstimateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTypeEstimateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>
          }
          findMany: {
            args: Prisma.UserTypeEstimateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>[]
          }
          create: {
            args: Prisma.UserTypeEstimateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>
          }
          createMany: {
            args: Prisma.UserTypeEstimateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserTypeEstimateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>[]
          }
          delete: {
            args: Prisma.UserTypeEstimateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>
          }
          update: {
            args: Prisma.UserTypeEstimateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>
          }
          deleteMany: {
            args: Prisma.UserTypeEstimateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTypeEstimateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTypeEstimateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTypeEstimatePayload>
          }
          aggregate: {
            args: Prisma.UserTypeEstimateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTypeEstimate>
          }
          groupBy: {
            args: Prisma.UserTypeEstimateGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTypeEstimateGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTypeEstimateCountArgs<ExtArgs>
            result: $Utils.Optional<UserTypeEstimateCountAggregateOutputType> | number
          }
        }
      }
      TypeStats: {
        payload: Prisma.$TypeStatsPayload<ExtArgs>
        fields: Prisma.TypeStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypeStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypeStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>
          }
          findFirst: {
            args: Prisma.TypeStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypeStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>
          }
          findMany: {
            args: Prisma.TypeStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>[]
          }
          create: {
            args: Prisma.TypeStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>
          }
          createMany: {
            args: Prisma.TypeStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TypeStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>[]
          }
          delete: {
            args: Prisma.TypeStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>
          }
          update: {
            args: Prisma.TypeStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>
          }
          deleteMany: {
            args: Prisma.TypeStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TypeStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TypeStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TypeStatsPayload>
          }
          aggregate: {
            args: Prisma.TypeStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTypeStats>
          }
          groupBy: {
            args: Prisma.TypeStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TypeStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypeStatsCountArgs<ExtArgs>
            result: $Utils.Optional<TypeStatsCountAggregateOutputType> | number
          }
        }
      }
      HookCandidate: {
        payload: Prisma.$HookCandidatePayload<ExtArgs>
        fields: Prisma.HookCandidateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HookCandidateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HookCandidateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>
          }
          findFirst: {
            args: Prisma.HookCandidateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HookCandidateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>
          }
          findMany: {
            args: Prisma.HookCandidateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>[]
          }
          create: {
            args: Prisma.HookCandidateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>
          }
          createMany: {
            args: Prisma.HookCandidateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HookCandidateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>[]
          }
          delete: {
            args: Prisma.HookCandidateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>
          }
          update: {
            args: Prisma.HookCandidateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>
          }
          deleteMany: {
            args: Prisma.HookCandidateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HookCandidateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HookCandidateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HookCandidatePayload>
          }
          aggregate: {
            args: Prisma.HookCandidateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHookCandidate>
          }
          groupBy: {
            args: Prisma.HookCandidateGroupByArgs<ExtArgs>
            result: $Utils.Optional<HookCandidateGroupByOutputType>[]
          }
          count: {
            args: Prisma.HookCandidateCountArgs<ExtArgs>
            result: $Utils.Optional<HookCandidateCountAggregateOutputType> | number
          }
        }
      }
      TiktokPost: {
        payload: Prisma.$TiktokPostPayload<ExtArgs>
        fields: Prisma.TiktokPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TiktokPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TiktokPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>
          }
          findFirst: {
            args: Prisma.TiktokPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TiktokPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>
          }
          findMany: {
            args: Prisma.TiktokPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>[]
          }
          create: {
            args: Prisma.TiktokPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>
          }
          createMany: {
            args: Prisma.TiktokPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TiktokPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>[]
          }
          delete: {
            args: Prisma.TiktokPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>
          }
          update: {
            args: Prisma.TiktokPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>
          }
          deleteMany: {
            args: Prisma.TiktokPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TiktokPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TiktokPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiktokPostPayload>
          }
          aggregate: {
            args: Prisma.TiktokPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTiktokPost>
          }
          groupBy: {
            args: Prisma.TiktokPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<TiktokPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.TiktokPostCountArgs<ExtArgs>
            result: $Utils.Optional<TiktokPostCountAggregateOutputType> | number
          }
        }
      }
      WisdomPattern: {
        payload: Prisma.$WisdomPatternPayload<ExtArgs>
        fields: Prisma.WisdomPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WisdomPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WisdomPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>
          }
          findFirst: {
            args: Prisma.WisdomPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WisdomPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>
          }
          findMany: {
            args: Prisma.WisdomPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>[]
          }
          create: {
            args: Prisma.WisdomPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>
          }
          createMany: {
            args: Prisma.WisdomPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WisdomPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>[]
          }
          delete: {
            args: Prisma.WisdomPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>
          }
          update: {
            args: Prisma.WisdomPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>
          }
          deleteMany: {
            args: Prisma.WisdomPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WisdomPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WisdomPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WisdomPatternPayload>
          }
          aggregate: {
            args: Prisma.WisdomPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWisdomPattern>
          }
          groupBy: {
            args: Prisma.WisdomPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<WisdomPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.WisdomPatternCountArgs<ExtArgs>
            result: $Utils.Optional<WisdomPatternCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type NudgeEventCountOutputType
   */

  export type NudgeEventCountOutputType = {
    outcomes: number
  }

  export type NudgeEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outcomes?: boolean | NudgeEventCountOutputTypeCountOutcomesArgs
  }

  // Custom InputTypes
  /**
   * NudgeEventCountOutputType without action
   */
  export type NudgeEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEventCountOutputType
     */
    select?: NudgeEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NudgeEventCountOutputType without action
   */
  export type NudgeEventCountOutputTypeCountOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NudgeOutcomeWhereInput
  }


  /**
   * Count Type HookCandidateCountOutputType
   */

  export type HookCandidateCountOutputType = {
    tiktokPosts: number
  }

  export type HookCandidateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tiktokPosts?: boolean | HookCandidateCountOutputTypeCountTiktokPostsArgs
  }

  // Custom InputTypes
  /**
   * HookCandidateCountOutputType without action
   */
  export type HookCandidateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidateCountOutputType
     */
    select?: HookCandidateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HookCandidateCountOutputType without action
   */
  export type HookCandidateCountOutputTypeCountTiktokPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiktokPostWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    userId: string | null
    provider: string | null
    providerSub: string | null
    email: string | null
    scope: string | null
    expiry: Date | null
    rotationFamilyId: string | null
    revokedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    userId: string | null
    provider: string | null
    providerSub: string | null
    email: string | null
    scope: string | null
    expiry: Date | null
    rotationFamilyId: string | null
    revokedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    userId: number
    provider: number
    providerSub: number
    email: number
    accessTokenEnc: number
    refreshTokenEnc: number
    scope: number
    expiry: number
    rotationFamilyId: number
    revokedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    userId?: true
    provider?: true
    providerSub?: true
    email?: true
    scope?: true
    expiry?: true
    rotationFamilyId?: true
    revokedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenMaxAggregateInputType = {
    userId?: true
    provider?: true
    providerSub?: true
    email?: true
    scope?: true
    expiry?: true
    rotationFamilyId?: true
    revokedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenCountAggregateInputType = {
    userId?: true
    provider?: true
    providerSub?: true
    email?: true
    accessTokenEnc?: true
    refreshTokenEnc?: true
    scope?: true
    expiry?: true
    rotationFamilyId?: true
    revokedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    userId: string
    provider: string
    providerSub: string | null
    email: string | null
    accessTokenEnc: JsonValue
    refreshTokenEnc: JsonValue | null
    scope: string | null
    expiry: Date | null
    rotationFamilyId: string | null
    revokedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provider?: boolean
    providerSub?: boolean
    email?: boolean
    accessTokenEnc?: boolean
    refreshTokenEnc?: boolean
    scope?: boolean
    expiry?: boolean
    rotationFamilyId?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provider?: boolean
    providerSub?: boolean
    email?: boolean
    accessTokenEnc?: boolean
    refreshTokenEnc?: boolean
    scope?: boolean
    expiry?: boolean
    rotationFamilyId?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    userId?: boolean
    provider?: boolean
    providerSub?: boolean
    email?: boolean
    accessTokenEnc?: boolean
    refreshTokenEnc?: boolean
    scope?: boolean
    expiry?: boolean
    rotationFamilyId?: boolean
    revokedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      provider: string
      providerSub: string | null
      email: string | null
      accessTokenEnc: Prisma.JsonValue
      refreshTokenEnc: Prisma.JsonValue | null
      scope: string | null
      expiry: Date | null
      rotationFamilyId: string | null
      revokedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const tokenWithUserIdOnly = await prisma.token.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `userId`
     * const tokenWithUserIdOnly = await prisma.token.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly userId: FieldRef<"Token", 'String'>
    readonly provider: FieldRef<"Token", 'String'>
    readonly providerSub: FieldRef<"Token", 'String'>
    readonly email: FieldRef<"Token", 'String'>
    readonly accessTokenEnc: FieldRef<"Token", 'Json'>
    readonly refreshTokenEnc: FieldRef<"Token", 'Json'>
    readonly scope: FieldRef<"Token", 'String'>
    readonly expiry: FieldRef<"Token", 'DateTime'>
    readonly rotationFamilyId: FieldRef<"Token", 'String'>
    readonly revokedAt: FieldRef<"Token", 'DateTime'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly updatedAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    deviceId: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
    rotatedFrom: string | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    reuseDetected: boolean | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokenHash: string | null
    deviceId: string | null
    userAgent: string | null
    createdAt: Date | null
    expiresAt: Date | null
    rotatedFrom: string | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    reuseDetected: boolean | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    tokenHash: number
    deviceId: number
    userAgent: number
    createdAt: number
    expiresAt: number
    rotatedFrom: number
    revokedAt: number
    lastUsedAt: number
    reuseDetected: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    deviceId?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    rotatedFrom?: true
    revokedAt?: true
    lastUsedAt?: true
    reuseDetected?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    deviceId?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    rotatedFrom?: true
    revokedAt?: true
    lastUsedAt?: true
    reuseDetected?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    tokenHash?: true
    deviceId?: true
    userAgent?: true
    createdAt?: true
    expiresAt?: true
    rotatedFrom?: true
    revokedAt?: true
    lastUsedAt?: true
    reuseDetected?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    tokenHash: string
    deviceId: string
    userAgent: string | null
    createdAt: Date
    expiresAt: Date
    rotatedFrom: string | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    reuseDetected: boolean
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    deviceId?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    rotatedFrom?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    reuseDetected?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    deviceId?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    rotatedFrom?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    reuseDetected?: boolean
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    tokenHash?: boolean
    deviceId?: boolean
    userAgent?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    rotatedFrom?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    reuseDetected?: boolean
  }


  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokenHash: string
      deviceId: string
      userAgent: string | null
      createdAt: Date
      expiresAt: Date
      rotatedFrom: string | null
      revokedAt: Date | null
      lastUsedAt: Date | null
      reuseDetected: boolean
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly tokenHash: FieldRef<"RefreshToken", 'String'>
    readonly deviceId: FieldRef<"RefreshToken", 'String'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly rotatedFrom: FieldRef<"RefreshToken", 'String'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly lastUsedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly reuseDetected: FieldRef<"RefreshToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
  }


  /**
   * Model MobileProfile
   */

  export type AggregateMobileProfile = {
    _count: MobileProfileCountAggregateOutputType | null
    _min: MobileProfileMinAggregateOutputType | null
    _max: MobileProfileMaxAggregateOutputType | null
  }

  export type MobileProfileMinAggregateOutputType = {
    deviceId: string | null
    userId: string | null
    language: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MobileProfileMaxAggregateOutputType = {
    deviceId: string | null
    userId: string | null
    language: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type MobileProfileCountAggregateOutputType = {
    deviceId: number
    userId: number
    profile: number
    language: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type MobileProfileMinAggregateInputType = {
    deviceId?: true
    userId?: true
    language?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MobileProfileMaxAggregateInputType = {
    deviceId?: true
    userId?: true
    language?: true
    updatedAt?: true
    createdAt?: true
  }

  export type MobileProfileCountAggregateInputType = {
    deviceId?: true
    userId?: true
    profile?: true
    language?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type MobileProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileProfile to aggregate.
     */
    where?: MobileProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileProfiles to fetch.
     */
    orderBy?: MobileProfileOrderByWithRelationInput | MobileProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobileProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobileProfiles
    **/
    _count?: true | MobileProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobileProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobileProfileMaxAggregateInputType
  }

  export type GetMobileProfileAggregateType<T extends MobileProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateMobileProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobileProfile[P]>
      : GetScalarType<T[P], AggregateMobileProfile[P]>
  }




  export type MobileProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobileProfileWhereInput
    orderBy?: MobileProfileOrderByWithAggregationInput | MobileProfileOrderByWithAggregationInput[]
    by: MobileProfileScalarFieldEnum[] | MobileProfileScalarFieldEnum
    having?: MobileProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobileProfileCountAggregateInputType | true
    _min?: MobileProfileMinAggregateInputType
    _max?: MobileProfileMaxAggregateInputType
  }

  export type MobileProfileGroupByOutputType = {
    deviceId: string
    userId: string
    profile: JsonValue
    language: string
    updatedAt: Date | null
    createdAt: Date | null
    _count: MobileProfileCountAggregateOutputType | null
    _min: MobileProfileMinAggregateOutputType | null
    _max: MobileProfileMaxAggregateOutputType | null
  }

  type GetMobileProfileGroupByPayload<T extends MobileProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobileProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobileProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobileProfileGroupByOutputType[P]>
            : GetScalarType<T[P], MobileProfileGroupByOutputType[P]>
        }
      >
    >


  export type MobileProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    deviceId?: boolean
    userId?: boolean
    profile?: boolean
    language?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mobileProfile"]>

  export type MobileProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    deviceId?: boolean
    userId?: boolean
    profile?: boolean
    language?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["mobileProfile"]>

  export type MobileProfileSelectScalar = {
    deviceId?: boolean
    userId?: boolean
    profile?: boolean
    language?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }


  export type $MobileProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobileProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      deviceId: string
      userId: string
      profile: Prisma.JsonValue
      language: string
      updatedAt: Date | null
      createdAt: Date | null
    }, ExtArgs["result"]["mobileProfile"]>
    composites: {}
  }

  type MobileProfileGetPayload<S extends boolean | null | undefined | MobileProfileDefaultArgs> = $Result.GetResult<Prisma.$MobileProfilePayload, S>

  type MobileProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MobileProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MobileProfileCountAggregateInputType | true
    }

  export interface MobileProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobileProfile'], meta: { name: 'MobileProfile' } }
    /**
     * Find zero or one MobileProfile that matches the filter.
     * @param {MobileProfileFindUniqueArgs} args - Arguments to find a MobileProfile
     * @example
     * // Get one MobileProfile
     * const mobileProfile = await prisma.mobileProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MobileProfileFindUniqueArgs>(args: SelectSubset<T, MobileProfileFindUniqueArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MobileProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MobileProfileFindUniqueOrThrowArgs} args - Arguments to find a MobileProfile
     * @example
     * // Get one MobileProfile
     * const mobileProfile = await prisma.mobileProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MobileProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, MobileProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MobileProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileFindFirstArgs} args - Arguments to find a MobileProfile
     * @example
     * // Get one MobileProfile
     * const mobileProfile = await prisma.mobileProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MobileProfileFindFirstArgs>(args?: SelectSubset<T, MobileProfileFindFirstArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MobileProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileFindFirstOrThrowArgs} args - Arguments to find a MobileProfile
     * @example
     * // Get one MobileProfile
     * const mobileProfile = await prisma.mobileProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MobileProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, MobileProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MobileProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobileProfiles
     * const mobileProfiles = await prisma.mobileProfile.findMany()
     * 
     * // Get first 10 MobileProfiles
     * const mobileProfiles = await prisma.mobileProfile.findMany({ take: 10 })
     * 
     * // Only select the `deviceId`
     * const mobileProfileWithDeviceIdOnly = await prisma.mobileProfile.findMany({ select: { deviceId: true } })
     * 
     */
    findMany<T extends MobileProfileFindManyArgs>(args?: SelectSubset<T, MobileProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MobileProfile.
     * @param {MobileProfileCreateArgs} args - Arguments to create a MobileProfile.
     * @example
     * // Create one MobileProfile
     * const MobileProfile = await prisma.mobileProfile.create({
     *   data: {
     *     // ... data to create a MobileProfile
     *   }
     * })
     * 
     */
    create<T extends MobileProfileCreateArgs>(args: SelectSubset<T, MobileProfileCreateArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MobileProfiles.
     * @param {MobileProfileCreateManyArgs} args - Arguments to create many MobileProfiles.
     * @example
     * // Create many MobileProfiles
     * const mobileProfile = await prisma.mobileProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MobileProfileCreateManyArgs>(args?: SelectSubset<T, MobileProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MobileProfiles and returns the data saved in the database.
     * @param {MobileProfileCreateManyAndReturnArgs} args - Arguments to create many MobileProfiles.
     * @example
     * // Create many MobileProfiles
     * const mobileProfile = await prisma.mobileProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MobileProfiles and only return the `deviceId`
     * const mobileProfileWithDeviceIdOnly = await prisma.mobileProfile.createManyAndReturn({ 
     *   select: { deviceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MobileProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, MobileProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MobileProfile.
     * @param {MobileProfileDeleteArgs} args - Arguments to delete one MobileProfile.
     * @example
     * // Delete one MobileProfile
     * const MobileProfile = await prisma.mobileProfile.delete({
     *   where: {
     *     // ... filter to delete one MobileProfile
     *   }
     * })
     * 
     */
    delete<T extends MobileProfileDeleteArgs>(args: SelectSubset<T, MobileProfileDeleteArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MobileProfile.
     * @param {MobileProfileUpdateArgs} args - Arguments to update one MobileProfile.
     * @example
     * // Update one MobileProfile
     * const mobileProfile = await prisma.mobileProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MobileProfileUpdateArgs>(args: SelectSubset<T, MobileProfileUpdateArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MobileProfiles.
     * @param {MobileProfileDeleteManyArgs} args - Arguments to filter MobileProfiles to delete.
     * @example
     * // Delete a few MobileProfiles
     * const { count } = await prisma.mobileProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MobileProfileDeleteManyArgs>(args?: SelectSubset<T, MobileProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobileProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobileProfiles
     * const mobileProfile = await prisma.mobileProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MobileProfileUpdateManyArgs>(args: SelectSubset<T, MobileProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MobileProfile.
     * @param {MobileProfileUpsertArgs} args - Arguments to update or create a MobileProfile.
     * @example
     * // Update or create a MobileProfile
     * const mobileProfile = await prisma.mobileProfile.upsert({
     *   create: {
     *     // ... data to create a MobileProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobileProfile we want to update
     *   }
     * })
     */
    upsert<T extends MobileProfileUpsertArgs>(args: SelectSubset<T, MobileProfileUpsertArgs<ExtArgs>>): Prisma__MobileProfileClient<$Result.GetResult<Prisma.$MobileProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MobileProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileCountArgs} args - Arguments to filter MobileProfiles to count.
     * @example
     * // Count the number of MobileProfiles
     * const count = await prisma.mobileProfile.count({
     *   where: {
     *     // ... the filter for the MobileProfiles we want to count
     *   }
     * })
    **/
    count<T extends MobileProfileCountArgs>(
      args?: Subset<T, MobileProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobileProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobileProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobileProfileAggregateArgs>(args: Subset<T, MobileProfileAggregateArgs>): Prisma.PrismaPromise<GetMobileProfileAggregateType<T>>

    /**
     * Group by MobileProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobileProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobileProfileGroupByArgs['orderBy'] }
        : { orderBy?: MobileProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobileProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobileProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobileProfile model
   */
  readonly fields: MobileProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobileProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobileProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MobileProfile model
   */ 
  interface MobileProfileFieldRefs {
    readonly deviceId: FieldRef<"MobileProfile", 'String'>
    readonly userId: FieldRef<"MobileProfile", 'String'>
    readonly profile: FieldRef<"MobileProfile", 'Json'>
    readonly language: FieldRef<"MobileProfile", 'String'>
    readonly updatedAt: FieldRef<"MobileProfile", 'DateTime'>
    readonly createdAt: FieldRef<"MobileProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MobileProfile findUnique
   */
  export type MobileProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * Filter, which MobileProfile to fetch.
     */
    where: MobileProfileWhereUniqueInput
  }

  /**
   * MobileProfile findUniqueOrThrow
   */
  export type MobileProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * Filter, which MobileProfile to fetch.
     */
    where: MobileProfileWhereUniqueInput
  }

  /**
   * MobileProfile findFirst
   */
  export type MobileProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * Filter, which MobileProfile to fetch.
     */
    where?: MobileProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileProfiles to fetch.
     */
    orderBy?: MobileProfileOrderByWithRelationInput | MobileProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileProfiles.
     */
    cursor?: MobileProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileProfiles.
     */
    distinct?: MobileProfileScalarFieldEnum | MobileProfileScalarFieldEnum[]
  }

  /**
   * MobileProfile findFirstOrThrow
   */
  export type MobileProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * Filter, which MobileProfile to fetch.
     */
    where?: MobileProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileProfiles to fetch.
     */
    orderBy?: MobileProfileOrderByWithRelationInput | MobileProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileProfiles.
     */
    cursor?: MobileProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileProfiles.
     */
    distinct?: MobileProfileScalarFieldEnum | MobileProfileScalarFieldEnum[]
  }

  /**
   * MobileProfile findMany
   */
  export type MobileProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * Filter, which MobileProfiles to fetch.
     */
    where?: MobileProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileProfiles to fetch.
     */
    orderBy?: MobileProfileOrderByWithRelationInput | MobileProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobileProfiles.
     */
    cursor?: MobileProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MobileProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileProfiles.
     */
    skip?: number
    distinct?: MobileProfileScalarFieldEnum | MobileProfileScalarFieldEnum[]
  }

  /**
   * MobileProfile create
   */
  export type MobileProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a MobileProfile.
     */
    data: XOR<MobileProfileCreateInput, MobileProfileUncheckedCreateInput>
  }

  /**
   * MobileProfile createMany
   */
  export type MobileProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobileProfiles.
     */
    data: MobileProfileCreateManyInput | MobileProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MobileProfile createManyAndReturn
   */
  export type MobileProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MobileProfiles.
     */
    data: MobileProfileCreateManyInput | MobileProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MobileProfile update
   */
  export type MobileProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a MobileProfile.
     */
    data: XOR<MobileProfileUpdateInput, MobileProfileUncheckedUpdateInput>
    /**
     * Choose, which MobileProfile to update.
     */
    where: MobileProfileWhereUniqueInput
  }

  /**
   * MobileProfile updateMany
   */
  export type MobileProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobileProfiles.
     */
    data: XOR<MobileProfileUpdateManyMutationInput, MobileProfileUncheckedUpdateManyInput>
    /**
     * Filter which MobileProfiles to update
     */
    where?: MobileProfileWhereInput
  }

  /**
   * MobileProfile upsert
   */
  export type MobileProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the MobileProfile to update in case it exists.
     */
    where: MobileProfileWhereUniqueInput
    /**
     * In case the MobileProfile found by the `where` argument doesn't exist, create a new MobileProfile with this data.
     */
    create: XOR<MobileProfileCreateInput, MobileProfileUncheckedCreateInput>
    /**
     * In case the MobileProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobileProfileUpdateInput, MobileProfileUncheckedUpdateInput>
  }

  /**
   * MobileProfile delete
   */
  export type MobileProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
    /**
     * Filter which MobileProfile to delete.
     */
    where: MobileProfileWhereUniqueInput
  }

  /**
   * MobileProfile deleteMany
   */
  export type MobileProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileProfiles to delete
     */
    where?: MobileProfileWhereInput
  }

  /**
   * MobileProfile without action
   */
  export type MobileProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileProfile
     */
    select?: MobileProfileSelect<ExtArgs> | null
  }


  /**
   * Model UserSubscription
   */

  export type AggregateUserSubscription = {
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  export type UserSubscriptionMinAggregateOutputType = {
    userId: string | null
    plan: string | null
    status: string | null
    entitlementSource: string | null
    revenuecatEntitlementId: string | null
    revenuecatOriginalTransactionId: string | null
    currentPeriodEnd: Date | null
    trialEnd: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionMaxAggregateOutputType = {
    userId: string | null
    plan: string | null
    status: string | null
    entitlementSource: string | null
    revenuecatEntitlementId: string | null
    revenuecatOriginalTransactionId: string | null
    currentPeriodEnd: Date | null
    trialEnd: Date | null
    updatedAt: Date | null
  }

  export type UserSubscriptionCountAggregateOutputType = {
    userId: number
    plan: number
    status: number
    entitlementSource: number
    revenuecatEntitlementId: number
    revenuecatOriginalTransactionId: number
    entitlementPayload: number
    currentPeriodEnd: number
    trialEnd: number
    metadata: number
    updatedAt: number
    _all: number
  }


  export type UserSubscriptionMinAggregateInputType = {
    userId?: true
    plan?: true
    status?: true
    entitlementSource?: true
    revenuecatEntitlementId?: true
    revenuecatOriginalTransactionId?: true
    currentPeriodEnd?: true
    trialEnd?: true
    updatedAt?: true
  }

  export type UserSubscriptionMaxAggregateInputType = {
    userId?: true
    plan?: true
    status?: true
    entitlementSource?: true
    revenuecatEntitlementId?: true
    revenuecatOriginalTransactionId?: true
    currentPeriodEnd?: true
    trialEnd?: true
    updatedAt?: true
  }

  export type UserSubscriptionCountAggregateInputType = {
    userId?: true
    plan?: true
    status?: true
    entitlementSource?: true
    revenuecatEntitlementId?: true
    revenuecatOriginalTransactionId?: true
    entitlementPayload?: true
    currentPeriodEnd?: true
    trialEnd?: true
    metadata?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscription to aggregate.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSubscriptions
    **/
    _count?: true | UserSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type GetUserSubscriptionAggregateType<T extends UserSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSubscription[P]>
      : GetScalarType<T[P], AggregateUserSubscription[P]>
  }




  export type UserSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSubscriptionWhereInput
    orderBy?: UserSubscriptionOrderByWithAggregationInput | UserSubscriptionOrderByWithAggregationInput[]
    by: UserSubscriptionScalarFieldEnum[] | UserSubscriptionScalarFieldEnum
    having?: UserSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSubscriptionCountAggregateInputType | true
    _min?: UserSubscriptionMinAggregateInputType
    _max?: UserSubscriptionMaxAggregateInputType
  }

  export type UserSubscriptionGroupByOutputType = {
    userId: string
    plan: string
    status: string
    entitlementSource: string
    revenuecatEntitlementId: string | null
    revenuecatOriginalTransactionId: string | null
    entitlementPayload: JsonValue | null
    currentPeriodEnd: Date | null
    trialEnd: Date | null
    metadata: JsonValue
    updatedAt: Date
    _count: UserSubscriptionCountAggregateOutputType | null
    _min: UserSubscriptionMinAggregateOutputType | null
    _max: UserSubscriptionMaxAggregateOutputType | null
  }

  type GetUserSubscriptionGroupByPayload<T extends UserSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type UserSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    plan?: boolean
    status?: boolean
    entitlementSource?: boolean
    revenuecatEntitlementId?: boolean
    revenuecatOriginalTransactionId?: boolean
    entitlementPayload?: boolean
    currentPeriodEnd?: boolean
    trialEnd?: boolean
    metadata?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    plan?: boolean
    status?: boolean
    entitlementSource?: boolean
    revenuecatEntitlementId?: boolean
    revenuecatOriginalTransactionId?: boolean
    entitlementPayload?: boolean
    currentPeriodEnd?: boolean
    trialEnd?: boolean
    metadata?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userSubscription"]>

  export type UserSubscriptionSelectScalar = {
    userId?: boolean
    plan?: boolean
    status?: boolean
    entitlementSource?: boolean
    revenuecatEntitlementId?: boolean
    revenuecatOriginalTransactionId?: boolean
    entitlementPayload?: boolean
    currentPeriodEnd?: boolean
    trialEnd?: boolean
    metadata?: boolean
    updatedAt?: boolean
  }


  export type $UserSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSubscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      plan: string
      status: string
      entitlementSource: string
      revenuecatEntitlementId: string | null
      revenuecatOriginalTransactionId: string | null
      entitlementPayload: Prisma.JsonValue | null
      currentPeriodEnd: Date | null
      trialEnd: Date | null
      metadata: Prisma.JsonValue
      updatedAt: Date
    }, ExtArgs["result"]["userSubscription"]>
    composites: {}
  }

  type UserSubscriptionGetPayload<S extends boolean | null | undefined | UserSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$UserSubscriptionPayload, S>

  type UserSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSubscriptionCountAggregateInputType | true
    }

  export interface UserSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSubscription'], meta: { name: 'UserSubscription' } }
    /**
     * Find zero or one UserSubscription that matches the filter.
     * @param {UserSubscriptionFindUniqueArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSubscriptionFindUniqueArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSubscriptionFindFirstArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindFirstOrThrowArgs} args - Arguments to find a UserSubscription
     * @example
     * // Get one UserSubscription
     * const userSubscription = await prisma.userSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany()
     * 
     * // Get first 10 UserSubscriptions
     * const userSubscriptions = await prisma.userSubscription.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSubscriptionWithUserIdOnly = await prisma.userSubscription.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSubscriptionFindManyArgs>(args?: SelectSubset<T, UserSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSubscription.
     * @param {UserSubscriptionCreateArgs} args - Arguments to create a UserSubscription.
     * @example
     * // Create one UserSubscription
     * const UserSubscription = await prisma.userSubscription.create({
     *   data: {
     *     // ... data to create a UserSubscription
     *   }
     * })
     * 
     */
    create<T extends UserSubscriptionCreateArgs>(args: SelectSubset<T, UserSubscriptionCreateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSubscriptions.
     * @param {UserSubscriptionCreateManyArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSubscriptionCreateManyArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSubscriptions and returns the data saved in the database.
     * @param {UserSubscriptionCreateManyAndReturnArgs} args - Arguments to create many UserSubscriptions.
     * @example
     * // Create many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSubscriptions and only return the `userId`
     * const userSubscriptionWithUserIdOnly = await prisma.userSubscription.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSubscription.
     * @param {UserSubscriptionDeleteArgs} args - Arguments to delete one UserSubscription.
     * @example
     * // Delete one UserSubscription
     * const UserSubscription = await prisma.userSubscription.delete({
     *   where: {
     *     // ... filter to delete one UserSubscription
     *   }
     * })
     * 
     */
    delete<T extends UserSubscriptionDeleteArgs>(args: SelectSubset<T, UserSubscriptionDeleteArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSubscription.
     * @param {UserSubscriptionUpdateArgs} args - Arguments to update one UserSubscription.
     * @example
     * // Update one UserSubscription
     * const userSubscription = await prisma.userSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSubscriptionUpdateArgs>(args: SelectSubset<T, UserSubscriptionUpdateArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSubscriptions.
     * @param {UserSubscriptionDeleteManyArgs} args - Arguments to filter UserSubscriptions to delete.
     * @example
     * // Delete a few UserSubscriptions
     * const { count } = await prisma.userSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSubscriptionDeleteManyArgs>(args?: SelectSubset<T, UserSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSubscriptions
     * const userSubscription = await prisma.userSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSubscriptionUpdateManyArgs>(args: SelectSubset<T, UserSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSubscription.
     * @param {UserSubscriptionUpsertArgs} args - Arguments to update or create a UserSubscription.
     * @example
     * // Update or create a UserSubscription
     * const userSubscription = await prisma.userSubscription.upsert({
     *   create: {
     *     // ... data to create a UserSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSubscription we want to update
     *   }
     * })
     */
    upsert<T extends UserSubscriptionUpsertArgs>(args: SelectSubset<T, UserSubscriptionUpsertArgs<ExtArgs>>): Prisma__UserSubscriptionClient<$Result.GetResult<Prisma.$UserSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionCountArgs} args - Arguments to filter UserSubscriptions to count.
     * @example
     * // Count the number of UserSubscriptions
     * const count = await prisma.userSubscription.count({
     *   where: {
     *     // ... the filter for the UserSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends UserSubscriptionCountArgs>(
      args?: Subset<T, UserSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSubscriptionAggregateArgs>(args: Subset<T, UserSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetUserSubscriptionAggregateType<T>>

    /**
     * Group by UserSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: UserSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSubscription model
   */
  readonly fields: UserSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSubscription model
   */ 
  interface UserSubscriptionFieldRefs {
    readonly userId: FieldRef<"UserSubscription", 'String'>
    readonly plan: FieldRef<"UserSubscription", 'String'>
    readonly status: FieldRef<"UserSubscription", 'String'>
    readonly entitlementSource: FieldRef<"UserSubscription", 'String'>
    readonly revenuecatEntitlementId: FieldRef<"UserSubscription", 'String'>
    readonly revenuecatOriginalTransactionId: FieldRef<"UserSubscription", 'String'>
    readonly entitlementPayload: FieldRef<"UserSubscription", 'Json'>
    readonly currentPeriodEnd: FieldRef<"UserSubscription", 'DateTime'>
    readonly trialEnd: FieldRef<"UserSubscription", 'DateTime'>
    readonly metadata: FieldRef<"UserSubscription", 'Json'>
    readonly updatedAt: FieldRef<"UserSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSubscription findUnique
   */
  export type UserSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findUniqueOrThrow
   */
  export type UserSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription findFirst
   */
  export type UserSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findFirstOrThrow
   */
  export type UserSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which UserSubscription to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSubscriptions.
     */
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription findMany
   */
  export type UserSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Filter, which UserSubscriptions to fetch.
     */
    where?: UserSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSubscriptions to fetch.
     */
    orderBy?: UserSubscriptionOrderByWithRelationInput | UserSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSubscriptions.
     */
    cursor?: UserSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSubscriptions.
     */
    skip?: number
    distinct?: UserSubscriptionScalarFieldEnum | UserSubscriptionScalarFieldEnum[]
  }

  /**
   * UserSubscription create
   */
  export type UserSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * The data needed to create a UserSubscription.
     */
    data: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
  }

  /**
   * UserSubscription createMany
   */
  export type UserSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription createManyAndReturn
   */
  export type UserSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSubscriptions.
     */
    data: UserSubscriptionCreateManyInput | UserSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSubscription update
   */
  export type UserSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * The data needed to update a UserSubscription.
     */
    data: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which UserSubscription to update.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription updateMany
   */
  export type UserSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSubscriptions.
     */
    data: XOR<UserSubscriptionUpdateManyMutationInput, UserSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which UserSubscriptions to update
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription upsert
   */
  export type UserSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * The filter to search for the UserSubscription to update in case it exists.
     */
    where: UserSubscriptionWhereUniqueInput
    /**
     * In case the UserSubscription found by the `where` argument doesn't exist, create a new UserSubscription with this data.
     */
    create: XOR<UserSubscriptionCreateInput, UserSubscriptionUncheckedCreateInput>
    /**
     * In case the UserSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSubscriptionUpdateInput, UserSubscriptionUncheckedUpdateInput>
  }

  /**
   * UserSubscription delete
   */
  export type UserSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
    /**
     * Filter which UserSubscription to delete.
     */
    where: UserSubscriptionWhereUniqueInput
  }

  /**
   * UserSubscription deleteMany
   */
  export type UserSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSubscriptions to delete
     */
    where?: UserSubscriptionWhereInput
  }

  /**
   * UserSubscription without action
   */
  export type UserSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSubscription
     */
    select?: UserSubscriptionSelect<ExtArgs> | null
  }


  /**
   * Model SubscriptionEvent
   */

  export type AggregateSubscriptionEvent = {
    _count: SubscriptionEventCountAggregateOutputType | null
    _min: SubscriptionEventMinAggregateOutputType | null
    _max: SubscriptionEventMaxAggregateOutputType | null
  }

  export type SubscriptionEventMinAggregateOutputType = {
    eventId: string | null
    userId: string | null
    type: string | null
    provider: string | null
    createdAt: Date | null
  }

  export type SubscriptionEventMaxAggregateOutputType = {
    eventId: string | null
    userId: string | null
    type: string | null
    provider: string | null
    createdAt: Date | null
  }

  export type SubscriptionEventCountAggregateOutputType = {
    eventId: number
    userId: number
    type: number
    provider: number
    payload: number
    createdAt: number
    _all: number
  }


  export type SubscriptionEventMinAggregateInputType = {
    eventId?: true
    userId?: true
    type?: true
    provider?: true
    createdAt?: true
  }

  export type SubscriptionEventMaxAggregateInputType = {
    eventId?: true
    userId?: true
    type?: true
    provider?: true
    createdAt?: true
  }

  export type SubscriptionEventCountAggregateInputType = {
    eventId?: true
    userId?: true
    type?: true
    provider?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type SubscriptionEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionEvent to aggregate.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionEvents
    **/
    _count?: true | SubscriptionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionEventMaxAggregateInputType
  }

  export type GetSubscriptionEventAggregateType<T extends SubscriptionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionEvent[P]>
      : GetScalarType<T[P], AggregateSubscriptionEvent[P]>
  }




  export type SubscriptionEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionEventWhereInput
    orderBy?: SubscriptionEventOrderByWithAggregationInput | SubscriptionEventOrderByWithAggregationInput[]
    by: SubscriptionEventScalarFieldEnum[] | SubscriptionEventScalarFieldEnum
    having?: SubscriptionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionEventCountAggregateInputType | true
    _min?: SubscriptionEventMinAggregateInputType
    _max?: SubscriptionEventMaxAggregateInputType
  }

  export type SubscriptionEventGroupByOutputType = {
    eventId: string
    userId: string | null
    type: string
    provider: string
    payload: JsonValue | null
    createdAt: Date
    _count: SubscriptionEventCountAggregateOutputType | null
    _min: SubscriptionEventMinAggregateOutputType | null
    _max: SubscriptionEventMaxAggregateOutputType | null
  }

  type GetSubscriptionEventGroupByPayload<T extends SubscriptionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionEventGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionEventGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    payload?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["subscriptionEvent"]>

  export type SubscriptionEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    payload?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["subscriptionEvent"]>

  export type SubscriptionEventSelectScalar = {
    eventId?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    payload?: boolean
    createdAt?: boolean
  }


  export type $SubscriptionEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      eventId: string
      userId: string | null
      type: string
      provider: string
      payload: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["subscriptionEvent"]>
    composites: {}
  }

  type SubscriptionEventGetPayload<S extends boolean | null | undefined | SubscriptionEventDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionEventPayload, S>

  type SubscriptionEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubscriptionEventCountAggregateInputType | true
    }

  export interface SubscriptionEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionEvent'], meta: { name: 'SubscriptionEvent' } }
    /**
     * Find zero or one SubscriptionEvent that matches the filter.
     * @param {SubscriptionEventFindUniqueArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionEventFindUniqueArgs>(args: SelectSubset<T, SubscriptionEventFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubscriptionEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubscriptionEventFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubscriptionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventFindFirstArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionEventFindFirstArgs>(args?: SelectSubset<T, SubscriptionEventFindFirstArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubscriptionEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventFindFirstOrThrowArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubscriptionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionEvents
     * const subscriptionEvents = await prisma.subscriptionEvent.findMany()
     * 
     * // Get first 10 SubscriptionEvents
     * const subscriptionEvents = await prisma.subscriptionEvent.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const subscriptionEventWithEventIdOnly = await prisma.subscriptionEvent.findMany({ select: { eventId: true } })
     * 
     */
    findMany<T extends SubscriptionEventFindManyArgs>(args?: SelectSubset<T, SubscriptionEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubscriptionEvent.
     * @param {SubscriptionEventCreateArgs} args - Arguments to create a SubscriptionEvent.
     * @example
     * // Create one SubscriptionEvent
     * const SubscriptionEvent = await prisma.subscriptionEvent.create({
     *   data: {
     *     // ... data to create a SubscriptionEvent
     *   }
     * })
     * 
     */
    create<T extends SubscriptionEventCreateArgs>(args: SelectSubset<T, SubscriptionEventCreateArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubscriptionEvents.
     * @param {SubscriptionEventCreateManyArgs} args - Arguments to create many SubscriptionEvents.
     * @example
     * // Create many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionEventCreateManyArgs>(args?: SelectSubset<T, SubscriptionEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionEvents and returns the data saved in the database.
     * @param {SubscriptionEventCreateManyAndReturnArgs} args - Arguments to create many SubscriptionEvents.
     * @example
     * // Create many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionEvents and only return the `eventId`
     * const subscriptionEventWithEventIdOnly = await prisma.subscriptionEvent.createManyAndReturn({ 
     *   select: { eventId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SubscriptionEvent.
     * @param {SubscriptionEventDeleteArgs} args - Arguments to delete one SubscriptionEvent.
     * @example
     * // Delete one SubscriptionEvent
     * const SubscriptionEvent = await prisma.subscriptionEvent.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionEvent
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionEventDeleteArgs>(args: SelectSubset<T, SubscriptionEventDeleteArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubscriptionEvent.
     * @param {SubscriptionEventUpdateArgs} args - Arguments to update one SubscriptionEvent.
     * @example
     * // Update one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionEventUpdateArgs>(args: SelectSubset<T, SubscriptionEventUpdateArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubscriptionEvents.
     * @param {SubscriptionEventDeleteManyArgs} args - Arguments to filter SubscriptionEvents to delete.
     * @example
     * // Delete a few SubscriptionEvents
     * const { count } = await prisma.subscriptionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionEventDeleteManyArgs>(args?: SelectSubset<T, SubscriptionEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionEventUpdateManyArgs>(args: SelectSubset<T, SubscriptionEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubscriptionEvent.
     * @param {SubscriptionEventUpsertArgs} args - Arguments to update or create a SubscriptionEvent.
     * @example
     * // Update or create a SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.upsert({
     *   create: {
     *     // ... data to create a SubscriptionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionEvent we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionEventUpsertArgs>(args: SelectSubset<T, SubscriptionEventUpsertArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubscriptionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventCountArgs} args - Arguments to filter SubscriptionEvents to count.
     * @example
     * // Count the number of SubscriptionEvents
     * const count = await prisma.subscriptionEvent.count({
     *   where: {
     *     // ... the filter for the SubscriptionEvents we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionEventCountArgs>(
      args?: Subset<T, SubscriptionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionEventAggregateArgs>(args: Subset<T, SubscriptionEventAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionEventAggregateType<T>>

    /**
     * Group by SubscriptionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionEventGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionEvent model
   */
  readonly fields: SubscriptionEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionEvent model
   */ 
  interface SubscriptionEventFieldRefs {
    readonly eventId: FieldRef<"SubscriptionEvent", 'String'>
    readonly userId: FieldRef<"SubscriptionEvent", 'String'>
    readonly type: FieldRef<"SubscriptionEvent", 'String'>
    readonly provider: FieldRef<"SubscriptionEvent", 'String'>
    readonly payload: FieldRef<"SubscriptionEvent", 'Json'>
    readonly createdAt: FieldRef<"SubscriptionEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionEvent findUnique
   */
  export type SubscriptionEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent findUniqueOrThrow
   */
  export type SubscriptionEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent findFirst
   */
  export type SubscriptionEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionEvents.
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionEvents.
     */
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * SubscriptionEvent findFirstOrThrow
   */
  export type SubscriptionEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionEvents.
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionEvents.
     */
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * SubscriptionEvent findMany
   */
  export type SubscriptionEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvents to fetch.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionEvents.
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * SubscriptionEvent create
   */
  export type SubscriptionEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionEvent.
     */
    data: XOR<SubscriptionEventCreateInput, SubscriptionEventUncheckedCreateInput>
  }

  /**
   * SubscriptionEvent createMany
   */
  export type SubscriptionEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionEvents.
     */
    data: SubscriptionEventCreateManyInput | SubscriptionEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionEvent createManyAndReturn
   */
  export type SubscriptionEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SubscriptionEvents.
     */
    data: SubscriptionEventCreateManyInput | SubscriptionEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionEvent update
   */
  export type SubscriptionEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionEvent.
     */
    data: XOR<SubscriptionEventUpdateInput, SubscriptionEventUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionEvent to update.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent updateMany
   */
  export type SubscriptionEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionEvents.
     */
    data: XOR<SubscriptionEventUpdateManyMutationInput, SubscriptionEventUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionEvents to update
     */
    where?: SubscriptionEventWhereInput
  }

  /**
   * SubscriptionEvent upsert
   */
  export type SubscriptionEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionEvent to update in case it exists.
     */
    where: SubscriptionEventWhereUniqueInput
    /**
     * In case the SubscriptionEvent found by the `where` argument doesn't exist, create a new SubscriptionEvent with this data.
     */
    create: XOR<SubscriptionEventCreateInput, SubscriptionEventUncheckedCreateInput>
    /**
     * In case the SubscriptionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionEventUpdateInput, SubscriptionEventUncheckedUpdateInput>
  }

  /**
   * SubscriptionEvent delete
   */
  export type SubscriptionEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Filter which SubscriptionEvent to delete.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent deleteMany
   */
  export type SubscriptionEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionEvents to delete
     */
    where?: SubscriptionEventWhereInput
  }

  /**
   * SubscriptionEvent without action
   */
  export type SubscriptionEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
  }


  /**
   * Model MonthlyVcGrant
   */

  export type AggregateMonthlyVcGrant = {
    _count: MonthlyVcGrantCountAggregateOutputType | null
    _avg: MonthlyVcGrantAvgAggregateOutputType | null
    _sum: MonthlyVcGrantSumAggregateOutputType | null
    _min: MonthlyVcGrantMinAggregateOutputType | null
    _max: MonthlyVcGrantMaxAggregateOutputType | null
  }

  export type MonthlyVcGrantAvgAggregateOutputType = {
    minutes: number | null
  }

  export type MonthlyVcGrantSumAggregateOutputType = {
    minutes: number | null
  }

  export type MonthlyVcGrantMinAggregateOutputType = {
    userId: string | null
    grantMonth: Date | null
    reason: string | null
    minutes: number | null
    grantedAt: Date | null
  }

  export type MonthlyVcGrantMaxAggregateOutputType = {
    userId: string | null
    grantMonth: Date | null
    reason: string | null
    minutes: number | null
    grantedAt: Date | null
  }

  export type MonthlyVcGrantCountAggregateOutputType = {
    userId: number
    grantMonth: number
    reason: number
    minutes: number
    grantedAt: number
    _all: number
  }


  export type MonthlyVcGrantAvgAggregateInputType = {
    minutes?: true
  }

  export type MonthlyVcGrantSumAggregateInputType = {
    minutes?: true
  }

  export type MonthlyVcGrantMinAggregateInputType = {
    userId?: true
    grantMonth?: true
    reason?: true
    minutes?: true
    grantedAt?: true
  }

  export type MonthlyVcGrantMaxAggregateInputType = {
    userId?: true
    grantMonth?: true
    reason?: true
    minutes?: true
    grantedAt?: true
  }

  export type MonthlyVcGrantCountAggregateInputType = {
    userId?: true
    grantMonth?: true
    reason?: true
    minutes?: true
    grantedAt?: true
    _all?: true
  }

  export type MonthlyVcGrantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyVcGrant to aggregate.
     */
    where?: MonthlyVcGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyVcGrants to fetch.
     */
    orderBy?: MonthlyVcGrantOrderByWithRelationInput | MonthlyVcGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthlyVcGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyVcGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyVcGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthlyVcGrants
    **/
    _count?: true | MonthlyVcGrantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthlyVcGrantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthlyVcGrantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthlyVcGrantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthlyVcGrantMaxAggregateInputType
  }

  export type GetMonthlyVcGrantAggregateType<T extends MonthlyVcGrantAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthlyVcGrant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthlyVcGrant[P]>
      : GetScalarType<T[P], AggregateMonthlyVcGrant[P]>
  }




  export type MonthlyVcGrantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyVcGrantWhereInput
    orderBy?: MonthlyVcGrantOrderByWithAggregationInput | MonthlyVcGrantOrderByWithAggregationInput[]
    by: MonthlyVcGrantScalarFieldEnum[] | MonthlyVcGrantScalarFieldEnum
    having?: MonthlyVcGrantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthlyVcGrantCountAggregateInputType | true
    _avg?: MonthlyVcGrantAvgAggregateInputType
    _sum?: MonthlyVcGrantSumAggregateInputType
    _min?: MonthlyVcGrantMinAggregateInputType
    _max?: MonthlyVcGrantMaxAggregateInputType
  }

  export type MonthlyVcGrantGroupByOutputType = {
    userId: string
    grantMonth: Date
    reason: string
    minutes: number
    grantedAt: Date
    _count: MonthlyVcGrantCountAggregateOutputType | null
    _avg: MonthlyVcGrantAvgAggregateOutputType | null
    _sum: MonthlyVcGrantSumAggregateOutputType | null
    _min: MonthlyVcGrantMinAggregateOutputType | null
    _max: MonthlyVcGrantMaxAggregateOutputType | null
  }

  type GetMonthlyVcGrantGroupByPayload<T extends MonthlyVcGrantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthlyVcGrantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthlyVcGrantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthlyVcGrantGroupByOutputType[P]>
            : GetScalarType<T[P], MonthlyVcGrantGroupByOutputType[P]>
        }
      >
    >


  export type MonthlyVcGrantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    grantMonth?: boolean
    reason?: boolean
    minutes?: boolean
    grantedAt?: boolean
  }, ExtArgs["result"]["monthlyVcGrant"]>

  export type MonthlyVcGrantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    grantMonth?: boolean
    reason?: boolean
    minutes?: boolean
    grantedAt?: boolean
  }, ExtArgs["result"]["monthlyVcGrant"]>

  export type MonthlyVcGrantSelectScalar = {
    userId?: boolean
    grantMonth?: boolean
    reason?: boolean
    minutes?: boolean
    grantedAt?: boolean
  }


  export type $MonthlyVcGrantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthlyVcGrant"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      grantMonth: Date
      reason: string
      minutes: number
      grantedAt: Date
    }, ExtArgs["result"]["monthlyVcGrant"]>
    composites: {}
  }

  type MonthlyVcGrantGetPayload<S extends boolean | null | undefined | MonthlyVcGrantDefaultArgs> = $Result.GetResult<Prisma.$MonthlyVcGrantPayload, S>

  type MonthlyVcGrantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonthlyVcGrantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonthlyVcGrantCountAggregateInputType | true
    }

  export interface MonthlyVcGrantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthlyVcGrant'], meta: { name: 'MonthlyVcGrant' } }
    /**
     * Find zero or one MonthlyVcGrant that matches the filter.
     * @param {MonthlyVcGrantFindUniqueArgs} args - Arguments to find a MonthlyVcGrant
     * @example
     * // Get one MonthlyVcGrant
     * const monthlyVcGrant = await prisma.monthlyVcGrant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthlyVcGrantFindUniqueArgs>(args: SelectSubset<T, MonthlyVcGrantFindUniqueArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MonthlyVcGrant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonthlyVcGrantFindUniqueOrThrowArgs} args - Arguments to find a MonthlyVcGrant
     * @example
     * // Get one MonthlyVcGrant
     * const monthlyVcGrant = await prisma.monthlyVcGrant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthlyVcGrantFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthlyVcGrantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MonthlyVcGrant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantFindFirstArgs} args - Arguments to find a MonthlyVcGrant
     * @example
     * // Get one MonthlyVcGrant
     * const monthlyVcGrant = await prisma.monthlyVcGrant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthlyVcGrantFindFirstArgs>(args?: SelectSubset<T, MonthlyVcGrantFindFirstArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MonthlyVcGrant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantFindFirstOrThrowArgs} args - Arguments to find a MonthlyVcGrant
     * @example
     * // Get one MonthlyVcGrant
     * const monthlyVcGrant = await prisma.monthlyVcGrant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthlyVcGrantFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthlyVcGrantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MonthlyVcGrants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthlyVcGrants
     * const monthlyVcGrants = await prisma.monthlyVcGrant.findMany()
     * 
     * // Get first 10 MonthlyVcGrants
     * const monthlyVcGrants = await prisma.monthlyVcGrant.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const monthlyVcGrantWithUserIdOnly = await prisma.monthlyVcGrant.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends MonthlyVcGrantFindManyArgs>(args?: SelectSubset<T, MonthlyVcGrantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MonthlyVcGrant.
     * @param {MonthlyVcGrantCreateArgs} args - Arguments to create a MonthlyVcGrant.
     * @example
     * // Create one MonthlyVcGrant
     * const MonthlyVcGrant = await prisma.monthlyVcGrant.create({
     *   data: {
     *     // ... data to create a MonthlyVcGrant
     *   }
     * })
     * 
     */
    create<T extends MonthlyVcGrantCreateArgs>(args: SelectSubset<T, MonthlyVcGrantCreateArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MonthlyVcGrants.
     * @param {MonthlyVcGrantCreateManyArgs} args - Arguments to create many MonthlyVcGrants.
     * @example
     * // Create many MonthlyVcGrants
     * const monthlyVcGrant = await prisma.monthlyVcGrant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthlyVcGrantCreateManyArgs>(args?: SelectSubset<T, MonthlyVcGrantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthlyVcGrants and returns the data saved in the database.
     * @param {MonthlyVcGrantCreateManyAndReturnArgs} args - Arguments to create many MonthlyVcGrants.
     * @example
     * // Create many MonthlyVcGrants
     * const monthlyVcGrant = await prisma.monthlyVcGrant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthlyVcGrants and only return the `userId`
     * const monthlyVcGrantWithUserIdOnly = await prisma.monthlyVcGrant.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthlyVcGrantCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthlyVcGrantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MonthlyVcGrant.
     * @param {MonthlyVcGrantDeleteArgs} args - Arguments to delete one MonthlyVcGrant.
     * @example
     * // Delete one MonthlyVcGrant
     * const MonthlyVcGrant = await prisma.monthlyVcGrant.delete({
     *   where: {
     *     // ... filter to delete one MonthlyVcGrant
     *   }
     * })
     * 
     */
    delete<T extends MonthlyVcGrantDeleteArgs>(args: SelectSubset<T, MonthlyVcGrantDeleteArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MonthlyVcGrant.
     * @param {MonthlyVcGrantUpdateArgs} args - Arguments to update one MonthlyVcGrant.
     * @example
     * // Update one MonthlyVcGrant
     * const monthlyVcGrant = await prisma.monthlyVcGrant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthlyVcGrantUpdateArgs>(args: SelectSubset<T, MonthlyVcGrantUpdateArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MonthlyVcGrants.
     * @param {MonthlyVcGrantDeleteManyArgs} args - Arguments to filter MonthlyVcGrants to delete.
     * @example
     * // Delete a few MonthlyVcGrants
     * const { count } = await prisma.monthlyVcGrant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthlyVcGrantDeleteManyArgs>(args?: SelectSubset<T, MonthlyVcGrantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlyVcGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthlyVcGrants
     * const monthlyVcGrant = await prisma.monthlyVcGrant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthlyVcGrantUpdateManyArgs>(args: SelectSubset<T, MonthlyVcGrantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MonthlyVcGrant.
     * @param {MonthlyVcGrantUpsertArgs} args - Arguments to update or create a MonthlyVcGrant.
     * @example
     * // Update or create a MonthlyVcGrant
     * const monthlyVcGrant = await prisma.monthlyVcGrant.upsert({
     *   create: {
     *     // ... data to create a MonthlyVcGrant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthlyVcGrant we want to update
     *   }
     * })
     */
    upsert<T extends MonthlyVcGrantUpsertArgs>(args: SelectSubset<T, MonthlyVcGrantUpsertArgs<ExtArgs>>): Prisma__MonthlyVcGrantClient<$Result.GetResult<Prisma.$MonthlyVcGrantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MonthlyVcGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantCountArgs} args - Arguments to filter MonthlyVcGrants to count.
     * @example
     * // Count the number of MonthlyVcGrants
     * const count = await prisma.monthlyVcGrant.count({
     *   where: {
     *     // ... the filter for the MonthlyVcGrants we want to count
     *   }
     * })
    **/
    count<T extends MonthlyVcGrantCountArgs>(
      args?: Subset<T, MonthlyVcGrantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthlyVcGrantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthlyVcGrant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthlyVcGrantAggregateArgs>(args: Subset<T, MonthlyVcGrantAggregateArgs>): Prisma.PrismaPromise<GetMonthlyVcGrantAggregateType<T>>

    /**
     * Group by MonthlyVcGrant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyVcGrantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthlyVcGrantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthlyVcGrantGroupByArgs['orderBy'] }
        : { orderBy?: MonthlyVcGrantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthlyVcGrantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthlyVcGrantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthlyVcGrant model
   */
  readonly fields: MonthlyVcGrantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthlyVcGrant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthlyVcGrantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthlyVcGrant model
   */ 
  interface MonthlyVcGrantFieldRefs {
    readonly userId: FieldRef<"MonthlyVcGrant", 'String'>
    readonly grantMonth: FieldRef<"MonthlyVcGrant", 'DateTime'>
    readonly reason: FieldRef<"MonthlyVcGrant", 'String'>
    readonly minutes: FieldRef<"MonthlyVcGrant", 'Int'>
    readonly grantedAt: FieldRef<"MonthlyVcGrant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MonthlyVcGrant findUnique
   */
  export type MonthlyVcGrantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * Filter, which MonthlyVcGrant to fetch.
     */
    where: MonthlyVcGrantWhereUniqueInput
  }

  /**
   * MonthlyVcGrant findUniqueOrThrow
   */
  export type MonthlyVcGrantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * Filter, which MonthlyVcGrant to fetch.
     */
    where: MonthlyVcGrantWhereUniqueInput
  }

  /**
   * MonthlyVcGrant findFirst
   */
  export type MonthlyVcGrantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * Filter, which MonthlyVcGrant to fetch.
     */
    where?: MonthlyVcGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyVcGrants to fetch.
     */
    orderBy?: MonthlyVcGrantOrderByWithRelationInput | MonthlyVcGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyVcGrants.
     */
    cursor?: MonthlyVcGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyVcGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyVcGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyVcGrants.
     */
    distinct?: MonthlyVcGrantScalarFieldEnum | MonthlyVcGrantScalarFieldEnum[]
  }

  /**
   * MonthlyVcGrant findFirstOrThrow
   */
  export type MonthlyVcGrantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * Filter, which MonthlyVcGrant to fetch.
     */
    where?: MonthlyVcGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyVcGrants to fetch.
     */
    orderBy?: MonthlyVcGrantOrderByWithRelationInput | MonthlyVcGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyVcGrants.
     */
    cursor?: MonthlyVcGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyVcGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyVcGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyVcGrants.
     */
    distinct?: MonthlyVcGrantScalarFieldEnum | MonthlyVcGrantScalarFieldEnum[]
  }

  /**
   * MonthlyVcGrant findMany
   */
  export type MonthlyVcGrantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * Filter, which MonthlyVcGrants to fetch.
     */
    where?: MonthlyVcGrantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyVcGrants to fetch.
     */
    orderBy?: MonthlyVcGrantOrderByWithRelationInput | MonthlyVcGrantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthlyVcGrants.
     */
    cursor?: MonthlyVcGrantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyVcGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyVcGrants.
     */
    skip?: number
    distinct?: MonthlyVcGrantScalarFieldEnum | MonthlyVcGrantScalarFieldEnum[]
  }

  /**
   * MonthlyVcGrant create
   */
  export type MonthlyVcGrantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * The data needed to create a MonthlyVcGrant.
     */
    data: XOR<MonthlyVcGrantCreateInput, MonthlyVcGrantUncheckedCreateInput>
  }

  /**
   * MonthlyVcGrant createMany
   */
  export type MonthlyVcGrantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthlyVcGrants.
     */
    data: MonthlyVcGrantCreateManyInput | MonthlyVcGrantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthlyVcGrant createManyAndReturn
   */
  export type MonthlyVcGrantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MonthlyVcGrants.
     */
    data: MonthlyVcGrantCreateManyInput | MonthlyVcGrantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthlyVcGrant update
   */
  export type MonthlyVcGrantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * The data needed to update a MonthlyVcGrant.
     */
    data: XOR<MonthlyVcGrantUpdateInput, MonthlyVcGrantUncheckedUpdateInput>
    /**
     * Choose, which MonthlyVcGrant to update.
     */
    where: MonthlyVcGrantWhereUniqueInput
  }

  /**
   * MonthlyVcGrant updateMany
   */
  export type MonthlyVcGrantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthlyVcGrants.
     */
    data: XOR<MonthlyVcGrantUpdateManyMutationInput, MonthlyVcGrantUncheckedUpdateManyInput>
    /**
     * Filter which MonthlyVcGrants to update
     */
    where?: MonthlyVcGrantWhereInput
  }

  /**
   * MonthlyVcGrant upsert
   */
  export type MonthlyVcGrantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * The filter to search for the MonthlyVcGrant to update in case it exists.
     */
    where: MonthlyVcGrantWhereUniqueInput
    /**
     * In case the MonthlyVcGrant found by the `where` argument doesn't exist, create a new MonthlyVcGrant with this data.
     */
    create: XOR<MonthlyVcGrantCreateInput, MonthlyVcGrantUncheckedCreateInput>
    /**
     * In case the MonthlyVcGrant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthlyVcGrantUpdateInput, MonthlyVcGrantUncheckedUpdateInput>
  }

  /**
   * MonthlyVcGrant delete
   */
  export type MonthlyVcGrantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
    /**
     * Filter which MonthlyVcGrant to delete.
     */
    where: MonthlyVcGrantWhereUniqueInput
  }

  /**
   * MonthlyVcGrant deleteMany
   */
  export type MonthlyVcGrantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyVcGrants to delete
     */
    where?: MonthlyVcGrantWhereInput
  }

  /**
   * MonthlyVcGrant without action
   */
  export type MonthlyVcGrantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyVcGrant
     */
    select?: MonthlyVcGrantSelect<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    email: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    email?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    email: string | null
    metadata: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settings?: boolean | Profile$settingsArgs<ExtArgs>
    userTypeEstimate?: boolean | Profile$userTypeEstimateArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    email?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | Profile$settingsArgs<ExtArgs>
    userTypeEstimate?: boolean | Profile$userTypeEstimateArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      settings: Prisma.$UserSettingPayload<ExtArgs> | null
      userTypeEstimate: Prisma.$UserTypeEstimatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      metadata: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settings<T extends Profile$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$settingsArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    userTypeEstimate<T extends Profile$userTypeEstimateArgs<ExtArgs> = {}>(args?: Subset<T, Profile$userTypeEstimateArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly metadata: FieldRef<"Profile", 'Json'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.settings
   */
  export type Profile$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    where?: UserSettingWhereInput
  }

  /**
   * Profile.userTypeEstimate
   */
  export type Profile$userTypeEstimateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    where?: UserTypeEstimateWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserSetting
   */

  export type AggregateUserSetting = {
    _count: UserSettingCountAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  export type UserSettingMinAggregateOutputType = {
    userId: string | null
    language: string | null
    timezone: string | null
    notificationsEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingMaxAggregateOutputType = {
    userId: string | null
    language: string | null
    timezone: string | null
    notificationsEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingCountAggregateOutputType = {
    userId: number
    language: number
    timezone: number
    notificationsEnabled: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingMinAggregateInputType = {
    userId?: true
    language?: true
    timezone?: true
    notificationsEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingMaxAggregateInputType = {
    userId?: true
    language?: true
    timezone?: true
    notificationsEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingCountAggregateInputType = {
    userId?: true
    language?: true
    timezone?: true
    notificationsEnabled?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSetting to aggregate.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingMaxAggregateInputType
  }

  export type GetUserSettingAggregateType<T extends UserSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSetting[P]>
      : GetScalarType<T[P], AggregateUserSetting[P]>
  }




  export type UserSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingWhereInput
    orderBy?: UserSettingOrderByWithAggregationInput | UserSettingOrderByWithAggregationInput[]
    by: UserSettingScalarFieldEnum[] | UserSettingScalarFieldEnum
    having?: UserSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingCountAggregateInputType | true
    _min?: UserSettingMinAggregateInputType
    _max?: UserSettingMaxAggregateInputType
  }

  export type UserSettingGroupByOutputType = {
    userId: string
    language: string
    timezone: string
    notificationsEnabled: boolean
    preferences: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserSettingCountAggregateOutputType | null
    _min: UserSettingMinAggregateOutputType | null
    _max: UserSettingMaxAggregateOutputType | null
  }

  type GetUserSettingGroupByPayload<T extends UserSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    language?: boolean
    timezone?: boolean
    notificationsEnabled?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    language?: boolean
    timezone?: boolean
    notificationsEnabled?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSetting"]>

  export type UserSettingSelectScalar = {
    userId?: boolean
    language?: boolean
    timezone?: boolean
    notificationsEnabled?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type UserSettingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $UserSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSetting"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      language: string
      timezone: string
      notificationsEnabled: boolean
      preferences: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSetting"]>
    composites: {}
  }

  type UserSettingGetPayload<S extends boolean | null | undefined | UserSettingDefaultArgs> = $Result.GetResult<Prisma.$UserSettingPayload, S>

  type UserSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSettingCountAggregateInputType | true
    }

  export interface UserSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSetting'], meta: { name: 'UserSetting' } }
    /**
     * Find zero or one UserSetting that matches the filter.
     * @param {UserSettingFindUniqueArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingFindUniqueArgs>(args: SelectSubset<T, UserSettingFindUniqueArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSetting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSettingFindUniqueOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingFindFirstArgs>(args?: SelectSubset<T, UserSettingFindFirstArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindFirstOrThrowArgs} args - Arguments to find a UserSetting
     * @example
     * // Get one UserSetting
     * const userSetting = await prisma.userSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSetting.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSetting.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSettingWithUserIdOnly = await prisma.userSetting.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSettingFindManyArgs>(args?: SelectSubset<T, UserSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSetting.
     * @param {UserSettingCreateArgs} args - Arguments to create a UserSetting.
     * @example
     * // Create one UserSetting
     * const UserSetting = await prisma.userSetting.create({
     *   data: {
     *     // ... data to create a UserSetting
     *   }
     * })
     * 
     */
    create<T extends UserSettingCreateArgs>(args: SelectSubset<T, UserSettingCreateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSettings.
     * @param {UserSettingCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingCreateManyArgs>(args?: SelectSubset<T, UserSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSetting = await prisma.userSetting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `userId`
     * const userSettingWithUserIdOnly = await prisma.userSetting.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSetting.
     * @param {UserSettingDeleteArgs} args - Arguments to delete one UserSetting.
     * @example
     * // Delete one UserSetting
     * const UserSetting = await prisma.userSetting.delete({
     *   where: {
     *     // ... filter to delete one UserSetting
     *   }
     * })
     * 
     */
    delete<T extends UserSettingDeleteArgs>(args: SelectSubset<T, UserSettingDeleteArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSetting.
     * @param {UserSettingUpdateArgs} args - Arguments to update one UserSetting.
     * @example
     * // Update one UserSetting
     * const userSetting = await prisma.userSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingUpdateArgs>(args: SelectSubset<T, UserSettingUpdateArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingDeleteManyArgs>(args?: SelectSubset<T, UserSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSetting = await prisma.userSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingUpdateManyArgs>(args: SelectSubset<T, UserSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSetting.
     * @param {UserSettingUpsertArgs} args - Arguments to update or create a UserSetting.
     * @example
     * // Update or create a UserSetting
     * const userSetting = await prisma.userSetting.upsert({
     *   create: {
     *     // ... data to create a UserSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSetting we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingUpsertArgs>(args: SelectSubset<T, UserSettingUpsertArgs<ExtArgs>>): Prisma__UserSettingClient<$Result.GetResult<Prisma.$UserSettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSetting.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingCountArgs>(
      args?: Subset<T, UserSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingAggregateArgs>(args: Subset<T, UserSettingAggregateArgs>): Prisma.PrismaPromise<GetUserSettingAggregateType<T>>

    /**
     * Group by UserSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSetting model
   */
  readonly fields: UserSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSetting model
   */ 
  interface UserSettingFieldRefs {
    readonly userId: FieldRef<"UserSetting", 'String'>
    readonly language: FieldRef<"UserSetting", 'String'>
    readonly timezone: FieldRef<"UserSetting", 'String'>
    readonly notificationsEnabled: FieldRef<"UserSetting", 'Boolean'>
    readonly preferences: FieldRef<"UserSetting", 'Json'>
    readonly createdAt: FieldRef<"UserSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSetting findUnique
   */
  export type UserSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findUniqueOrThrow
   */
  export type UserSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting findFirst
   */
  export type UserSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findFirstOrThrow
   */
  export type UserSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSetting to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting findMany
   */
  export type UserSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingOrderByWithRelationInput | UserSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingScalarFieldEnum | UserSettingScalarFieldEnum[]
  }

  /**
   * UserSetting create
   */
  export type UserSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSetting.
     */
    data: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
  }

  /**
   * UserSetting createMany
   */
  export type UserSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSetting createManyAndReturn
   */
  export type UserSettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingCreateManyInput | UserSettingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSetting update
   */
  export type UserSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSetting.
     */
    data: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
    /**
     * Choose, which UserSetting to update.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting updateMany
   */
  export type UserSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingUpdateManyMutationInput, UserSettingUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingWhereInput
  }

  /**
   * UserSetting upsert
   */
  export type UserSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSetting to update in case it exists.
     */
    where: UserSettingWhereUniqueInput
    /**
     * In case the UserSetting found by the `where` argument doesn't exist, create a new UserSetting with this data.
     */
    create: XOR<UserSettingCreateInput, UserSettingUncheckedCreateInput>
    /**
     * In case the UserSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingUpdateInput, UserSettingUncheckedUpdateInput>
  }

  /**
   * UserSetting delete
   */
  export type UserSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
    /**
     * Filter which UserSetting to delete.
     */
    where: UserSettingWhereUniqueInput
  }

  /**
   * UserSetting deleteMany
   */
  export type UserSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingWhereInput
  }

  /**
   * UserSetting without action
   */
  export type UserSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSetting
     */
    select?: UserSettingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingInclude<ExtArgs> | null
  }


  /**
   * Model UserTrait
   */

  export type AggregateUserTrait = {
    _count: UserTraitCountAggregateOutputType | null
    _min: UserTraitMinAggregateOutputType | null
    _max: UserTraitMaxAggregateOutputType | null
  }

  export type UserTraitMinAggregateOutputType = {
    userId: string | null
    summary: string | null
    nudgeIntensity: string | null
    stickyMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTraitMaxAggregateOutputType = {
    userId: string | null
    summary: string | null
    nudgeIntensity: string | null
    stickyMode: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTraitCountAggregateOutputType = {
    userId: number
    ideals: number
    struggles: number
    big5: number
    keywords: number
    summary: number
    nudgeIntensity: number
    stickyMode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTraitMinAggregateInputType = {
    userId?: true
    summary?: true
    nudgeIntensity?: true
    stickyMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTraitMaxAggregateInputType = {
    userId?: true
    summary?: true
    nudgeIntensity?: true
    stickyMode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTraitCountAggregateInputType = {
    userId?: true
    ideals?: true
    struggles?: true
    big5?: true
    keywords?: true
    summary?: true
    nudgeIntensity?: true
    stickyMode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTraitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTrait to aggregate.
     */
    where?: UserTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTraits to fetch.
     */
    orderBy?: UserTraitOrderByWithRelationInput | UserTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTraits
    **/
    _count?: true | UserTraitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTraitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTraitMaxAggregateInputType
  }

  export type GetUserTraitAggregateType<T extends UserTraitAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTrait]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTrait[P]>
      : GetScalarType<T[P], AggregateUserTrait[P]>
  }




  export type UserTraitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTraitWhereInput
    orderBy?: UserTraitOrderByWithAggregationInput | UserTraitOrderByWithAggregationInput[]
    by: UserTraitScalarFieldEnum[] | UserTraitScalarFieldEnum
    having?: UserTraitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTraitCountAggregateInputType | true
    _min?: UserTraitMinAggregateInputType
    _max?: UserTraitMaxAggregateInputType
  }

  export type UserTraitGroupByOutputType = {
    userId: string
    ideals: string[]
    struggles: string[]
    big5: JsonValue
    keywords: string[]
    summary: string
    nudgeIntensity: string
    stickyMode: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserTraitCountAggregateOutputType | null
    _min: UserTraitMinAggregateOutputType | null
    _max: UserTraitMaxAggregateOutputType | null
  }

  type GetUserTraitGroupByPayload<T extends UserTraitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTraitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTraitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTraitGroupByOutputType[P]>
            : GetScalarType<T[P], UserTraitGroupByOutputType[P]>
        }
      >
    >


  export type UserTraitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    ideals?: boolean
    struggles?: boolean
    big5?: boolean
    keywords?: boolean
    summary?: boolean
    nudgeIntensity?: boolean
    stickyMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userTrait"]>

  export type UserTraitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    ideals?: boolean
    struggles?: boolean
    big5?: boolean
    keywords?: boolean
    summary?: boolean
    nudgeIntensity?: boolean
    stickyMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userTrait"]>

  export type UserTraitSelectScalar = {
    userId?: boolean
    ideals?: boolean
    struggles?: boolean
    big5?: boolean
    keywords?: boolean
    summary?: boolean
    nudgeIntensity?: boolean
    stickyMode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserTraitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTrait"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      ideals: string[]
      struggles: string[]
      big5: Prisma.JsonValue
      keywords: string[]
      summary: string
      nudgeIntensity: string
      stickyMode: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTrait"]>
    composites: {}
  }

  type UserTraitGetPayload<S extends boolean | null | undefined | UserTraitDefaultArgs> = $Result.GetResult<Prisma.$UserTraitPayload, S>

  type UserTraitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTraitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTraitCountAggregateInputType | true
    }

  export interface UserTraitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTrait'], meta: { name: 'UserTrait' } }
    /**
     * Find zero or one UserTrait that matches the filter.
     * @param {UserTraitFindUniqueArgs} args - Arguments to find a UserTrait
     * @example
     * // Get one UserTrait
     * const userTrait = await prisma.userTrait.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTraitFindUniqueArgs>(args: SelectSubset<T, UserTraitFindUniqueArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTrait that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTraitFindUniqueOrThrowArgs} args - Arguments to find a UserTrait
     * @example
     * // Get one UserTrait
     * const userTrait = await prisma.userTrait.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTraitFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTraitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTrait that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitFindFirstArgs} args - Arguments to find a UserTrait
     * @example
     * // Get one UserTrait
     * const userTrait = await prisma.userTrait.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTraitFindFirstArgs>(args?: SelectSubset<T, UserTraitFindFirstArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTrait that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitFindFirstOrThrowArgs} args - Arguments to find a UserTrait
     * @example
     * // Get one UserTrait
     * const userTrait = await prisma.userTrait.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTraitFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTraitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTraits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTraits
     * const userTraits = await prisma.userTrait.findMany()
     * 
     * // Get first 10 UserTraits
     * const userTraits = await prisma.userTrait.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userTraitWithUserIdOnly = await prisma.userTrait.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserTraitFindManyArgs>(args?: SelectSubset<T, UserTraitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTrait.
     * @param {UserTraitCreateArgs} args - Arguments to create a UserTrait.
     * @example
     * // Create one UserTrait
     * const UserTrait = await prisma.userTrait.create({
     *   data: {
     *     // ... data to create a UserTrait
     *   }
     * })
     * 
     */
    create<T extends UserTraitCreateArgs>(args: SelectSubset<T, UserTraitCreateArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTraits.
     * @param {UserTraitCreateManyArgs} args - Arguments to create many UserTraits.
     * @example
     * // Create many UserTraits
     * const userTrait = await prisma.userTrait.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTraitCreateManyArgs>(args?: SelectSubset<T, UserTraitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTraits and returns the data saved in the database.
     * @param {UserTraitCreateManyAndReturnArgs} args - Arguments to create many UserTraits.
     * @example
     * // Create many UserTraits
     * const userTrait = await prisma.userTrait.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTraits and only return the `userId`
     * const userTraitWithUserIdOnly = await prisma.userTrait.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTraitCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTraitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTrait.
     * @param {UserTraitDeleteArgs} args - Arguments to delete one UserTrait.
     * @example
     * // Delete one UserTrait
     * const UserTrait = await prisma.userTrait.delete({
     *   where: {
     *     // ... filter to delete one UserTrait
     *   }
     * })
     * 
     */
    delete<T extends UserTraitDeleteArgs>(args: SelectSubset<T, UserTraitDeleteArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTrait.
     * @param {UserTraitUpdateArgs} args - Arguments to update one UserTrait.
     * @example
     * // Update one UserTrait
     * const userTrait = await prisma.userTrait.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTraitUpdateArgs>(args: SelectSubset<T, UserTraitUpdateArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTraits.
     * @param {UserTraitDeleteManyArgs} args - Arguments to filter UserTraits to delete.
     * @example
     * // Delete a few UserTraits
     * const { count } = await prisma.userTrait.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTraitDeleteManyArgs>(args?: SelectSubset<T, UserTraitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTraits
     * const userTrait = await prisma.userTrait.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTraitUpdateManyArgs>(args: SelectSubset<T, UserTraitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTrait.
     * @param {UserTraitUpsertArgs} args - Arguments to update or create a UserTrait.
     * @example
     * // Update or create a UserTrait
     * const userTrait = await prisma.userTrait.upsert({
     *   create: {
     *     // ... data to create a UserTrait
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTrait we want to update
     *   }
     * })
     */
    upsert<T extends UserTraitUpsertArgs>(args: SelectSubset<T, UserTraitUpsertArgs<ExtArgs>>): Prisma__UserTraitClient<$Result.GetResult<Prisma.$UserTraitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTraits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitCountArgs} args - Arguments to filter UserTraits to count.
     * @example
     * // Count the number of UserTraits
     * const count = await prisma.userTrait.count({
     *   where: {
     *     // ... the filter for the UserTraits we want to count
     *   }
     * })
    **/
    count<T extends UserTraitCountArgs>(
      args?: Subset<T, UserTraitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTraitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTraitAggregateArgs>(args: Subset<T, UserTraitAggregateArgs>): Prisma.PrismaPromise<GetUserTraitAggregateType<T>>

    /**
     * Group by UserTrait.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTraitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTraitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTraitGroupByArgs['orderBy'] }
        : { orderBy?: UserTraitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTraitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTraitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTrait model
   */
  readonly fields: UserTraitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTrait.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTraitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTrait model
   */ 
  interface UserTraitFieldRefs {
    readonly userId: FieldRef<"UserTrait", 'String'>
    readonly ideals: FieldRef<"UserTrait", 'String[]'>
    readonly struggles: FieldRef<"UserTrait", 'String[]'>
    readonly big5: FieldRef<"UserTrait", 'Json'>
    readonly keywords: FieldRef<"UserTrait", 'String[]'>
    readonly summary: FieldRef<"UserTrait", 'String'>
    readonly nudgeIntensity: FieldRef<"UserTrait", 'String'>
    readonly stickyMode: FieldRef<"UserTrait", 'Boolean'>
    readonly createdAt: FieldRef<"UserTrait", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTrait", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTrait findUnique
   */
  export type UserTraitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * Filter, which UserTrait to fetch.
     */
    where: UserTraitWhereUniqueInput
  }

  /**
   * UserTrait findUniqueOrThrow
   */
  export type UserTraitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * Filter, which UserTrait to fetch.
     */
    where: UserTraitWhereUniqueInput
  }

  /**
   * UserTrait findFirst
   */
  export type UserTraitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * Filter, which UserTrait to fetch.
     */
    where?: UserTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTraits to fetch.
     */
    orderBy?: UserTraitOrderByWithRelationInput | UserTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTraits.
     */
    cursor?: UserTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTraits.
     */
    distinct?: UserTraitScalarFieldEnum | UserTraitScalarFieldEnum[]
  }

  /**
   * UserTrait findFirstOrThrow
   */
  export type UserTraitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * Filter, which UserTrait to fetch.
     */
    where?: UserTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTraits to fetch.
     */
    orderBy?: UserTraitOrderByWithRelationInput | UserTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTraits.
     */
    cursor?: UserTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTraits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTraits.
     */
    distinct?: UserTraitScalarFieldEnum | UserTraitScalarFieldEnum[]
  }

  /**
   * UserTrait findMany
   */
  export type UserTraitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * Filter, which UserTraits to fetch.
     */
    where?: UserTraitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTraits to fetch.
     */
    orderBy?: UserTraitOrderByWithRelationInput | UserTraitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTraits.
     */
    cursor?: UserTraitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTraits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTraits.
     */
    skip?: number
    distinct?: UserTraitScalarFieldEnum | UserTraitScalarFieldEnum[]
  }

  /**
   * UserTrait create
   */
  export type UserTraitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * The data needed to create a UserTrait.
     */
    data: XOR<UserTraitCreateInput, UserTraitUncheckedCreateInput>
  }

  /**
   * UserTrait createMany
   */
  export type UserTraitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTraits.
     */
    data: UserTraitCreateManyInput | UserTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTrait createManyAndReturn
   */
  export type UserTraitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTraits.
     */
    data: UserTraitCreateManyInput | UserTraitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTrait update
   */
  export type UserTraitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * The data needed to update a UserTrait.
     */
    data: XOR<UserTraitUpdateInput, UserTraitUncheckedUpdateInput>
    /**
     * Choose, which UserTrait to update.
     */
    where: UserTraitWhereUniqueInput
  }

  /**
   * UserTrait updateMany
   */
  export type UserTraitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTraits.
     */
    data: XOR<UserTraitUpdateManyMutationInput, UserTraitUncheckedUpdateManyInput>
    /**
     * Filter which UserTraits to update
     */
    where?: UserTraitWhereInput
  }

  /**
   * UserTrait upsert
   */
  export type UserTraitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * The filter to search for the UserTrait to update in case it exists.
     */
    where: UserTraitWhereUniqueInput
    /**
     * In case the UserTrait found by the `where` argument doesn't exist, create a new UserTrait with this data.
     */
    create: XOR<UserTraitCreateInput, UserTraitUncheckedCreateInput>
    /**
     * In case the UserTrait was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTraitUpdateInput, UserTraitUncheckedUpdateInput>
  }

  /**
   * UserTrait delete
   */
  export type UserTraitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
    /**
     * Filter which UserTrait to delete.
     */
    where: UserTraitWhereUniqueInput
  }

  /**
   * UserTrait deleteMany
   */
  export type UserTraitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTraits to delete
     */
    where?: UserTraitWhereInput
  }

  /**
   * UserTrait without action
   */
  export type UserTraitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTrait
     */
    select?: UserTraitSelect<ExtArgs> | null
  }


  /**
   * Model DailyMetric
   */

  export type AggregateDailyMetric = {
    _count: DailyMetricCountAggregateOutputType | null
    _avg: DailyMetricAvgAggregateOutputType | null
    _sum: DailyMetricSumAggregateOutputType | null
    _min: DailyMetricMinAggregateOutputType | null
    _max: DailyMetricMaxAggregateOutputType | null
  }

  export type DailyMetricAvgAggregateOutputType = {
    sleepDurationMin: number | null
    snsMinutesTotal: number | null
    snsMinutesNight: number | null
    steps: number | null
    sedentaryMinutes: number | null
  }

  export type DailyMetricSumAggregateOutputType = {
    sleepDurationMin: number | null
    snsMinutesTotal: number | null
    snsMinutesNight: number | null
    steps: number | null
    sedentaryMinutes: number | null
  }

  export type DailyMetricMinAggregateOutputType = {
    userId: string | null
    date: Date | null
    sleepDurationMin: number | null
    sleepStartAt: Date | null
    wakeAt: Date | null
    snsMinutesTotal: number | null
    snsMinutesNight: number | null
    steps: number | null
    sedentaryMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyMetricMaxAggregateOutputType = {
    userId: string | null
    date: Date | null
    sleepDurationMin: number | null
    sleepStartAt: Date | null
    wakeAt: Date | null
    snsMinutesTotal: number | null
    snsMinutesNight: number | null
    steps: number | null
    sedentaryMinutes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DailyMetricCountAggregateOutputType = {
    userId: number
    date: number
    sleepDurationMin: number
    sleepStartAt: number
    wakeAt: number
    snsMinutesTotal: number
    snsMinutesNight: number
    steps: number
    sedentaryMinutes: number
    activitySummary: number
    mindSummary: number
    insights: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DailyMetricAvgAggregateInputType = {
    sleepDurationMin?: true
    snsMinutesTotal?: true
    snsMinutesNight?: true
    steps?: true
    sedentaryMinutes?: true
  }

  export type DailyMetricSumAggregateInputType = {
    sleepDurationMin?: true
    snsMinutesTotal?: true
    snsMinutesNight?: true
    steps?: true
    sedentaryMinutes?: true
  }

  export type DailyMetricMinAggregateInputType = {
    userId?: true
    date?: true
    sleepDurationMin?: true
    sleepStartAt?: true
    wakeAt?: true
    snsMinutesTotal?: true
    snsMinutesNight?: true
    steps?: true
    sedentaryMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyMetricMaxAggregateInputType = {
    userId?: true
    date?: true
    sleepDurationMin?: true
    sleepStartAt?: true
    wakeAt?: true
    snsMinutesTotal?: true
    snsMinutesNight?: true
    steps?: true
    sedentaryMinutes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DailyMetricCountAggregateInputType = {
    userId?: true
    date?: true
    sleepDurationMin?: true
    sleepStartAt?: true
    wakeAt?: true
    snsMinutesTotal?: true
    snsMinutesNight?: true
    steps?: true
    sedentaryMinutes?: true
    activitySummary?: true
    mindSummary?: true
    insights?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DailyMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyMetric to aggregate.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyMetrics
    **/
    _count?: true | DailyMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyMetricMaxAggregateInputType
  }

  export type GetDailyMetricAggregateType<T extends DailyMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyMetric[P]>
      : GetScalarType<T[P], AggregateDailyMetric[P]>
  }




  export type DailyMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyMetricWhereInput
    orderBy?: DailyMetricOrderByWithAggregationInput | DailyMetricOrderByWithAggregationInput[]
    by: DailyMetricScalarFieldEnum[] | DailyMetricScalarFieldEnum
    having?: DailyMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyMetricCountAggregateInputType | true
    _avg?: DailyMetricAvgAggregateInputType
    _sum?: DailyMetricSumAggregateInputType
    _min?: DailyMetricMinAggregateInputType
    _max?: DailyMetricMaxAggregateInputType
  }

  export type DailyMetricGroupByOutputType = {
    userId: string
    date: Date
    sleepDurationMin: number | null
    sleepStartAt: Date | null
    wakeAt: Date | null
    snsMinutesTotal: number
    snsMinutesNight: number
    steps: number
    sedentaryMinutes: number
    activitySummary: JsonValue
    mindSummary: JsonValue
    insights: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: DailyMetricCountAggregateOutputType | null
    _avg: DailyMetricAvgAggregateOutputType | null
    _sum: DailyMetricSumAggregateOutputType | null
    _min: DailyMetricMinAggregateOutputType | null
    _max: DailyMetricMaxAggregateOutputType | null
  }

  type GetDailyMetricGroupByPayload<T extends DailyMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyMetricGroupByOutputType[P]>
            : GetScalarType<T[P], DailyMetricGroupByOutputType[P]>
        }
      >
    >


  export type DailyMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    date?: boolean
    sleepDurationMin?: boolean
    sleepStartAt?: boolean
    wakeAt?: boolean
    snsMinutesTotal?: boolean
    snsMinutesNight?: boolean
    steps?: boolean
    sedentaryMinutes?: boolean
    activitySummary?: boolean
    mindSummary?: boolean
    insights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyMetric"]>

  export type DailyMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    date?: boolean
    sleepDurationMin?: boolean
    sleepStartAt?: boolean
    wakeAt?: boolean
    snsMinutesTotal?: boolean
    snsMinutesNight?: boolean
    steps?: boolean
    sedentaryMinutes?: boolean
    activitySummary?: boolean
    mindSummary?: boolean
    insights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dailyMetric"]>

  export type DailyMetricSelectScalar = {
    userId?: boolean
    date?: boolean
    sleepDurationMin?: boolean
    sleepStartAt?: boolean
    wakeAt?: boolean
    snsMinutesTotal?: boolean
    snsMinutesNight?: boolean
    steps?: boolean
    sedentaryMinutes?: boolean
    activitySummary?: boolean
    mindSummary?: boolean
    insights?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DailyMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      date: Date
      sleepDurationMin: number | null
      sleepStartAt: Date | null
      wakeAt: Date | null
      snsMinutesTotal: number
      snsMinutesNight: number
      steps: number
      sedentaryMinutes: number
      activitySummary: Prisma.JsonValue
      mindSummary: Prisma.JsonValue
      insights: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dailyMetric"]>
    composites: {}
  }

  type DailyMetricGetPayload<S extends boolean | null | undefined | DailyMetricDefaultArgs> = $Result.GetResult<Prisma.$DailyMetricPayload, S>

  type DailyMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyMetricCountAggregateInputType | true
    }

  export interface DailyMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyMetric'], meta: { name: 'DailyMetric' } }
    /**
     * Find zero or one DailyMetric that matches the filter.
     * @param {DailyMetricFindUniqueArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyMetricFindUniqueArgs>(args: SelectSubset<T, DailyMetricFindUniqueArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyMetricFindUniqueOrThrowArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricFindFirstArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyMetricFindFirstArgs>(args?: SelectSubset<T, DailyMetricFindFirstArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricFindFirstOrThrowArgs} args - Arguments to find a DailyMetric
     * @example
     * // Get one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyMetrics
     * const dailyMetrics = await prisma.dailyMetric.findMany()
     * 
     * // Get first 10 DailyMetrics
     * const dailyMetrics = await prisma.dailyMetric.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const dailyMetricWithUserIdOnly = await prisma.dailyMetric.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends DailyMetricFindManyArgs>(args?: SelectSubset<T, DailyMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyMetric.
     * @param {DailyMetricCreateArgs} args - Arguments to create a DailyMetric.
     * @example
     * // Create one DailyMetric
     * const DailyMetric = await prisma.dailyMetric.create({
     *   data: {
     *     // ... data to create a DailyMetric
     *   }
     * })
     * 
     */
    create<T extends DailyMetricCreateArgs>(args: SelectSubset<T, DailyMetricCreateArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyMetrics.
     * @param {DailyMetricCreateManyArgs} args - Arguments to create many DailyMetrics.
     * @example
     * // Create many DailyMetrics
     * const dailyMetric = await prisma.dailyMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyMetricCreateManyArgs>(args?: SelectSubset<T, DailyMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyMetrics and returns the data saved in the database.
     * @param {DailyMetricCreateManyAndReturnArgs} args - Arguments to create many DailyMetrics.
     * @example
     * // Create many DailyMetrics
     * const dailyMetric = await prisma.dailyMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyMetrics and only return the `userId`
     * const dailyMetricWithUserIdOnly = await prisma.dailyMetric.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyMetric.
     * @param {DailyMetricDeleteArgs} args - Arguments to delete one DailyMetric.
     * @example
     * // Delete one DailyMetric
     * const DailyMetric = await prisma.dailyMetric.delete({
     *   where: {
     *     // ... filter to delete one DailyMetric
     *   }
     * })
     * 
     */
    delete<T extends DailyMetricDeleteArgs>(args: SelectSubset<T, DailyMetricDeleteArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyMetric.
     * @param {DailyMetricUpdateArgs} args - Arguments to update one DailyMetric.
     * @example
     * // Update one DailyMetric
     * const dailyMetric = await prisma.dailyMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyMetricUpdateArgs>(args: SelectSubset<T, DailyMetricUpdateArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyMetrics.
     * @param {DailyMetricDeleteManyArgs} args - Arguments to filter DailyMetrics to delete.
     * @example
     * // Delete a few DailyMetrics
     * const { count } = await prisma.dailyMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyMetricDeleteManyArgs>(args?: SelectSubset<T, DailyMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyMetrics
     * const dailyMetric = await prisma.dailyMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyMetricUpdateManyArgs>(args: SelectSubset<T, DailyMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyMetric.
     * @param {DailyMetricUpsertArgs} args - Arguments to update or create a DailyMetric.
     * @example
     * // Update or create a DailyMetric
     * const dailyMetric = await prisma.dailyMetric.upsert({
     *   create: {
     *     // ... data to create a DailyMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyMetric we want to update
     *   }
     * })
     */
    upsert<T extends DailyMetricUpsertArgs>(args: SelectSubset<T, DailyMetricUpsertArgs<ExtArgs>>): Prisma__DailyMetricClient<$Result.GetResult<Prisma.$DailyMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricCountArgs} args - Arguments to filter DailyMetrics to count.
     * @example
     * // Count the number of DailyMetrics
     * const count = await prisma.dailyMetric.count({
     *   where: {
     *     // ... the filter for the DailyMetrics we want to count
     *   }
     * })
    **/
    count<T extends DailyMetricCountArgs>(
      args?: Subset<T, DailyMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyMetricAggregateArgs>(args: Subset<T, DailyMetricAggregateArgs>): Prisma.PrismaPromise<GetDailyMetricAggregateType<T>>

    /**
     * Group by DailyMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyMetricGroupByArgs['orderBy'] }
        : { orderBy?: DailyMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyMetric model
   */
  readonly fields: DailyMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyMetric model
   */ 
  interface DailyMetricFieldRefs {
    readonly userId: FieldRef<"DailyMetric", 'String'>
    readonly date: FieldRef<"DailyMetric", 'DateTime'>
    readonly sleepDurationMin: FieldRef<"DailyMetric", 'Int'>
    readonly sleepStartAt: FieldRef<"DailyMetric", 'DateTime'>
    readonly wakeAt: FieldRef<"DailyMetric", 'DateTime'>
    readonly snsMinutesTotal: FieldRef<"DailyMetric", 'Int'>
    readonly snsMinutesNight: FieldRef<"DailyMetric", 'Int'>
    readonly steps: FieldRef<"DailyMetric", 'Int'>
    readonly sedentaryMinutes: FieldRef<"DailyMetric", 'Int'>
    readonly activitySummary: FieldRef<"DailyMetric", 'Json'>
    readonly mindSummary: FieldRef<"DailyMetric", 'Json'>
    readonly insights: FieldRef<"DailyMetric", 'Json'>
    readonly createdAt: FieldRef<"DailyMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"DailyMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyMetric findUnique
   */
  export type DailyMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric findUniqueOrThrow
   */
  export type DailyMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric findFirst
   */
  export type DailyMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyMetrics.
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyMetrics.
     */
    distinct?: DailyMetricScalarFieldEnum | DailyMetricScalarFieldEnum[]
  }

  /**
   * DailyMetric findFirstOrThrow
   */
  export type DailyMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetric to fetch.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyMetrics.
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyMetrics.
     */
    distinct?: DailyMetricScalarFieldEnum | DailyMetricScalarFieldEnum[]
  }

  /**
   * DailyMetric findMany
   */
  export type DailyMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter, which DailyMetrics to fetch.
     */
    where?: DailyMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyMetrics to fetch.
     */
    orderBy?: DailyMetricOrderByWithRelationInput | DailyMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyMetrics.
     */
    cursor?: DailyMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyMetrics.
     */
    skip?: number
    distinct?: DailyMetricScalarFieldEnum | DailyMetricScalarFieldEnum[]
  }

  /**
   * DailyMetric create
   */
  export type DailyMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a DailyMetric.
     */
    data: XOR<DailyMetricCreateInput, DailyMetricUncheckedCreateInput>
  }

  /**
   * DailyMetric createMany
   */
  export type DailyMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyMetrics.
     */
    data: DailyMetricCreateManyInput | DailyMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyMetric createManyAndReturn
   */
  export type DailyMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyMetrics.
     */
    data: DailyMetricCreateManyInput | DailyMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyMetric update
   */
  export type DailyMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a DailyMetric.
     */
    data: XOR<DailyMetricUpdateInput, DailyMetricUncheckedUpdateInput>
    /**
     * Choose, which DailyMetric to update.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric updateMany
   */
  export type DailyMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyMetrics.
     */
    data: XOR<DailyMetricUpdateManyMutationInput, DailyMetricUncheckedUpdateManyInput>
    /**
     * Filter which DailyMetrics to update
     */
    where?: DailyMetricWhereInput
  }

  /**
   * DailyMetric upsert
   */
  export type DailyMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the DailyMetric to update in case it exists.
     */
    where: DailyMetricWhereUniqueInput
    /**
     * In case the DailyMetric found by the `where` argument doesn't exist, create a new DailyMetric with this data.
     */
    create: XOR<DailyMetricCreateInput, DailyMetricUncheckedCreateInput>
    /**
     * In case the DailyMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyMetricUpdateInput, DailyMetricUncheckedUpdateInput>
  }

  /**
   * DailyMetric delete
   */
  export type DailyMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
    /**
     * Filter which DailyMetric to delete.
     */
    where: DailyMetricWhereUniqueInput
  }

  /**
   * DailyMetric deleteMany
   */
  export type DailyMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyMetrics to delete
     */
    where?: DailyMetricWhereInput
  }

  /**
   * DailyMetric without action
   */
  export type DailyMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyMetric
     */
    select?: DailyMetricSelect<ExtArgs> | null
  }


  /**
   * Model NudgeEvent
   */

  export type AggregateNudgeEvent = {
    _count: NudgeEventCountAggregateOutputType | null
    _min: NudgeEventMinAggregateOutputType | null
    _max: NudgeEventMaxAggregateOutputType | null
  }

  export type NudgeEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    domain: string | null
    subtype: string | null
    decisionPoint: string | null
    actionTemplate: string | null
    channel: string | null
    sent: boolean | null
    createdAt: Date | null
  }

  export type NudgeEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    domain: string | null
    subtype: string | null
    decisionPoint: string | null
    actionTemplate: string | null
    channel: string | null
    sent: boolean | null
    createdAt: Date | null
  }

  export type NudgeEventCountAggregateOutputType = {
    id: number
    userId: number
    domain: number
    subtype: number
    decisionPoint: number
    state: number
    actionTemplate: number
    channel: number
    sent: number
    createdAt: number
    _all: number
  }


  export type NudgeEventMinAggregateInputType = {
    id?: true
    userId?: true
    domain?: true
    subtype?: true
    decisionPoint?: true
    actionTemplate?: true
    channel?: true
    sent?: true
    createdAt?: true
  }

  export type NudgeEventMaxAggregateInputType = {
    id?: true
    userId?: true
    domain?: true
    subtype?: true
    decisionPoint?: true
    actionTemplate?: true
    channel?: true
    sent?: true
    createdAt?: true
  }

  export type NudgeEventCountAggregateInputType = {
    id?: true
    userId?: true
    domain?: true
    subtype?: true
    decisionPoint?: true
    state?: true
    actionTemplate?: true
    channel?: true
    sent?: true
    createdAt?: true
    _all?: true
  }

  export type NudgeEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NudgeEvent to aggregate.
     */
    where?: NudgeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeEvents to fetch.
     */
    orderBy?: NudgeEventOrderByWithRelationInput | NudgeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NudgeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NudgeEvents
    **/
    _count?: true | NudgeEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NudgeEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NudgeEventMaxAggregateInputType
  }

  export type GetNudgeEventAggregateType<T extends NudgeEventAggregateArgs> = {
        [P in keyof T & keyof AggregateNudgeEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNudgeEvent[P]>
      : GetScalarType<T[P], AggregateNudgeEvent[P]>
  }




  export type NudgeEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NudgeEventWhereInput
    orderBy?: NudgeEventOrderByWithAggregationInput | NudgeEventOrderByWithAggregationInput[]
    by: NudgeEventScalarFieldEnum[] | NudgeEventScalarFieldEnum
    having?: NudgeEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NudgeEventCountAggregateInputType | true
    _min?: NudgeEventMinAggregateInputType
    _max?: NudgeEventMaxAggregateInputType
  }

  export type NudgeEventGroupByOutputType = {
    id: string
    userId: string
    domain: string
    subtype: string
    decisionPoint: string
    state: JsonValue
    actionTemplate: string | null
    channel: string
    sent: boolean
    createdAt: Date
    _count: NudgeEventCountAggregateOutputType | null
    _min: NudgeEventMinAggregateOutputType | null
    _max: NudgeEventMaxAggregateOutputType | null
  }

  type GetNudgeEventGroupByPayload<T extends NudgeEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NudgeEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NudgeEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NudgeEventGroupByOutputType[P]>
            : GetScalarType<T[P], NudgeEventGroupByOutputType[P]>
        }
      >
    >


  export type NudgeEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    domain?: boolean
    subtype?: boolean
    decisionPoint?: boolean
    state?: boolean
    actionTemplate?: boolean
    channel?: boolean
    sent?: boolean
    createdAt?: boolean
    outcomes?: boolean | NudgeEvent$outcomesArgs<ExtArgs>
    _count?: boolean | NudgeEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nudgeEvent"]>

  export type NudgeEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    domain?: boolean
    subtype?: boolean
    decisionPoint?: boolean
    state?: boolean
    actionTemplate?: boolean
    channel?: boolean
    sent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nudgeEvent"]>

  export type NudgeEventSelectScalar = {
    id?: boolean
    userId?: boolean
    domain?: boolean
    subtype?: boolean
    decisionPoint?: boolean
    state?: boolean
    actionTemplate?: boolean
    channel?: boolean
    sent?: boolean
    createdAt?: boolean
  }

  export type NudgeEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outcomes?: boolean | NudgeEvent$outcomesArgs<ExtArgs>
    _count?: boolean | NudgeEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NudgeEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NudgeEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NudgeEvent"
    objects: {
      outcomes: Prisma.$NudgeOutcomePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      domain: string
      subtype: string
      decisionPoint: string
      state: Prisma.JsonValue
      actionTemplate: string | null
      channel: string
      sent: boolean
      createdAt: Date
    }, ExtArgs["result"]["nudgeEvent"]>
    composites: {}
  }

  type NudgeEventGetPayload<S extends boolean | null | undefined | NudgeEventDefaultArgs> = $Result.GetResult<Prisma.$NudgeEventPayload, S>

  type NudgeEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NudgeEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NudgeEventCountAggregateInputType | true
    }

  export interface NudgeEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NudgeEvent'], meta: { name: 'NudgeEvent' } }
    /**
     * Find zero or one NudgeEvent that matches the filter.
     * @param {NudgeEventFindUniqueArgs} args - Arguments to find a NudgeEvent
     * @example
     * // Get one NudgeEvent
     * const nudgeEvent = await prisma.nudgeEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NudgeEventFindUniqueArgs>(args: SelectSubset<T, NudgeEventFindUniqueArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NudgeEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NudgeEventFindUniqueOrThrowArgs} args - Arguments to find a NudgeEvent
     * @example
     * // Get one NudgeEvent
     * const nudgeEvent = await prisma.nudgeEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NudgeEventFindUniqueOrThrowArgs>(args: SelectSubset<T, NudgeEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NudgeEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventFindFirstArgs} args - Arguments to find a NudgeEvent
     * @example
     * // Get one NudgeEvent
     * const nudgeEvent = await prisma.nudgeEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NudgeEventFindFirstArgs>(args?: SelectSubset<T, NudgeEventFindFirstArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NudgeEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventFindFirstOrThrowArgs} args - Arguments to find a NudgeEvent
     * @example
     * // Get one NudgeEvent
     * const nudgeEvent = await prisma.nudgeEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NudgeEventFindFirstOrThrowArgs>(args?: SelectSubset<T, NudgeEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NudgeEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NudgeEvents
     * const nudgeEvents = await prisma.nudgeEvent.findMany()
     * 
     * // Get first 10 NudgeEvents
     * const nudgeEvents = await prisma.nudgeEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nudgeEventWithIdOnly = await prisma.nudgeEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NudgeEventFindManyArgs>(args?: SelectSubset<T, NudgeEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NudgeEvent.
     * @param {NudgeEventCreateArgs} args - Arguments to create a NudgeEvent.
     * @example
     * // Create one NudgeEvent
     * const NudgeEvent = await prisma.nudgeEvent.create({
     *   data: {
     *     // ... data to create a NudgeEvent
     *   }
     * })
     * 
     */
    create<T extends NudgeEventCreateArgs>(args: SelectSubset<T, NudgeEventCreateArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NudgeEvents.
     * @param {NudgeEventCreateManyArgs} args - Arguments to create many NudgeEvents.
     * @example
     * // Create many NudgeEvents
     * const nudgeEvent = await prisma.nudgeEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NudgeEventCreateManyArgs>(args?: SelectSubset<T, NudgeEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NudgeEvents and returns the data saved in the database.
     * @param {NudgeEventCreateManyAndReturnArgs} args - Arguments to create many NudgeEvents.
     * @example
     * // Create many NudgeEvents
     * const nudgeEvent = await prisma.nudgeEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NudgeEvents and only return the `id`
     * const nudgeEventWithIdOnly = await prisma.nudgeEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NudgeEventCreateManyAndReturnArgs>(args?: SelectSubset<T, NudgeEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NudgeEvent.
     * @param {NudgeEventDeleteArgs} args - Arguments to delete one NudgeEvent.
     * @example
     * // Delete one NudgeEvent
     * const NudgeEvent = await prisma.nudgeEvent.delete({
     *   where: {
     *     // ... filter to delete one NudgeEvent
     *   }
     * })
     * 
     */
    delete<T extends NudgeEventDeleteArgs>(args: SelectSubset<T, NudgeEventDeleteArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NudgeEvent.
     * @param {NudgeEventUpdateArgs} args - Arguments to update one NudgeEvent.
     * @example
     * // Update one NudgeEvent
     * const nudgeEvent = await prisma.nudgeEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NudgeEventUpdateArgs>(args: SelectSubset<T, NudgeEventUpdateArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NudgeEvents.
     * @param {NudgeEventDeleteManyArgs} args - Arguments to filter NudgeEvents to delete.
     * @example
     * // Delete a few NudgeEvents
     * const { count } = await prisma.nudgeEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NudgeEventDeleteManyArgs>(args?: SelectSubset<T, NudgeEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NudgeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NudgeEvents
     * const nudgeEvent = await prisma.nudgeEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NudgeEventUpdateManyArgs>(args: SelectSubset<T, NudgeEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NudgeEvent.
     * @param {NudgeEventUpsertArgs} args - Arguments to update or create a NudgeEvent.
     * @example
     * // Update or create a NudgeEvent
     * const nudgeEvent = await prisma.nudgeEvent.upsert({
     *   create: {
     *     // ... data to create a NudgeEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NudgeEvent we want to update
     *   }
     * })
     */
    upsert<T extends NudgeEventUpsertArgs>(args: SelectSubset<T, NudgeEventUpsertArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NudgeEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventCountArgs} args - Arguments to filter NudgeEvents to count.
     * @example
     * // Count the number of NudgeEvents
     * const count = await prisma.nudgeEvent.count({
     *   where: {
     *     // ... the filter for the NudgeEvents we want to count
     *   }
     * })
    **/
    count<T extends NudgeEventCountArgs>(
      args?: Subset<T, NudgeEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NudgeEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NudgeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NudgeEventAggregateArgs>(args: Subset<T, NudgeEventAggregateArgs>): Prisma.PrismaPromise<GetNudgeEventAggregateType<T>>

    /**
     * Group by NudgeEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NudgeEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NudgeEventGroupByArgs['orderBy'] }
        : { orderBy?: NudgeEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NudgeEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNudgeEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NudgeEvent model
   */
  readonly fields: NudgeEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NudgeEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NudgeEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outcomes<T extends NudgeEvent$outcomesArgs<ExtArgs> = {}>(args?: Subset<T, NudgeEvent$outcomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NudgeEvent model
   */ 
  interface NudgeEventFieldRefs {
    readonly id: FieldRef<"NudgeEvent", 'String'>
    readonly userId: FieldRef<"NudgeEvent", 'String'>
    readonly domain: FieldRef<"NudgeEvent", 'String'>
    readonly subtype: FieldRef<"NudgeEvent", 'String'>
    readonly decisionPoint: FieldRef<"NudgeEvent", 'String'>
    readonly state: FieldRef<"NudgeEvent", 'Json'>
    readonly actionTemplate: FieldRef<"NudgeEvent", 'String'>
    readonly channel: FieldRef<"NudgeEvent", 'String'>
    readonly sent: FieldRef<"NudgeEvent", 'Boolean'>
    readonly createdAt: FieldRef<"NudgeEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NudgeEvent findUnique
   */
  export type NudgeEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * Filter, which NudgeEvent to fetch.
     */
    where: NudgeEventWhereUniqueInput
  }

  /**
   * NudgeEvent findUniqueOrThrow
   */
  export type NudgeEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * Filter, which NudgeEvent to fetch.
     */
    where: NudgeEventWhereUniqueInput
  }

  /**
   * NudgeEvent findFirst
   */
  export type NudgeEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * Filter, which NudgeEvent to fetch.
     */
    where?: NudgeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeEvents to fetch.
     */
    orderBy?: NudgeEventOrderByWithRelationInput | NudgeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NudgeEvents.
     */
    cursor?: NudgeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NudgeEvents.
     */
    distinct?: NudgeEventScalarFieldEnum | NudgeEventScalarFieldEnum[]
  }

  /**
   * NudgeEvent findFirstOrThrow
   */
  export type NudgeEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * Filter, which NudgeEvent to fetch.
     */
    where?: NudgeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeEvents to fetch.
     */
    orderBy?: NudgeEventOrderByWithRelationInput | NudgeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NudgeEvents.
     */
    cursor?: NudgeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NudgeEvents.
     */
    distinct?: NudgeEventScalarFieldEnum | NudgeEventScalarFieldEnum[]
  }

  /**
   * NudgeEvent findMany
   */
  export type NudgeEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * Filter, which NudgeEvents to fetch.
     */
    where?: NudgeEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeEvents to fetch.
     */
    orderBy?: NudgeEventOrderByWithRelationInput | NudgeEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NudgeEvents.
     */
    cursor?: NudgeEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeEvents.
     */
    skip?: number
    distinct?: NudgeEventScalarFieldEnum | NudgeEventScalarFieldEnum[]
  }

  /**
   * NudgeEvent create
   */
  export type NudgeEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * The data needed to create a NudgeEvent.
     */
    data: XOR<NudgeEventCreateInput, NudgeEventUncheckedCreateInput>
  }

  /**
   * NudgeEvent createMany
   */
  export type NudgeEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NudgeEvents.
     */
    data: NudgeEventCreateManyInput | NudgeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NudgeEvent createManyAndReturn
   */
  export type NudgeEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NudgeEvents.
     */
    data: NudgeEventCreateManyInput | NudgeEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NudgeEvent update
   */
  export type NudgeEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * The data needed to update a NudgeEvent.
     */
    data: XOR<NudgeEventUpdateInput, NudgeEventUncheckedUpdateInput>
    /**
     * Choose, which NudgeEvent to update.
     */
    where: NudgeEventWhereUniqueInput
  }

  /**
   * NudgeEvent updateMany
   */
  export type NudgeEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NudgeEvents.
     */
    data: XOR<NudgeEventUpdateManyMutationInput, NudgeEventUncheckedUpdateManyInput>
    /**
     * Filter which NudgeEvents to update
     */
    where?: NudgeEventWhereInput
  }

  /**
   * NudgeEvent upsert
   */
  export type NudgeEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * The filter to search for the NudgeEvent to update in case it exists.
     */
    where: NudgeEventWhereUniqueInput
    /**
     * In case the NudgeEvent found by the `where` argument doesn't exist, create a new NudgeEvent with this data.
     */
    create: XOR<NudgeEventCreateInput, NudgeEventUncheckedCreateInput>
    /**
     * In case the NudgeEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NudgeEventUpdateInput, NudgeEventUncheckedUpdateInput>
  }

  /**
   * NudgeEvent delete
   */
  export type NudgeEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
    /**
     * Filter which NudgeEvent to delete.
     */
    where: NudgeEventWhereUniqueInput
  }

  /**
   * NudgeEvent deleteMany
   */
  export type NudgeEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NudgeEvents to delete
     */
    where?: NudgeEventWhereInput
  }

  /**
   * NudgeEvent.outcomes
   */
  export type NudgeEvent$outcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    where?: NudgeOutcomeWhereInput
    orderBy?: NudgeOutcomeOrderByWithRelationInput | NudgeOutcomeOrderByWithRelationInput[]
    cursor?: NudgeOutcomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NudgeOutcomeScalarFieldEnum | NudgeOutcomeScalarFieldEnum[]
  }

  /**
   * NudgeEvent without action
   */
  export type NudgeEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeEvent
     */
    select?: NudgeEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeEventInclude<ExtArgs> | null
  }


  /**
   * Model NudgeOutcome
   */

  export type AggregateNudgeOutcome = {
    _count: NudgeOutcomeCountAggregateOutputType | null
    _avg: NudgeOutcomeAvgAggregateOutputType | null
    _sum: NudgeOutcomeSumAggregateOutputType | null
    _min: NudgeOutcomeMinAggregateOutputType | null
    _max: NudgeOutcomeMaxAggregateOutputType | null
  }

  export type NudgeOutcomeAvgAggregateOutputType = {
    reward: number | null
  }

  export type NudgeOutcomeSumAggregateOutputType = {
    reward: number | null
  }

  export type NudgeOutcomeMinAggregateOutputType = {
    id: string | null
    nudgeEventId: string | null
    reward: number | null
    createdAt: Date | null
  }

  export type NudgeOutcomeMaxAggregateOutputType = {
    id: string | null
    nudgeEventId: string | null
    reward: number | null
    createdAt: Date | null
  }

  export type NudgeOutcomeCountAggregateOutputType = {
    id: number
    nudgeEventId: number
    reward: number
    shortTerm: number
    emaScore: number
    signals: number
    createdAt: number
    _all: number
  }


  export type NudgeOutcomeAvgAggregateInputType = {
    reward?: true
  }

  export type NudgeOutcomeSumAggregateInputType = {
    reward?: true
  }

  export type NudgeOutcomeMinAggregateInputType = {
    id?: true
    nudgeEventId?: true
    reward?: true
    createdAt?: true
  }

  export type NudgeOutcomeMaxAggregateInputType = {
    id?: true
    nudgeEventId?: true
    reward?: true
    createdAt?: true
  }

  export type NudgeOutcomeCountAggregateInputType = {
    id?: true
    nudgeEventId?: true
    reward?: true
    shortTerm?: true
    emaScore?: true
    signals?: true
    createdAt?: true
    _all?: true
  }

  export type NudgeOutcomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NudgeOutcome to aggregate.
     */
    where?: NudgeOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeOutcomes to fetch.
     */
    orderBy?: NudgeOutcomeOrderByWithRelationInput | NudgeOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NudgeOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NudgeOutcomes
    **/
    _count?: true | NudgeOutcomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NudgeOutcomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NudgeOutcomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NudgeOutcomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NudgeOutcomeMaxAggregateInputType
  }

  export type GetNudgeOutcomeAggregateType<T extends NudgeOutcomeAggregateArgs> = {
        [P in keyof T & keyof AggregateNudgeOutcome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNudgeOutcome[P]>
      : GetScalarType<T[P], AggregateNudgeOutcome[P]>
  }




  export type NudgeOutcomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NudgeOutcomeWhereInput
    orderBy?: NudgeOutcomeOrderByWithAggregationInput | NudgeOutcomeOrderByWithAggregationInput[]
    by: NudgeOutcomeScalarFieldEnum[] | NudgeOutcomeScalarFieldEnum
    having?: NudgeOutcomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NudgeOutcomeCountAggregateInputType | true
    _avg?: NudgeOutcomeAvgAggregateInputType
    _sum?: NudgeOutcomeSumAggregateInputType
    _min?: NudgeOutcomeMinAggregateInputType
    _max?: NudgeOutcomeMaxAggregateInputType
  }

  export type NudgeOutcomeGroupByOutputType = {
    id: string
    nudgeEventId: string
    reward: number | null
    shortTerm: JsonValue
    emaScore: JsonValue | null
    signals: JsonValue
    createdAt: Date
    _count: NudgeOutcomeCountAggregateOutputType | null
    _avg: NudgeOutcomeAvgAggregateOutputType | null
    _sum: NudgeOutcomeSumAggregateOutputType | null
    _min: NudgeOutcomeMinAggregateOutputType | null
    _max: NudgeOutcomeMaxAggregateOutputType | null
  }

  type GetNudgeOutcomeGroupByPayload<T extends NudgeOutcomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NudgeOutcomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NudgeOutcomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NudgeOutcomeGroupByOutputType[P]>
            : GetScalarType<T[P], NudgeOutcomeGroupByOutputType[P]>
        }
      >
    >


  export type NudgeOutcomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nudgeEventId?: boolean
    reward?: boolean
    shortTerm?: boolean
    emaScore?: boolean
    signals?: boolean
    createdAt?: boolean
    event?: boolean | NudgeEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nudgeOutcome"]>

  export type NudgeOutcomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nudgeEventId?: boolean
    reward?: boolean
    shortTerm?: boolean
    emaScore?: boolean
    signals?: boolean
    createdAt?: boolean
    event?: boolean | NudgeEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nudgeOutcome"]>

  export type NudgeOutcomeSelectScalar = {
    id?: boolean
    nudgeEventId?: boolean
    reward?: boolean
    shortTerm?: boolean
    emaScore?: boolean
    signals?: boolean
    createdAt?: boolean
  }

  export type NudgeOutcomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | NudgeEventDefaultArgs<ExtArgs>
  }
  export type NudgeOutcomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | NudgeEventDefaultArgs<ExtArgs>
  }

  export type $NudgeOutcomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NudgeOutcome"
    objects: {
      event: Prisma.$NudgeEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nudgeEventId: string
      reward: number | null
      shortTerm: Prisma.JsonValue
      emaScore: Prisma.JsonValue | null
      signals: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["nudgeOutcome"]>
    composites: {}
  }

  type NudgeOutcomeGetPayload<S extends boolean | null | undefined | NudgeOutcomeDefaultArgs> = $Result.GetResult<Prisma.$NudgeOutcomePayload, S>

  type NudgeOutcomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NudgeOutcomeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NudgeOutcomeCountAggregateInputType | true
    }

  export interface NudgeOutcomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NudgeOutcome'], meta: { name: 'NudgeOutcome' } }
    /**
     * Find zero or one NudgeOutcome that matches the filter.
     * @param {NudgeOutcomeFindUniqueArgs} args - Arguments to find a NudgeOutcome
     * @example
     * // Get one NudgeOutcome
     * const nudgeOutcome = await prisma.nudgeOutcome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NudgeOutcomeFindUniqueArgs>(args: SelectSubset<T, NudgeOutcomeFindUniqueArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NudgeOutcome that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NudgeOutcomeFindUniqueOrThrowArgs} args - Arguments to find a NudgeOutcome
     * @example
     * // Get one NudgeOutcome
     * const nudgeOutcome = await prisma.nudgeOutcome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NudgeOutcomeFindUniqueOrThrowArgs>(args: SelectSubset<T, NudgeOutcomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NudgeOutcome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeFindFirstArgs} args - Arguments to find a NudgeOutcome
     * @example
     * // Get one NudgeOutcome
     * const nudgeOutcome = await prisma.nudgeOutcome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NudgeOutcomeFindFirstArgs>(args?: SelectSubset<T, NudgeOutcomeFindFirstArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NudgeOutcome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeFindFirstOrThrowArgs} args - Arguments to find a NudgeOutcome
     * @example
     * // Get one NudgeOutcome
     * const nudgeOutcome = await prisma.nudgeOutcome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NudgeOutcomeFindFirstOrThrowArgs>(args?: SelectSubset<T, NudgeOutcomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NudgeOutcomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NudgeOutcomes
     * const nudgeOutcomes = await prisma.nudgeOutcome.findMany()
     * 
     * // Get first 10 NudgeOutcomes
     * const nudgeOutcomes = await prisma.nudgeOutcome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nudgeOutcomeWithIdOnly = await prisma.nudgeOutcome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NudgeOutcomeFindManyArgs>(args?: SelectSubset<T, NudgeOutcomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NudgeOutcome.
     * @param {NudgeOutcomeCreateArgs} args - Arguments to create a NudgeOutcome.
     * @example
     * // Create one NudgeOutcome
     * const NudgeOutcome = await prisma.nudgeOutcome.create({
     *   data: {
     *     // ... data to create a NudgeOutcome
     *   }
     * })
     * 
     */
    create<T extends NudgeOutcomeCreateArgs>(args: SelectSubset<T, NudgeOutcomeCreateArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NudgeOutcomes.
     * @param {NudgeOutcomeCreateManyArgs} args - Arguments to create many NudgeOutcomes.
     * @example
     * // Create many NudgeOutcomes
     * const nudgeOutcome = await prisma.nudgeOutcome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NudgeOutcomeCreateManyArgs>(args?: SelectSubset<T, NudgeOutcomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NudgeOutcomes and returns the data saved in the database.
     * @param {NudgeOutcomeCreateManyAndReturnArgs} args - Arguments to create many NudgeOutcomes.
     * @example
     * // Create many NudgeOutcomes
     * const nudgeOutcome = await prisma.nudgeOutcome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NudgeOutcomes and only return the `id`
     * const nudgeOutcomeWithIdOnly = await prisma.nudgeOutcome.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NudgeOutcomeCreateManyAndReturnArgs>(args?: SelectSubset<T, NudgeOutcomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NudgeOutcome.
     * @param {NudgeOutcomeDeleteArgs} args - Arguments to delete one NudgeOutcome.
     * @example
     * // Delete one NudgeOutcome
     * const NudgeOutcome = await prisma.nudgeOutcome.delete({
     *   where: {
     *     // ... filter to delete one NudgeOutcome
     *   }
     * })
     * 
     */
    delete<T extends NudgeOutcomeDeleteArgs>(args: SelectSubset<T, NudgeOutcomeDeleteArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NudgeOutcome.
     * @param {NudgeOutcomeUpdateArgs} args - Arguments to update one NudgeOutcome.
     * @example
     * // Update one NudgeOutcome
     * const nudgeOutcome = await prisma.nudgeOutcome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NudgeOutcomeUpdateArgs>(args: SelectSubset<T, NudgeOutcomeUpdateArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NudgeOutcomes.
     * @param {NudgeOutcomeDeleteManyArgs} args - Arguments to filter NudgeOutcomes to delete.
     * @example
     * // Delete a few NudgeOutcomes
     * const { count } = await prisma.nudgeOutcome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NudgeOutcomeDeleteManyArgs>(args?: SelectSubset<T, NudgeOutcomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NudgeOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NudgeOutcomes
     * const nudgeOutcome = await prisma.nudgeOutcome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NudgeOutcomeUpdateManyArgs>(args: SelectSubset<T, NudgeOutcomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NudgeOutcome.
     * @param {NudgeOutcomeUpsertArgs} args - Arguments to update or create a NudgeOutcome.
     * @example
     * // Update or create a NudgeOutcome
     * const nudgeOutcome = await prisma.nudgeOutcome.upsert({
     *   create: {
     *     // ... data to create a NudgeOutcome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NudgeOutcome we want to update
     *   }
     * })
     */
    upsert<T extends NudgeOutcomeUpsertArgs>(args: SelectSubset<T, NudgeOutcomeUpsertArgs<ExtArgs>>): Prisma__NudgeOutcomeClient<$Result.GetResult<Prisma.$NudgeOutcomePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NudgeOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeCountArgs} args - Arguments to filter NudgeOutcomes to count.
     * @example
     * // Count the number of NudgeOutcomes
     * const count = await prisma.nudgeOutcome.count({
     *   where: {
     *     // ... the filter for the NudgeOutcomes we want to count
     *   }
     * })
    **/
    count<T extends NudgeOutcomeCountArgs>(
      args?: Subset<T, NudgeOutcomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NudgeOutcomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NudgeOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NudgeOutcomeAggregateArgs>(args: Subset<T, NudgeOutcomeAggregateArgs>): Prisma.PrismaPromise<GetNudgeOutcomeAggregateType<T>>

    /**
     * Group by NudgeOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NudgeOutcomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NudgeOutcomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NudgeOutcomeGroupByArgs['orderBy'] }
        : { orderBy?: NudgeOutcomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NudgeOutcomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNudgeOutcomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NudgeOutcome model
   */
  readonly fields: NudgeOutcomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NudgeOutcome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NudgeOutcomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends NudgeEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NudgeEventDefaultArgs<ExtArgs>>): Prisma__NudgeEventClient<$Result.GetResult<Prisma.$NudgeEventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NudgeOutcome model
   */ 
  interface NudgeOutcomeFieldRefs {
    readonly id: FieldRef<"NudgeOutcome", 'String'>
    readonly nudgeEventId: FieldRef<"NudgeOutcome", 'String'>
    readonly reward: FieldRef<"NudgeOutcome", 'Float'>
    readonly shortTerm: FieldRef<"NudgeOutcome", 'Json'>
    readonly emaScore: FieldRef<"NudgeOutcome", 'Json'>
    readonly signals: FieldRef<"NudgeOutcome", 'Json'>
    readonly createdAt: FieldRef<"NudgeOutcome", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NudgeOutcome findUnique
   */
  export type NudgeOutcomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which NudgeOutcome to fetch.
     */
    where: NudgeOutcomeWhereUniqueInput
  }

  /**
   * NudgeOutcome findUniqueOrThrow
   */
  export type NudgeOutcomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which NudgeOutcome to fetch.
     */
    where: NudgeOutcomeWhereUniqueInput
  }

  /**
   * NudgeOutcome findFirst
   */
  export type NudgeOutcomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which NudgeOutcome to fetch.
     */
    where?: NudgeOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeOutcomes to fetch.
     */
    orderBy?: NudgeOutcomeOrderByWithRelationInput | NudgeOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NudgeOutcomes.
     */
    cursor?: NudgeOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NudgeOutcomes.
     */
    distinct?: NudgeOutcomeScalarFieldEnum | NudgeOutcomeScalarFieldEnum[]
  }

  /**
   * NudgeOutcome findFirstOrThrow
   */
  export type NudgeOutcomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which NudgeOutcome to fetch.
     */
    where?: NudgeOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeOutcomes to fetch.
     */
    orderBy?: NudgeOutcomeOrderByWithRelationInput | NudgeOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NudgeOutcomes.
     */
    cursor?: NudgeOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NudgeOutcomes.
     */
    distinct?: NudgeOutcomeScalarFieldEnum | NudgeOutcomeScalarFieldEnum[]
  }

  /**
   * NudgeOutcome findMany
   */
  export type NudgeOutcomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which NudgeOutcomes to fetch.
     */
    where?: NudgeOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NudgeOutcomes to fetch.
     */
    orderBy?: NudgeOutcomeOrderByWithRelationInput | NudgeOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NudgeOutcomes.
     */
    cursor?: NudgeOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NudgeOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NudgeOutcomes.
     */
    skip?: number
    distinct?: NudgeOutcomeScalarFieldEnum | NudgeOutcomeScalarFieldEnum[]
  }

  /**
   * NudgeOutcome create
   */
  export type NudgeOutcomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to create a NudgeOutcome.
     */
    data: XOR<NudgeOutcomeCreateInput, NudgeOutcomeUncheckedCreateInput>
  }

  /**
   * NudgeOutcome createMany
   */
  export type NudgeOutcomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NudgeOutcomes.
     */
    data: NudgeOutcomeCreateManyInput | NudgeOutcomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NudgeOutcome createManyAndReturn
   */
  export type NudgeOutcomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NudgeOutcomes.
     */
    data: NudgeOutcomeCreateManyInput | NudgeOutcomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NudgeOutcome update
   */
  export type NudgeOutcomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to update a NudgeOutcome.
     */
    data: XOR<NudgeOutcomeUpdateInput, NudgeOutcomeUncheckedUpdateInput>
    /**
     * Choose, which NudgeOutcome to update.
     */
    where: NudgeOutcomeWhereUniqueInput
  }

  /**
   * NudgeOutcome updateMany
   */
  export type NudgeOutcomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NudgeOutcomes.
     */
    data: XOR<NudgeOutcomeUpdateManyMutationInput, NudgeOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which NudgeOutcomes to update
     */
    where?: NudgeOutcomeWhereInput
  }

  /**
   * NudgeOutcome upsert
   */
  export type NudgeOutcomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * The filter to search for the NudgeOutcome to update in case it exists.
     */
    where: NudgeOutcomeWhereUniqueInput
    /**
     * In case the NudgeOutcome found by the `where` argument doesn't exist, create a new NudgeOutcome with this data.
     */
    create: XOR<NudgeOutcomeCreateInput, NudgeOutcomeUncheckedCreateInput>
    /**
     * In case the NudgeOutcome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NudgeOutcomeUpdateInput, NudgeOutcomeUncheckedUpdateInput>
  }

  /**
   * NudgeOutcome delete
   */
  export type NudgeOutcomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
    /**
     * Filter which NudgeOutcome to delete.
     */
    where: NudgeOutcomeWhereUniqueInput
  }

  /**
   * NudgeOutcome deleteMany
   */
  export type NudgeOutcomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NudgeOutcomes to delete
     */
    where?: NudgeOutcomeWhereInput
  }

  /**
   * NudgeOutcome without action
   */
  export type NudgeOutcomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NudgeOutcome
     */
    select?: NudgeOutcomeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NudgeOutcomeInclude<ExtArgs> | null
  }


  /**
   * Model FeelingSession
   */

  export type AggregateFeelingSession = {
    _count: FeelingSessionCountAggregateOutputType | null
    _min: FeelingSessionMinAggregateOutputType | null
    _max: FeelingSessionMaxAggregateOutputType | null
  }

  export type FeelingSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    feelingId: string | null
    topic: string | null
    actionTemplate: string | null
    startedAt: Date | null
    endedAt: Date | null
    emaBetter: boolean | null
    summary: string | null
    createdAt: Date | null
  }

  export type FeelingSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    feelingId: string | null
    topic: string | null
    actionTemplate: string | null
    startedAt: Date | null
    endedAt: Date | null
    emaBetter: boolean | null
    summary: string | null
    createdAt: Date | null
  }

  export type FeelingSessionCountAggregateOutputType = {
    id: number
    userId: number
    feelingId: number
    topic: number
    actionTemplate: number
    startedAt: number
    endedAt: number
    emaBetter: number
    summary: number
    transcript: number
    context: number
    createdAt: number
    _all: number
  }


  export type FeelingSessionMinAggregateInputType = {
    id?: true
    userId?: true
    feelingId?: true
    topic?: true
    actionTemplate?: true
    startedAt?: true
    endedAt?: true
    emaBetter?: true
    summary?: true
    createdAt?: true
  }

  export type FeelingSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    feelingId?: true
    topic?: true
    actionTemplate?: true
    startedAt?: true
    endedAt?: true
    emaBetter?: true
    summary?: true
    createdAt?: true
  }

  export type FeelingSessionCountAggregateInputType = {
    id?: true
    userId?: true
    feelingId?: true
    topic?: true
    actionTemplate?: true
    startedAt?: true
    endedAt?: true
    emaBetter?: true
    summary?: true
    transcript?: true
    context?: true
    createdAt?: true
    _all?: true
  }

  export type FeelingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeelingSession to aggregate.
     */
    where?: FeelingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeelingSessions to fetch.
     */
    orderBy?: FeelingSessionOrderByWithRelationInput | FeelingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeelingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeelingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeelingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeelingSessions
    **/
    _count?: true | FeelingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeelingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeelingSessionMaxAggregateInputType
  }

  export type GetFeelingSessionAggregateType<T extends FeelingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateFeelingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeelingSession[P]>
      : GetScalarType<T[P], AggregateFeelingSession[P]>
  }




  export type FeelingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeelingSessionWhereInput
    orderBy?: FeelingSessionOrderByWithAggregationInput | FeelingSessionOrderByWithAggregationInput[]
    by: FeelingSessionScalarFieldEnum[] | FeelingSessionScalarFieldEnum
    having?: FeelingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeelingSessionCountAggregateInputType | true
    _min?: FeelingSessionMinAggregateInputType
    _max?: FeelingSessionMaxAggregateInputType
  }

  export type FeelingSessionGroupByOutputType = {
    id: string
    userId: string
    feelingId: string
    topic: string | null
    actionTemplate: string | null
    startedAt: Date
    endedAt: Date | null
    emaBetter: boolean | null
    summary: string | null
    transcript: JsonValue | null
    context: JsonValue
    createdAt: Date
    _count: FeelingSessionCountAggregateOutputType | null
    _min: FeelingSessionMinAggregateOutputType | null
    _max: FeelingSessionMaxAggregateOutputType | null
  }

  type GetFeelingSessionGroupByPayload<T extends FeelingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeelingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeelingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeelingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], FeelingSessionGroupByOutputType[P]>
        }
      >
    >


  export type FeelingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feelingId?: boolean
    topic?: boolean
    actionTemplate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    emaBetter?: boolean
    summary?: boolean
    transcript?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["feelingSession"]>

  export type FeelingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    feelingId?: boolean
    topic?: boolean
    actionTemplate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    emaBetter?: boolean
    summary?: boolean
    transcript?: boolean
    context?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["feelingSession"]>

  export type FeelingSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    feelingId?: boolean
    topic?: boolean
    actionTemplate?: boolean
    startedAt?: boolean
    endedAt?: boolean
    emaBetter?: boolean
    summary?: boolean
    transcript?: boolean
    context?: boolean
    createdAt?: boolean
  }


  export type $FeelingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeelingSession"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      feelingId: string
      topic: string | null
      actionTemplate: string | null
      startedAt: Date
      endedAt: Date | null
      emaBetter: boolean | null
      summary: string | null
      transcript: Prisma.JsonValue | null
      context: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["feelingSession"]>
    composites: {}
  }

  type FeelingSessionGetPayload<S extends boolean | null | undefined | FeelingSessionDefaultArgs> = $Result.GetResult<Prisma.$FeelingSessionPayload, S>

  type FeelingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeelingSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeelingSessionCountAggregateInputType | true
    }

  export interface FeelingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeelingSession'], meta: { name: 'FeelingSession' } }
    /**
     * Find zero or one FeelingSession that matches the filter.
     * @param {FeelingSessionFindUniqueArgs} args - Arguments to find a FeelingSession
     * @example
     * // Get one FeelingSession
     * const feelingSession = await prisma.feelingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeelingSessionFindUniqueArgs>(args: SelectSubset<T, FeelingSessionFindUniqueArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeelingSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeelingSessionFindUniqueOrThrowArgs} args - Arguments to find a FeelingSession
     * @example
     * // Get one FeelingSession
     * const feelingSession = await prisma.feelingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeelingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, FeelingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeelingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionFindFirstArgs} args - Arguments to find a FeelingSession
     * @example
     * // Get one FeelingSession
     * const feelingSession = await prisma.feelingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeelingSessionFindFirstArgs>(args?: SelectSubset<T, FeelingSessionFindFirstArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeelingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionFindFirstOrThrowArgs} args - Arguments to find a FeelingSession
     * @example
     * // Get one FeelingSession
     * const feelingSession = await prisma.feelingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeelingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, FeelingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeelingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeelingSessions
     * const feelingSessions = await prisma.feelingSession.findMany()
     * 
     * // Get first 10 FeelingSessions
     * const feelingSessions = await prisma.feelingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feelingSessionWithIdOnly = await prisma.feelingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeelingSessionFindManyArgs>(args?: SelectSubset<T, FeelingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeelingSession.
     * @param {FeelingSessionCreateArgs} args - Arguments to create a FeelingSession.
     * @example
     * // Create one FeelingSession
     * const FeelingSession = await prisma.feelingSession.create({
     *   data: {
     *     // ... data to create a FeelingSession
     *   }
     * })
     * 
     */
    create<T extends FeelingSessionCreateArgs>(args: SelectSubset<T, FeelingSessionCreateArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeelingSessions.
     * @param {FeelingSessionCreateManyArgs} args - Arguments to create many FeelingSessions.
     * @example
     * // Create many FeelingSessions
     * const feelingSession = await prisma.feelingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeelingSessionCreateManyArgs>(args?: SelectSubset<T, FeelingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeelingSessions and returns the data saved in the database.
     * @param {FeelingSessionCreateManyAndReturnArgs} args - Arguments to create many FeelingSessions.
     * @example
     * // Create many FeelingSessions
     * const feelingSession = await prisma.feelingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeelingSessions and only return the `id`
     * const feelingSessionWithIdOnly = await prisma.feelingSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeelingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, FeelingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeelingSession.
     * @param {FeelingSessionDeleteArgs} args - Arguments to delete one FeelingSession.
     * @example
     * // Delete one FeelingSession
     * const FeelingSession = await prisma.feelingSession.delete({
     *   where: {
     *     // ... filter to delete one FeelingSession
     *   }
     * })
     * 
     */
    delete<T extends FeelingSessionDeleteArgs>(args: SelectSubset<T, FeelingSessionDeleteArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeelingSession.
     * @param {FeelingSessionUpdateArgs} args - Arguments to update one FeelingSession.
     * @example
     * // Update one FeelingSession
     * const feelingSession = await prisma.feelingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeelingSessionUpdateArgs>(args: SelectSubset<T, FeelingSessionUpdateArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeelingSessions.
     * @param {FeelingSessionDeleteManyArgs} args - Arguments to filter FeelingSessions to delete.
     * @example
     * // Delete a few FeelingSessions
     * const { count } = await prisma.feelingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeelingSessionDeleteManyArgs>(args?: SelectSubset<T, FeelingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeelingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeelingSessions
     * const feelingSession = await prisma.feelingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeelingSessionUpdateManyArgs>(args: SelectSubset<T, FeelingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeelingSession.
     * @param {FeelingSessionUpsertArgs} args - Arguments to update or create a FeelingSession.
     * @example
     * // Update or create a FeelingSession
     * const feelingSession = await prisma.feelingSession.upsert({
     *   create: {
     *     // ... data to create a FeelingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeelingSession we want to update
     *   }
     * })
     */
    upsert<T extends FeelingSessionUpsertArgs>(args: SelectSubset<T, FeelingSessionUpsertArgs<ExtArgs>>): Prisma__FeelingSessionClient<$Result.GetResult<Prisma.$FeelingSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeelingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionCountArgs} args - Arguments to filter FeelingSessions to count.
     * @example
     * // Count the number of FeelingSessions
     * const count = await prisma.feelingSession.count({
     *   where: {
     *     // ... the filter for the FeelingSessions we want to count
     *   }
     * })
    **/
    count<T extends FeelingSessionCountArgs>(
      args?: Subset<T, FeelingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeelingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeelingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeelingSessionAggregateArgs>(args: Subset<T, FeelingSessionAggregateArgs>): Prisma.PrismaPromise<GetFeelingSessionAggregateType<T>>

    /**
     * Group by FeelingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeelingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeelingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeelingSessionGroupByArgs['orderBy'] }
        : { orderBy?: FeelingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeelingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeelingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeelingSession model
   */
  readonly fields: FeelingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeelingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeelingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeelingSession model
   */ 
  interface FeelingSessionFieldRefs {
    readonly id: FieldRef<"FeelingSession", 'String'>
    readonly userId: FieldRef<"FeelingSession", 'String'>
    readonly feelingId: FieldRef<"FeelingSession", 'String'>
    readonly topic: FieldRef<"FeelingSession", 'String'>
    readonly actionTemplate: FieldRef<"FeelingSession", 'String'>
    readonly startedAt: FieldRef<"FeelingSession", 'DateTime'>
    readonly endedAt: FieldRef<"FeelingSession", 'DateTime'>
    readonly emaBetter: FieldRef<"FeelingSession", 'Boolean'>
    readonly summary: FieldRef<"FeelingSession", 'String'>
    readonly transcript: FieldRef<"FeelingSession", 'Json'>
    readonly context: FieldRef<"FeelingSession", 'Json'>
    readonly createdAt: FieldRef<"FeelingSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeelingSession findUnique
   */
  export type FeelingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * Filter, which FeelingSession to fetch.
     */
    where: FeelingSessionWhereUniqueInput
  }

  /**
   * FeelingSession findUniqueOrThrow
   */
  export type FeelingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * Filter, which FeelingSession to fetch.
     */
    where: FeelingSessionWhereUniqueInput
  }

  /**
   * FeelingSession findFirst
   */
  export type FeelingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * Filter, which FeelingSession to fetch.
     */
    where?: FeelingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeelingSessions to fetch.
     */
    orderBy?: FeelingSessionOrderByWithRelationInput | FeelingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeelingSessions.
     */
    cursor?: FeelingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeelingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeelingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeelingSessions.
     */
    distinct?: FeelingSessionScalarFieldEnum | FeelingSessionScalarFieldEnum[]
  }

  /**
   * FeelingSession findFirstOrThrow
   */
  export type FeelingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * Filter, which FeelingSession to fetch.
     */
    where?: FeelingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeelingSessions to fetch.
     */
    orderBy?: FeelingSessionOrderByWithRelationInput | FeelingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeelingSessions.
     */
    cursor?: FeelingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeelingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeelingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeelingSessions.
     */
    distinct?: FeelingSessionScalarFieldEnum | FeelingSessionScalarFieldEnum[]
  }

  /**
   * FeelingSession findMany
   */
  export type FeelingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * Filter, which FeelingSessions to fetch.
     */
    where?: FeelingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeelingSessions to fetch.
     */
    orderBy?: FeelingSessionOrderByWithRelationInput | FeelingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeelingSessions.
     */
    cursor?: FeelingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeelingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeelingSessions.
     */
    skip?: number
    distinct?: FeelingSessionScalarFieldEnum | FeelingSessionScalarFieldEnum[]
  }

  /**
   * FeelingSession create
   */
  export type FeelingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * The data needed to create a FeelingSession.
     */
    data: XOR<FeelingSessionCreateInput, FeelingSessionUncheckedCreateInput>
  }

  /**
   * FeelingSession createMany
   */
  export type FeelingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeelingSessions.
     */
    data: FeelingSessionCreateManyInput | FeelingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeelingSession createManyAndReturn
   */
  export type FeelingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeelingSessions.
     */
    data: FeelingSessionCreateManyInput | FeelingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeelingSession update
   */
  export type FeelingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * The data needed to update a FeelingSession.
     */
    data: XOR<FeelingSessionUpdateInput, FeelingSessionUncheckedUpdateInput>
    /**
     * Choose, which FeelingSession to update.
     */
    where: FeelingSessionWhereUniqueInput
  }

  /**
   * FeelingSession updateMany
   */
  export type FeelingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeelingSessions.
     */
    data: XOR<FeelingSessionUpdateManyMutationInput, FeelingSessionUncheckedUpdateManyInput>
    /**
     * Filter which FeelingSessions to update
     */
    where?: FeelingSessionWhereInput
  }

  /**
   * FeelingSession upsert
   */
  export type FeelingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * The filter to search for the FeelingSession to update in case it exists.
     */
    where: FeelingSessionWhereUniqueInput
    /**
     * In case the FeelingSession found by the `where` argument doesn't exist, create a new FeelingSession with this data.
     */
    create: XOR<FeelingSessionCreateInput, FeelingSessionUncheckedCreateInput>
    /**
     * In case the FeelingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeelingSessionUpdateInput, FeelingSessionUncheckedUpdateInput>
  }

  /**
   * FeelingSession delete
   */
  export type FeelingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
    /**
     * Filter which FeelingSession to delete.
     */
    where: FeelingSessionWhereUniqueInput
  }

  /**
   * FeelingSession deleteMany
   */
  export type FeelingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeelingSessions to delete
     */
    where?: FeelingSessionWhereInput
  }

  /**
   * FeelingSession without action
   */
  export type FeelingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeelingSession
     */
    select?: FeelingSessionSelect<ExtArgs> | null
  }


  /**
   * Model BanditModel
   */

  export type AggregateBanditModel = {
    _count: BanditModelCountAggregateOutputType | null
    _avg: BanditModelAvgAggregateOutputType | null
    _sum: BanditModelSumAggregateOutputType | null
    _min: BanditModelMinAggregateOutputType | null
    _max: BanditModelMaxAggregateOutputType | null
  }

  export type BanditModelAvgAggregateOutputType = {
    version: number | null
  }

  export type BanditModelSumAggregateOutputType = {
    version: number | null
  }

  export type BanditModelMinAggregateOutputType = {
    id: string | null
    domain: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BanditModelMaxAggregateOutputType = {
    id: string | null
    domain: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BanditModelCountAggregateOutputType = {
    id: number
    domain: number
    version: number
    weights: number
    covariance: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BanditModelAvgAggregateInputType = {
    version?: true
  }

  export type BanditModelSumAggregateInputType = {
    version?: true
  }

  export type BanditModelMinAggregateInputType = {
    id?: true
    domain?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BanditModelMaxAggregateInputType = {
    id?: true
    domain?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BanditModelCountAggregateInputType = {
    id?: true
    domain?: true
    version?: true
    weights?: true
    covariance?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BanditModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BanditModel to aggregate.
     */
    where?: BanditModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanditModels to fetch.
     */
    orderBy?: BanditModelOrderByWithRelationInput | BanditModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BanditModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanditModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanditModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BanditModels
    **/
    _count?: true | BanditModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BanditModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BanditModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BanditModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BanditModelMaxAggregateInputType
  }

  export type GetBanditModelAggregateType<T extends BanditModelAggregateArgs> = {
        [P in keyof T & keyof AggregateBanditModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanditModel[P]>
      : GetScalarType<T[P], AggregateBanditModel[P]>
  }




  export type BanditModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BanditModelWhereInput
    orderBy?: BanditModelOrderByWithAggregationInput | BanditModelOrderByWithAggregationInput[]
    by: BanditModelScalarFieldEnum[] | BanditModelScalarFieldEnum
    having?: BanditModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BanditModelCountAggregateInputType | true
    _avg?: BanditModelAvgAggregateInputType
    _sum?: BanditModelSumAggregateInputType
    _min?: BanditModelMinAggregateInputType
    _max?: BanditModelMaxAggregateInputType
  }

  export type BanditModelGroupByOutputType = {
    id: string
    domain: string
    version: number
    weights: JsonValue
    covariance: JsonValue
    meta: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: BanditModelCountAggregateOutputType | null
    _avg: BanditModelAvgAggregateOutputType | null
    _sum: BanditModelSumAggregateOutputType | null
    _min: BanditModelMinAggregateOutputType | null
    _max: BanditModelMaxAggregateOutputType | null
  }

  type GetBanditModelGroupByPayload<T extends BanditModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BanditModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BanditModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BanditModelGroupByOutputType[P]>
            : GetScalarType<T[P], BanditModelGroupByOutputType[P]>
        }
      >
    >


  export type BanditModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    version?: boolean
    weights?: boolean
    covariance?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banditModel"]>

  export type BanditModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domain?: boolean
    version?: boolean
    weights?: boolean
    covariance?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["banditModel"]>

  export type BanditModelSelectScalar = {
    id?: boolean
    domain?: boolean
    version?: boolean
    weights?: boolean
    covariance?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $BanditModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BanditModel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domain: string
      version: number
      weights: Prisma.JsonValue
      covariance: Prisma.JsonValue
      meta: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["banditModel"]>
    composites: {}
  }

  type BanditModelGetPayload<S extends boolean | null | undefined | BanditModelDefaultArgs> = $Result.GetResult<Prisma.$BanditModelPayload, S>

  type BanditModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BanditModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BanditModelCountAggregateInputType | true
    }

  export interface BanditModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BanditModel'], meta: { name: 'BanditModel' } }
    /**
     * Find zero or one BanditModel that matches the filter.
     * @param {BanditModelFindUniqueArgs} args - Arguments to find a BanditModel
     * @example
     * // Get one BanditModel
     * const banditModel = await prisma.banditModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BanditModelFindUniqueArgs>(args: SelectSubset<T, BanditModelFindUniqueArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BanditModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BanditModelFindUniqueOrThrowArgs} args - Arguments to find a BanditModel
     * @example
     * // Get one BanditModel
     * const banditModel = await prisma.banditModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BanditModelFindUniqueOrThrowArgs>(args: SelectSubset<T, BanditModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BanditModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelFindFirstArgs} args - Arguments to find a BanditModel
     * @example
     * // Get one BanditModel
     * const banditModel = await prisma.banditModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BanditModelFindFirstArgs>(args?: SelectSubset<T, BanditModelFindFirstArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BanditModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelFindFirstOrThrowArgs} args - Arguments to find a BanditModel
     * @example
     * // Get one BanditModel
     * const banditModel = await prisma.banditModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BanditModelFindFirstOrThrowArgs>(args?: SelectSubset<T, BanditModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BanditModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BanditModels
     * const banditModels = await prisma.banditModel.findMany()
     * 
     * // Get first 10 BanditModels
     * const banditModels = await prisma.banditModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const banditModelWithIdOnly = await prisma.banditModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BanditModelFindManyArgs>(args?: SelectSubset<T, BanditModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BanditModel.
     * @param {BanditModelCreateArgs} args - Arguments to create a BanditModel.
     * @example
     * // Create one BanditModel
     * const BanditModel = await prisma.banditModel.create({
     *   data: {
     *     // ... data to create a BanditModel
     *   }
     * })
     * 
     */
    create<T extends BanditModelCreateArgs>(args: SelectSubset<T, BanditModelCreateArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BanditModels.
     * @param {BanditModelCreateManyArgs} args - Arguments to create many BanditModels.
     * @example
     * // Create many BanditModels
     * const banditModel = await prisma.banditModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BanditModelCreateManyArgs>(args?: SelectSubset<T, BanditModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BanditModels and returns the data saved in the database.
     * @param {BanditModelCreateManyAndReturnArgs} args - Arguments to create many BanditModels.
     * @example
     * // Create many BanditModels
     * const banditModel = await prisma.banditModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BanditModels and only return the `id`
     * const banditModelWithIdOnly = await prisma.banditModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BanditModelCreateManyAndReturnArgs>(args?: SelectSubset<T, BanditModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BanditModel.
     * @param {BanditModelDeleteArgs} args - Arguments to delete one BanditModel.
     * @example
     * // Delete one BanditModel
     * const BanditModel = await prisma.banditModel.delete({
     *   where: {
     *     // ... filter to delete one BanditModel
     *   }
     * })
     * 
     */
    delete<T extends BanditModelDeleteArgs>(args: SelectSubset<T, BanditModelDeleteArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BanditModel.
     * @param {BanditModelUpdateArgs} args - Arguments to update one BanditModel.
     * @example
     * // Update one BanditModel
     * const banditModel = await prisma.banditModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BanditModelUpdateArgs>(args: SelectSubset<T, BanditModelUpdateArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BanditModels.
     * @param {BanditModelDeleteManyArgs} args - Arguments to filter BanditModels to delete.
     * @example
     * // Delete a few BanditModels
     * const { count } = await prisma.banditModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BanditModelDeleteManyArgs>(args?: SelectSubset<T, BanditModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BanditModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BanditModels
     * const banditModel = await prisma.banditModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BanditModelUpdateManyArgs>(args: SelectSubset<T, BanditModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BanditModel.
     * @param {BanditModelUpsertArgs} args - Arguments to update or create a BanditModel.
     * @example
     * // Update or create a BanditModel
     * const banditModel = await prisma.banditModel.upsert({
     *   create: {
     *     // ... data to create a BanditModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BanditModel we want to update
     *   }
     * })
     */
    upsert<T extends BanditModelUpsertArgs>(args: SelectSubset<T, BanditModelUpsertArgs<ExtArgs>>): Prisma__BanditModelClient<$Result.GetResult<Prisma.$BanditModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BanditModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelCountArgs} args - Arguments to filter BanditModels to count.
     * @example
     * // Count the number of BanditModels
     * const count = await prisma.banditModel.count({
     *   where: {
     *     // ... the filter for the BanditModels we want to count
     *   }
     * })
    **/
    count<T extends BanditModelCountArgs>(
      args?: Subset<T, BanditModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BanditModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BanditModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BanditModelAggregateArgs>(args: Subset<T, BanditModelAggregateArgs>): Prisma.PrismaPromise<GetBanditModelAggregateType<T>>

    /**
     * Group by BanditModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BanditModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BanditModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BanditModelGroupByArgs['orderBy'] }
        : { orderBy?: BanditModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BanditModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBanditModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BanditModel model
   */
  readonly fields: BanditModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BanditModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BanditModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BanditModel model
   */ 
  interface BanditModelFieldRefs {
    readonly id: FieldRef<"BanditModel", 'String'>
    readonly domain: FieldRef<"BanditModel", 'String'>
    readonly version: FieldRef<"BanditModel", 'Int'>
    readonly weights: FieldRef<"BanditModel", 'Json'>
    readonly covariance: FieldRef<"BanditModel", 'Json'>
    readonly meta: FieldRef<"BanditModel", 'Json'>
    readonly createdAt: FieldRef<"BanditModel", 'DateTime'>
    readonly updatedAt: FieldRef<"BanditModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BanditModel findUnique
   */
  export type BanditModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * Filter, which BanditModel to fetch.
     */
    where: BanditModelWhereUniqueInput
  }

  /**
   * BanditModel findUniqueOrThrow
   */
  export type BanditModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * Filter, which BanditModel to fetch.
     */
    where: BanditModelWhereUniqueInput
  }

  /**
   * BanditModel findFirst
   */
  export type BanditModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * Filter, which BanditModel to fetch.
     */
    where?: BanditModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanditModels to fetch.
     */
    orderBy?: BanditModelOrderByWithRelationInput | BanditModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BanditModels.
     */
    cursor?: BanditModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanditModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanditModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BanditModels.
     */
    distinct?: BanditModelScalarFieldEnum | BanditModelScalarFieldEnum[]
  }

  /**
   * BanditModel findFirstOrThrow
   */
  export type BanditModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * Filter, which BanditModel to fetch.
     */
    where?: BanditModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanditModels to fetch.
     */
    orderBy?: BanditModelOrderByWithRelationInput | BanditModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BanditModels.
     */
    cursor?: BanditModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanditModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanditModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BanditModels.
     */
    distinct?: BanditModelScalarFieldEnum | BanditModelScalarFieldEnum[]
  }

  /**
   * BanditModel findMany
   */
  export type BanditModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * Filter, which BanditModels to fetch.
     */
    where?: BanditModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BanditModels to fetch.
     */
    orderBy?: BanditModelOrderByWithRelationInput | BanditModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BanditModels.
     */
    cursor?: BanditModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BanditModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BanditModels.
     */
    skip?: number
    distinct?: BanditModelScalarFieldEnum | BanditModelScalarFieldEnum[]
  }

  /**
   * BanditModel create
   */
  export type BanditModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * The data needed to create a BanditModel.
     */
    data: XOR<BanditModelCreateInput, BanditModelUncheckedCreateInput>
  }

  /**
   * BanditModel createMany
   */
  export type BanditModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BanditModels.
     */
    data: BanditModelCreateManyInput | BanditModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BanditModel createManyAndReturn
   */
  export type BanditModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BanditModels.
     */
    data: BanditModelCreateManyInput | BanditModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BanditModel update
   */
  export type BanditModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * The data needed to update a BanditModel.
     */
    data: XOR<BanditModelUpdateInput, BanditModelUncheckedUpdateInput>
    /**
     * Choose, which BanditModel to update.
     */
    where: BanditModelWhereUniqueInput
  }

  /**
   * BanditModel updateMany
   */
  export type BanditModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BanditModels.
     */
    data: XOR<BanditModelUpdateManyMutationInput, BanditModelUncheckedUpdateManyInput>
    /**
     * Filter which BanditModels to update
     */
    where?: BanditModelWhereInput
  }

  /**
   * BanditModel upsert
   */
  export type BanditModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * The filter to search for the BanditModel to update in case it exists.
     */
    where: BanditModelWhereUniqueInput
    /**
     * In case the BanditModel found by the `where` argument doesn't exist, create a new BanditModel with this data.
     */
    create: XOR<BanditModelCreateInput, BanditModelUncheckedCreateInput>
    /**
     * In case the BanditModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BanditModelUpdateInput, BanditModelUncheckedUpdateInput>
  }

  /**
   * BanditModel delete
   */
  export type BanditModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
    /**
     * Filter which BanditModel to delete.
     */
    where: BanditModelWhereUniqueInput
  }

  /**
   * BanditModel deleteMany
   */
  export type BanditModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BanditModels to delete
     */
    where?: BanditModelWhereInput
  }

  /**
   * BanditModel without action
   */
  export type BanditModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BanditModel
     */
    select?: BanditModelSelect<ExtArgs> | null
  }


  /**
   * Model UserTypeEstimate
   */

  export type AggregateUserTypeEstimate = {
    _count: UserTypeEstimateCountAggregateOutputType | null
    _avg: UserTypeEstimateAvgAggregateOutputType | null
    _sum: UserTypeEstimateSumAggregateOutputType | null
    _min: UserTypeEstimateMinAggregateOutputType | null
    _max: UserTypeEstimateMaxAggregateOutputType | null
  }

  export type UserTypeEstimateAvgAggregateOutputType = {
    confidence: Decimal | null
  }

  export type UserTypeEstimateSumAggregateOutputType = {
    confidence: Decimal | null
  }

  export type UserTypeEstimateMinAggregateOutputType = {
    userId: string | null
    primaryType: string | null
    confidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTypeEstimateMaxAggregateOutputType = {
    userId: string | null
    primaryType: string | null
    confidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserTypeEstimateCountAggregateOutputType = {
    userId: number
    primaryType: number
    typeScores: number
    confidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserTypeEstimateAvgAggregateInputType = {
    confidence?: true
  }

  export type UserTypeEstimateSumAggregateInputType = {
    confidence?: true
  }

  export type UserTypeEstimateMinAggregateInputType = {
    userId?: true
    primaryType?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTypeEstimateMaxAggregateInputType = {
    userId?: true
    primaryType?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserTypeEstimateCountAggregateInputType = {
    userId?: true
    primaryType?: true
    typeScores?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserTypeEstimateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTypeEstimate to aggregate.
     */
    where?: UserTypeEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTypeEstimates to fetch.
     */
    orderBy?: UserTypeEstimateOrderByWithRelationInput | UserTypeEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTypeEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTypeEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTypeEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTypeEstimates
    **/
    _count?: true | UserTypeEstimateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTypeEstimateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTypeEstimateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTypeEstimateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTypeEstimateMaxAggregateInputType
  }

  export type GetUserTypeEstimateAggregateType<T extends UserTypeEstimateAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTypeEstimate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTypeEstimate[P]>
      : GetScalarType<T[P], AggregateUserTypeEstimate[P]>
  }




  export type UserTypeEstimateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTypeEstimateWhereInput
    orderBy?: UserTypeEstimateOrderByWithAggregationInput | UserTypeEstimateOrderByWithAggregationInput[]
    by: UserTypeEstimateScalarFieldEnum[] | UserTypeEstimateScalarFieldEnum
    having?: UserTypeEstimateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTypeEstimateCountAggregateInputType | true
    _avg?: UserTypeEstimateAvgAggregateInputType
    _sum?: UserTypeEstimateSumAggregateInputType
    _min?: UserTypeEstimateMinAggregateInputType
    _max?: UserTypeEstimateMaxAggregateInputType
  }

  export type UserTypeEstimateGroupByOutputType = {
    userId: string
    primaryType: string
    typeScores: JsonValue
    confidence: Decimal
    createdAt: Date
    updatedAt: Date
    _count: UserTypeEstimateCountAggregateOutputType | null
    _avg: UserTypeEstimateAvgAggregateOutputType | null
    _sum: UserTypeEstimateSumAggregateOutputType | null
    _min: UserTypeEstimateMinAggregateOutputType | null
    _max: UserTypeEstimateMaxAggregateOutputType | null
  }

  type GetUserTypeEstimateGroupByPayload<T extends UserTypeEstimateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTypeEstimateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTypeEstimateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTypeEstimateGroupByOutputType[P]>
            : GetScalarType<T[P], UserTypeEstimateGroupByOutputType[P]>
        }
      >
    >


  export type UserTypeEstimateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    primaryType?: boolean
    typeScores?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTypeEstimate"]>

  export type UserTypeEstimateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    primaryType?: boolean
    typeScores?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTypeEstimate"]>

  export type UserTypeEstimateSelectScalar = {
    userId?: boolean
    primaryType?: boolean
    typeScores?: boolean
    confidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserTypeEstimateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type UserTypeEstimateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $UserTypeEstimatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTypeEstimate"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      primaryType: string
      typeScores: Prisma.JsonValue
      confidence: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userTypeEstimate"]>
    composites: {}
  }

  type UserTypeEstimateGetPayload<S extends boolean | null | undefined | UserTypeEstimateDefaultArgs> = $Result.GetResult<Prisma.$UserTypeEstimatePayload, S>

  type UserTypeEstimateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTypeEstimateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTypeEstimateCountAggregateInputType | true
    }

  export interface UserTypeEstimateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTypeEstimate'], meta: { name: 'UserTypeEstimate' } }
    /**
     * Find zero or one UserTypeEstimate that matches the filter.
     * @param {UserTypeEstimateFindUniqueArgs} args - Arguments to find a UserTypeEstimate
     * @example
     * // Get one UserTypeEstimate
     * const userTypeEstimate = await prisma.userTypeEstimate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTypeEstimateFindUniqueArgs>(args: SelectSubset<T, UserTypeEstimateFindUniqueArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTypeEstimate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTypeEstimateFindUniqueOrThrowArgs} args - Arguments to find a UserTypeEstimate
     * @example
     * // Get one UserTypeEstimate
     * const userTypeEstimate = await prisma.userTypeEstimate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTypeEstimateFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTypeEstimateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTypeEstimate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateFindFirstArgs} args - Arguments to find a UserTypeEstimate
     * @example
     * // Get one UserTypeEstimate
     * const userTypeEstimate = await prisma.userTypeEstimate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTypeEstimateFindFirstArgs>(args?: SelectSubset<T, UserTypeEstimateFindFirstArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTypeEstimate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateFindFirstOrThrowArgs} args - Arguments to find a UserTypeEstimate
     * @example
     * // Get one UserTypeEstimate
     * const userTypeEstimate = await prisma.userTypeEstimate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTypeEstimateFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTypeEstimateFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTypeEstimates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTypeEstimates
     * const userTypeEstimates = await prisma.userTypeEstimate.findMany()
     * 
     * // Get first 10 UserTypeEstimates
     * const userTypeEstimates = await prisma.userTypeEstimate.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userTypeEstimateWithUserIdOnly = await prisma.userTypeEstimate.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserTypeEstimateFindManyArgs>(args?: SelectSubset<T, UserTypeEstimateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTypeEstimate.
     * @param {UserTypeEstimateCreateArgs} args - Arguments to create a UserTypeEstimate.
     * @example
     * // Create one UserTypeEstimate
     * const UserTypeEstimate = await prisma.userTypeEstimate.create({
     *   data: {
     *     // ... data to create a UserTypeEstimate
     *   }
     * })
     * 
     */
    create<T extends UserTypeEstimateCreateArgs>(args: SelectSubset<T, UserTypeEstimateCreateArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTypeEstimates.
     * @param {UserTypeEstimateCreateManyArgs} args - Arguments to create many UserTypeEstimates.
     * @example
     * // Create many UserTypeEstimates
     * const userTypeEstimate = await prisma.userTypeEstimate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTypeEstimateCreateManyArgs>(args?: SelectSubset<T, UserTypeEstimateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserTypeEstimates and returns the data saved in the database.
     * @param {UserTypeEstimateCreateManyAndReturnArgs} args - Arguments to create many UserTypeEstimates.
     * @example
     * // Create many UserTypeEstimates
     * const userTypeEstimate = await prisma.userTypeEstimate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserTypeEstimates and only return the `userId`
     * const userTypeEstimateWithUserIdOnly = await prisma.userTypeEstimate.createManyAndReturn({ 
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserTypeEstimateCreateManyAndReturnArgs>(args?: SelectSubset<T, UserTypeEstimateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserTypeEstimate.
     * @param {UserTypeEstimateDeleteArgs} args - Arguments to delete one UserTypeEstimate.
     * @example
     * // Delete one UserTypeEstimate
     * const UserTypeEstimate = await prisma.userTypeEstimate.delete({
     *   where: {
     *     // ... filter to delete one UserTypeEstimate
     *   }
     * })
     * 
     */
    delete<T extends UserTypeEstimateDeleteArgs>(args: SelectSubset<T, UserTypeEstimateDeleteArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTypeEstimate.
     * @param {UserTypeEstimateUpdateArgs} args - Arguments to update one UserTypeEstimate.
     * @example
     * // Update one UserTypeEstimate
     * const userTypeEstimate = await prisma.userTypeEstimate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTypeEstimateUpdateArgs>(args: SelectSubset<T, UserTypeEstimateUpdateArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTypeEstimates.
     * @param {UserTypeEstimateDeleteManyArgs} args - Arguments to filter UserTypeEstimates to delete.
     * @example
     * // Delete a few UserTypeEstimates
     * const { count } = await prisma.userTypeEstimate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTypeEstimateDeleteManyArgs>(args?: SelectSubset<T, UserTypeEstimateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTypeEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTypeEstimates
     * const userTypeEstimate = await prisma.userTypeEstimate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTypeEstimateUpdateManyArgs>(args: SelectSubset<T, UserTypeEstimateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTypeEstimate.
     * @param {UserTypeEstimateUpsertArgs} args - Arguments to update or create a UserTypeEstimate.
     * @example
     * // Update or create a UserTypeEstimate
     * const userTypeEstimate = await prisma.userTypeEstimate.upsert({
     *   create: {
     *     // ... data to create a UserTypeEstimate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTypeEstimate we want to update
     *   }
     * })
     */
    upsert<T extends UserTypeEstimateUpsertArgs>(args: SelectSubset<T, UserTypeEstimateUpsertArgs<ExtArgs>>): Prisma__UserTypeEstimateClient<$Result.GetResult<Prisma.$UserTypeEstimatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTypeEstimates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateCountArgs} args - Arguments to filter UserTypeEstimates to count.
     * @example
     * // Count the number of UserTypeEstimates
     * const count = await prisma.userTypeEstimate.count({
     *   where: {
     *     // ... the filter for the UserTypeEstimates we want to count
     *   }
     * })
    **/
    count<T extends UserTypeEstimateCountArgs>(
      args?: Subset<T, UserTypeEstimateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTypeEstimateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTypeEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTypeEstimateAggregateArgs>(args: Subset<T, UserTypeEstimateAggregateArgs>): Prisma.PrismaPromise<GetUserTypeEstimateAggregateType<T>>

    /**
     * Group by UserTypeEstimate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTypeEstimateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTypeEstimateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTypeEstimateGroupByArgs['orderBy'] }
        : { orderBy?: UserTypeEstimateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTypeEstimateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTypeEstimateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTypeEstimate model
   */
  readonly fields: UserTypeEstimateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTypeEstimate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTypeEstimateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTypeEstimate model
   */ 
  interface UserTypeEstimateFieldRefs {
    readonly userId: FieldRef<"UserTypeEstimate", 'String'>
    readonly primaryType: FieldRef<"UserTypeEstimate", 'String'>
    readonly typeScores: FieldRef<"UserTypeEstimate", 'Json'>
    readonly confidence: FieldRef<"UserTypeEstimate", 'Decimal'>
    readonly createdAt: FieldRef<"UserTypeEstimate", 'DateTime'>
    readonly updatedAt: FieldRef<"UserTypeEstimate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserTypeEstimate findUnique
   */
  export type UserTypeEstimateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * Filter, which UserTypeEstimate to fetch.
     */
    where: UserTypeEstimateWhereUniqueInput
  }

  /**
   * UserTypeEstimate findUniqueOrThrow
   */
  export type UserTypeEstimateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * Filter, which UserTypeEstimate to fetch.
     */
    where: UserTypeEstimateWhereUniqueInput
  }

  /**
   * UserTypeEstimate findFirst
   */
  export type UserTypeEstimateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * Filter, which UserTypeEstimate to fetch.
     */
    where?: UserTypeEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTypeEstimates to fetch.
     */
    orderBy?: UserTypeEstimateOrderByWithRelationInput | UserTypeEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTypeEstimates.
     */
    cursor?: UserTypeEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTypeEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTypeEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTypeEstimates.
     */
    distinct?: UserTypeEstimateScalarFieldEnum | UserTypeEstimateScalarFieldEnum[]
  }

  /**
   * UserTypeEstimate findFirstOrThrow
   */
  export type UserTypeEstimateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * Filter, which UserTypeEstimate to fetch.
     */
    where?: UserTypeEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTypeEstimates to fetch.
     */
    orderBy?: UserTypeEstimateOrderByWithRelationInput | UserTypeEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTypeEstimates.
     */
    cursor?: UserTypeEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTypeEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTypeEstimates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTypeEstimates.
     */
    distinct?: UserTypeEstimateScalarFieldEnum | UserTypeEstimateScalarFieldEnum[]
  }

  /**
   * UserTypeEstimate findMany
   */
  export type UserTypeEstimateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * Filter, which UserTypeEstimates to fetch.
     */
    where?: UserTypeEstimateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTypeEstimates to fetch.
     */
    orderBy?: UserTypeEstimateOrderByWithRelationInput | UserTypeEstimateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTypeEstimates.
     */
    cursor?: UserTypeEstimateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTypeEstimates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTypeEstimates.
     */
    skip?: number
    distinct?: UserTypeEstimateScalarFieldEnum | UserTypeEstimateScalarFieldEnum[]
  }

  /**
   * UserTypeEstimate create
   */
  export type UserTypeEstimateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTypeEstimate.
     */
    data: XOR<UserTypeEstimateCreateInput, UserTypeEstimateUncheckedCreateInput>
  }

  /**
   * UserTypeEstimate createMany
   */
  export type UserTypeEstimateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTypeEstimates.
     */
    data: UserTypeEstimateCreateManyInput | UserTypeEstimateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTypeEstimate createManyAndReturn
   */
  export type UserTypeEstimateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserTypeEstimates.
     */
    data: UserTypeEstimateCreateManyInput | UserTypeEstimateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserTypeEstimate update
   */
  export type UserTypeEstimateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTypeEstimate.
     */
    data: XOR<UserTypeEstimateUpdateInput, UserTypeEstimateUncheckedUpdateInput>
    /**
     * Choose, which UserTypeEstimate to update.
     */
    where: UserTypeEstimateWhereUniqueInput
  }

  /**
   * UserTypeEstimate updateMany
   */
  export type UserTypeEstimateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTypeEstimates.
     */
    data: XOR<UserTypeEstimateUpdateManyMutationInput, UserTypeEstimateUncheckedUpdateManyInput>
    /**
     * Filter which UserTypeEstimates to update
     */
    where?: UserTypeEstimateWhereInput
  }

  /**
   * UserTypeEstimate upsert
   */
  export type UserTypeEstimateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTypeEstimate to update in case it exists.
     */
    where: UserTypeEstimateWhereUniqueInput
    /**
     * In case the UserTypeEstimate found by the `where` argument doesn't exist, create a new UserTypeEstimate with this data.
     */
    create: XOR<UserTypeEstimateCreateInput, UserTypeEstimateUncheckedCreateInput>
    /**
     * In case the UserTypeEstimate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTypeEstimateUpdateInput, UserTypeEstimateUncheckedUpdateInput>
  }

  /**
   * UserTypeEstimate delete
   */
  export type UserTypeEstimateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
    /**
     * Filter which UserTypeEstimate to delete.
     */
    where: UserTypeEstimateWhereUniqueInput
  }

  /**
   * UserTypeEstimate deleteMany
   */
  export type UserTypeEstimateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTypeEstimates to delete
     */
    where?: UserTypeEstimateWhereInput
  }

  /**
   * UserTypeEstimate without action
   */
  export type UserTypeEstimateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTypeEstimate
     */
    select?: UserTypeEstimateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTypeEstimateInclude<ExtArgs> | null
  }


  /**
   * Model TypeStats
   */

  export type AggregateTypeStats = {
    _count: TypeStatsCountAggregateOutputType | null
    _avg: TypeStatsAvgAggregateOutputType | null
    _sum: TypeStatsSumAggregateOutputType | null
    _min: TypeStatsMinAggregateOutputType | null
    _max: TypeStatsMaxAggregateOutputType | null
  }

  export type TypeStatsAvgAggregateOutputType = {
    tappedCount: number | null
    ignoredCount: number | null
    thumbsUpCount: number | null
    thumbsDownCount: number | null
    sampleSize: number | null
  }

  export type TypeStatsSumAggregateOutputType = {
    tappedCount: bigint | null
    ignoredCount: bigint | null
    thumbsUpCount: bigint | null
    thumbsDownCount: bigint | null
    sampleSize: bigint | null
  }

  export type TypeStatsMinAggregateOutputType = {
    typeId: string | null
    tone: string | null
    tappedCount: bigint | null
    ignoredCount: bigint | null
    thumbsUpCount: bigint | null
    thumbsDownCount: bigint | null
    sampleSize: bigint | null
    updatedAt: Date | null
  }

  export type TypeStatsMaxAggregateOutputType = {
    typeId: string | null
    tone: string | null
    tappedCount: bigint | null
    ignoredCount: bigint | null
    thumbsUpCount: bigint | null
    thumbsDownCount: bigint | null
    sampleSize: bigint | null
    updatedAt: Date | null
  }

  export type TypeStatsCountAggregateOutputType = {
    typeId: number
    tone: number
    tappedCount: number
    ignoredCount: number
    thumbsUpCount: number
    thumbsDownCount: number
    sampleSize: number
    updatedAt: number
    _all: number
  }


  export type TypeStatsAvgAggregateInputType = {
    tappedCount?: true
    ignoredCount?: true
    thumbsUpCount?: true
    thumbsDownCount?: true
    sampleSize?: true
  }

  export type TypeStatsSumAggregateInputType = {
    tappedCount?: true
    ignoredCount?: true
    thumbsUpCount?: true
    thumbsDownCount?: true
    sampleSize?: true
  }

  export type TypeStatsMinAggregateInputType = {
    typeId?: true
    tone?: true
    tappedCount?: true
    ignoredCount?: true
    thumbsUpCount?: true
    thumbsDownCount?: true
    sampleSize?: true
    updatedAt?: true
  }

  export type TypeStatsMaxAggregateInputType = {
    typeId?: true
    tone?: true
    tappedCount?: true
    ignoredCount?: true
    thumbsUpCount?: true
    thumbsDownCount?: true
    sampleSize?: true
    updatedAt?: true
  }

  export type TypeStatsCountAggregateInputType = {
    typeId?: true
    tone?: true
    tappedCount?: true
    ignoredCount?: true
    thumbsUpCount?: true
    thumbsDownCount?: true
    sampleSize?: true
    updatedAt?: true
    _all?: true
  }

  export type TypeStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeStats to aggregate.
     */
    where?: TypeStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeStats to fetch.
     */
    orderBy?: TypeStatsOrderByWithRelationInput | TypeStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypeStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypeStats
    **/
    _count?: true | TypeStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TypeStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TypeStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypeStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypeStatsMaxAggregateInputType
  }

  export type GetTypeStatsAggregateType<T extends TypeStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateTypeStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypeStats[P]>
      : GetScalarType<T[P], AggregateTypeStats[P]>
  }




  export type TypeStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypeStatsWhereInput
    orderBy?: TypeStatsOrderByWithAggregationInput | TypeStatsOrderByWithAggregationInput[]
    by: TypeStatsScalarFieldEnum[] | TypeStatsScalarFieldEnum
    having?: TypeStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypeStatsCountAggregateInputType | true
    _avg?: TypeStatsAvgAggregateInputType
    _sum?: TypeStatsSumAggregateInputType
    _min?: TypeStatsMinAggregateInputType
    _max?: TypeStatsMaxAggregateInputType
  }

  export type TypeStatsGroupByOutputType = {
    typeId: string
    tone: string
    tappedCount: bigint
    ignoredCount: bigint
    thumbsUpCount: bigint
    thumbsDownCount: bigint
    sampleSize: bigint
    updatedAt: Date
    _count: TypeStatsCountAggregateOutputType | null
    _avg: TypeStatsAvgAggregateOutputType | null
    _sum: TypeStatsSumAggregateOutputType | null
    _min: TypeStatsMinAggregateOutputType | null
    _max: TypeStatsMaxAggregateOutputType | null
  }

  type GetTypeStatsGroupByPayload<T extends TypeStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypeStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypeStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypeStatsGroupByOutputType[P]>
            : GetScalarType<T[P], TypeStatsGroupByOutputType[P]>
        }
      >
    >


  export type TypeStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeId?: boolean
    tone?: boolean
    tappedCount?: boolean
    ignoredCount?: boolean
    thumbsUpCount?: boolean
    thumbsDownCount?: boolean
    sampleSize?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["typeStats"]>

  export type TypeStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    typeId?: boolean
    tone?: boolean
    tappedCount?: boolean
    ignoredCount?: boolean
    thumbsUpCount?: boolean
    thumbsDownCount?: boolean
    sampleSize?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["typeStats"]>

  export type TypeStatsSelectScalar = {
    typeId?: boolean
    tone?: boolean
    tappedCount?: boolean
    ignoredCount?: boolean
    thumbsUpCount?: boolean
    thumbsDownCount?: boolean
    sampleSize?: boolean
    updatedAt?: boolean
  }


  export type $TypeStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypeStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      typeId: string
      tone: string
      tappedCount: bigint
      ignoredCount: bigint
      thumbsUpCount: bigint
      thumbsDownCount: bigint
      sampleSize: bigint
      updatedAt: Date
    }, ExtArgs["result"]["typeStats"]>
    composites: {}
  }

  type TypeStatsGetPayload<S extends boolean | null | undefined | TypeStatsDefaultArgs> = $Result.GetResult<Prisma.$TypeStatsPayload, S>

  type TypeStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TypeStatsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TypeStatsCountAggregateInputType | true
    }

  export interface TypeStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypeStats'], meta: { name: 'TypeStats' } }
    /**
     * Find zero or one TypeStats that matches the filter.
     * @param {TypeStatsFindUniqueArgs} args - Arguments to find a TypeStats
     * @example
     * // Get one TypeStats
     * const typeStats = await prisma.typeStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TypeStatsFindUniqueArgs>(args: SelectSubset<T, TypeStatsFindUniqueArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TypeStats that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TypeStatsFindUniqueOrThrowArgs} args - Arguments to find a TypeStats
     * @example
     * // Get one TypeStats
     * const typeStats = await prisma.typeStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TypeStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, TypeStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TypeStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsFindFirstArgs} args - Arguments to find a TypeStats
     * @example
     * // Get one TypeStats
     * const typeStats = await prisma.typeStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TypeStatsFindFirstArgs>(args?: SelectSubset<T, TypeStatsFindFirstArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TypeStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsFindFirstOrThrowArgs} args - Arguments to find a TypeStats
     * @example
     * // Get one TypeStats
     * const typeStats = await prisma.typeStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TypeStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, TypeStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TypeStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypeStats
     * const typeStats = await prisma.typeStats.findMany()
     * 
     * // Get first 10 TypeStats
     * const typeStats = await prisma.typeStats.findMany({ take: 10 })
     * 
     * // Only select the `typeId`
     * const typeStatsWithTypeIdOnly = await prisma.typeStats.findMany({ select: { typeId: true } })
     * 
     */
    findMany<T extends TypeStatsFindManyArgs>(args?: SelectSubset<T, TypeStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TypeStats.
     * @param {TypeStatsCreateArgs} args - Arguments to create a TypeStats.
     * @example
     * // Create one TypeStats
     * const TypeStats = await prisma.typeStats.create({
     *   data: {
     *     // ... data to create a TypeStats
     *   }
     * })
     * 
     */
    create<T extends TypeStatsCreateArgs>(args: SelectSubset<T, TypeStatsCreateArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TypeStats.
     * @param {TypeStatsCreateManyArgs} args - Arguments to create many TypeStats.
     * @example
     * // Create many TypeStats
     * const typeStats = await prisma.typeStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TypeStatsCreateManyArgs>(args?: SelectSubset<T, TypeStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TypeStats and returns the data saved in the database.
     * @param {TypeStatsCreateManyAndReturnArgs} args - Arguments to create many TypeStats.
     * @example
     * // Create many TypeStats
     * const typeStats = await prisma.typeStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TypeStats and only return the `typeId`
     * const typeStatsWithTypeIdOnly = await prisma.typeStats.createManyAndReturn({ 
     *   select: { typeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TypeStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, TypeStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TypeStats.
     * @param {TypeStatsDeleteArgs} args - Arguments to delete one TypeStats.
     * @example
     * // Delete one TypeStats
     * const TypeStats = await prisma.typeStats.delete({
     *   where: {
     *     // ... filter to delete one TypeStats
     *   }
     * })
     * 
     */
    delete<T extends TypeStatsDeleteArgs>(args: SelectSubset<T, TypeStatsDeleteArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TypeStats.
     * @param {TypeStatsUpdateArgs} args - Arguments to update one TypeStats.
     * @example
     * // Update one TypeStats
     * const typeStats = await prisma.typeStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TypeStatsUpdateArgs>(args: SelectSubset<T, TypeStatsUpdateArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TypeStats.
     * @param {TypeStatsDeleteManyArgs} args - Arguments to filter TypeStats to delete.
     * @example
     * // Delete a few TypeStats
     * const { count } = await prisma.typeStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TypeStatsDeleteManyArgs>(args?: SelectSubset<T, TypeStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypeStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypeStats
     * const typeStats = await prisma.typeStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TypeStatsUpdateManyArgs>(args: SelectSubset<T, TypeStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypeStats.
     * @param {TypeStatsUpsertArgs} args - Arguments to update or create a TypeStats.
     * @example
     * // Update or create a TypeStats
     * const typeStats = await prisma.typeStats.upsert({
     *   create: {
     *     // ... data to create a TypeStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypeStats we want to update
     *   }
     * })
     */
    upsert<T extends TypeStatsUpsertArgs>(args: SelectSubset<T, TypeStatsUpsertArgs<ExtArgs>>): Prisma__TypeStatsClient<$Result.GetResult<Prisma.$TypeStatsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TypeStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsCountArgs} args - Arguments to filter TypeStats to count.
     * @example
     * // Count the number of TypeStats
     * const count = await prisma.typeStats.count({
     *   where: {
     *     // ... the filter for the TypeStats we want to count
     *   }
     * })
    **/
    count<T extends TypeStatsCountArgs>(
      args?: Subset<T, TypeStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypeStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypeStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypeStatsAggregateArgs>(args: Subset<T, TypeStatsAggregateArgs>): Prisma.PrismaPromise<GetTypeStatsAggregateType<T>>

    /**
     * Group by TypeStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypeStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypeStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypeStatsGroupByArgs['orderBy'] }
        : { orderBy?: TypeStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypeStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypeStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypeStats model
   */
  readonly fields: TypeStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypeStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypeStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TypeStats model
   */ 
  interface TypeStatsFieldRefs {
    readonly typeId: FieldRef<"TypeStats", 'String'>
    readonly tone: FieldRef<"TypeStats", 'String'>
    readonly tappedCount: FieldRef<"TypeStats", 'BigInt'>
    readonly ignoredCount: FieldRef<"TypeStats", 'BigInt'>
    readonly thumbsUpCount: FieldRef<"TypeStats", 'BigInt'>
    readonly thumbsDownCount: FieldRef<"TypeStats", 'BigInt'>
    readonly sampleSize: FieldRef<"TypeStats", 'BigInt'>
    readonly updatedAt: FieldRef<"TypeStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TypeStats findUnique
   */
  export type TypeStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * Filter, which TypeStats to fetch.
     */
    where: TypeStatsWhereUniqueInput
  }

  /**
   * TypeStats findUniqueOrThrow
   */
  export type TypeStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * Filter, which TypeStats to fetch.
     */
    where: TypeStatsWhereUniqueInput
  }

  /**
   * TypeStats findFirst
   */
  export type TypeStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * Filter, which TypeStats to fetch.
     */
    where?: TypeStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeStats to fetch.
     */
    orderBy?: TypeStatsOrderByWithRelationInput | TypeStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeStats.
     */
    cursor?: TypeStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeStats.
     */
    distinct?: TypeStatsScalarFieldEnum | TypeStatsScalarFieldEnum[]
  }

  /**
   * TypeStats findFirstOrThrow
   */
  export type TypeStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * Filter, which TypeStats to fetch.
     */
    where?: TypeStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeStats to fetch.
     */
    orderBy?: TypeStatsOrderByWithRelationInput | TypeStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypeStats.
     */
    cursor?: TypeStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypeStats.
     */
    distinct?: TypeStatsScalarFieldEnum | TypeStatsScalarFieldEnum[]
  }

  /**
   * TypeStats findMany
   */
  export type TypeStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * Filter, which TypeStats to fetch.
     */
    where?: TypeStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypeStats to fetch.
     */
    orderBy?: TypeStatsOrderByWithRelationInput | TypeStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypeStats.
     */
    cursor?: TypeStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypeStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypeStats.
     */
    skip?: number
    distinct?: TypeStatsScalarFieldEnum | TypeStatsScalarFieldEnum[]
  }

  /**
   * TypeStats create
   */
  export type TypeStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * The data needed to create a TypeStats.
     */
    data: XOR<TypeStatsCreateInput, TypeStatsUncheckedCreateInput>
  }

  /**
   * TypeStats createMany
   */
  export type TypeStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypeStats.
     */
    data: TypeStatsCreateManyInput | TypeStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeStats createManyAndReturn
   */
  export type TypeStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TypeStats.
     */
    data: TypeStatsCreateManyInput | TypeStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypeStats update
   */
  export type TypeStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * The data needed to update a TypeStats.
     */
    data: XOR<TypeStatsUpdateInput, TypeStatsUncheckedUpdateInput>
    /**
     * Choose, which TypeStats to update.
     */
    where: TypeStatsWhereUniqueInput
  }

  /**
   * TypeStats updateMany
   */
  export type TypeStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypeStats.
     */
    data: XOR<TypeStatsUpdateManyMutationInput, TypeStatsUncheckedUpdateManyInput>
    /**
     * Filter which TypeStats to update
     */
    where?: TypeStatsWhereInput
  }

  /**
   * TypeStats upsert
   */
  export type TypeStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * The filter to search for the TypeStats to update in case it exists.
     */
    where: TypeStatsWhereUniqueInput
    /**
     * In case the TypeStats found by the `where` argument doesn't exist, create a new TypeStats with this data.
     */
    create: XOR<TypeStatsCreateInput, TypeStatsUncheckedCreateInput>
    /**
     * In case the TypeStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypeStatsUpdateInput, TypeStatsUncheckedUpdateInput>
  }

  /**
   * TypeStats delete
   */
  export type TypeStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
    /**
     * Filter which TypeStats to delete.
     */
    where: TypeStatsWhereUniqueInput
  }

  /**
   * TypeStats deleteMany
   */
  export type TypeStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypeStats to delete
     */
    where?: TypeStatsWhereInput
  }

  /**
   * TypeStats without action
   */
  export type TypeStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypeStats
     */
    select?: TypeStatsSelect<ExtArgs> | null
  }


  /**
   * Model HookCandidate
   */

  export type AggregateHookCandidate = {
    _count: HookCandidateCountAggregateOutputType | null
    _avg: HookCandidateAvgAggregateOutputType | null
    _sum: HookCandidateSumAggregateOutputType | null
    _min: HookCandidateMinAggregateOutputType | null
    _max: HookCandidateMaxAggregateOutputType | null
  }

  export type HookCandidateAvgAggregateOutputType = {
    appTapRate: Decimal | null
    appThumbsUpRate: Decimal | null
    appSampleSize: number | null
    tiktokLikeRate: Decimal | null
    tiktokShareRate: Decimal | null
    tiktokSampleSize: number | null
    explorationWeight: Decimal | null
  }

  export type HookCandidateSumAggregateOutputType = {
    appTapRate: Decimal | null
    appThumbsUpRate: Decimal | null
    appSampleSize: number | null
    tiktokLikeRate: Decimal | null
    tiktokShareRate: Decimal | null
    tiktokSampleSize: number | null
    explorationWeight: Decimal | null
  }

  export type HookCandidateMinAggregateOutputType = {
    id: string | null
    text: string | null
    tone: string | null
    appTapRate: Decimal | null
    appThumbsUpRate: Decimal | null
    appSampleSize: number | null
    tiktokLikeRate: Decimal | null
    tiktokShareRate: Decimal | null
    tiktokSampleSize: number | null
    tiktokHighPerformer: boolean | null
    isWisdom: boolean | null
    explorationWeight: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HookCandidateMaxAggregateOutputType = {
    id: string | null
    text: string | null
    tone: string | null
    appTapRate: Decimal | null
    appThumbsUpRate: Decimal | null
    appSampleSize: number | null
    tiktokLikeRate: Decimal | null
    tiktokShareRate: Decimal | null
    tiktokSampleSize: number | null
    tiktokHighPerformer: boolean | null
    isWisdom: boolean | null
    explorationWeight: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HookCandidateCountAggregateOutputType = {
    id: number
    text: number
    tone: number
    targetProblemTypes: number
    targetUserTypes: number
    appTapRate: number
    appThumbsUpRate: number
    appSampleSize: number
    tiktokLikeRate: number
    tiktokShareRate: number
    tiktokSampleSize: number
    tiktokHighPerformer: number
    isWisdom: number
    explorationWeight: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HookCandidateAvgAggregateInputType = {
    appTapRate?: true
    appThumbsUpRate?: true
    appSampleSize?: true
    tiktokLikeRate?: true
    tiktokShareRate?: true
    tiktokSampleSize?: true
    explorationWeight?: true
  }

  export type HookCandidateSumAggregateInputType = {
    appTapRate?: true
    appThumbsUpRate?: true
    appSampleSize?: true
    tiktokLikeRate?: true
    tiktokShareRate?: true
    tiktokSampleSize?: true
    explorationWeight?: true
  }

  export type HookCandidateMinAggregateInputType = {
    id?: true
    text?: true
    tone?: true
    appTapRate?: true
    appThumbsUpRate?: true
    appSampleSize?: true
    tiktokLikeRate?: true
    tiktokShareRate?: true
    tiktokSampleSize?: true
    tiktokHighPerformer?: true
    isWisdom?: true
    explorationWeight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HookCandidateMaxAggregateInputType = {
    id?: true
    text?: true
    tone?: true
    appTapRate?: true
    appThumbsUpRate?: true
    appSampleSize?: true
    tiktokLikeRate?: true
    tiktokShareRate?: true
    tiktokSampleSize?: true
    tiktokHighPerformer?: true
    isWisdom?: true
    explorationWeight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HookCandidateCountAggregateInputType = {
    id?: true
    text?: true
    tone?: true
    targetProblemTypes?: true
    targetUserTypes?: true
    appTapRate?: true
    appThumbsUpRate?: true
    appSampleSize?: true
    tiktokLikeRate?: true
    tiktokShareRate?: true
    tiktokSampleSize?: true
    tiktokHighPerformer?: true
    isWisdom?: true
    explorationWeight?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HookCandidateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HookCandidate to aggregate.
     */
    where?: HookCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HookCandidates to fetch.
     */
    orderBy?: HookCandidateOrderByWithRelationInput | HookCandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HookCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HookCandidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HookCandidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HookCandidates
    **/
    _count?: true | HookCandidateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HookCandidateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HookCandidateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HookCandidateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HookCandidateMaxAggregateInputType
  }

  export type GetHookCandidateAggregateType<T extends HookCandidateAggregateArgs> = {
        [P in keyof T & keyof AggregateHookCandidate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHookCandidate[P]>
      : GetScalarType<T[P], AggregateHookCandidate[P]>
  }




  export type HookCandidateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HookCandidateWhereInput
    orderBy?: HookCandidateOrderByWithAggregationInput | HookCandidateOrderByWithAggregationInput[]
    by: HookCandidateScalarFieldEnum[] | HookCandidateScalarFieldEnum
    having?: HookCandidateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HookCandidateCountAggregateInputType | true
    _avg?: HookCandidateAvgAggregateInputType
    _sum?: HookCandidateSumAggregateInputType
    _min?: HookCandidateMinAggregateInputType
    _max?: HookCandidateMaxAggregateInputType
  }

  export type HookCandidateGroupByOutputType = {
    id: string
    text: string
    tone: string
    targetProblemTypes: string[]
    targetUserTypes: string[]
    appTapRate: Decimal
    appThumbsUpRate: Decimal
    appSampleSize: number
    tiktokLikeRate: Decimal
    tiktokShareRate: Decimal
    tiktokSampleSize: number
    tiktokHighPerformer: boolean
    isWisdom: boolean
    explorationWeight: Decimal
    createdAt: Date
    updatedAt: Date
    _count: HookCandidateCountAggregateOutputType | null
    _avg: HookCandidateAvgAggregateOutputType | null
    _sum: HookCandidateSumAggregateOutputType | null
    _min: HookCandidateMinAggregateOutputType | null
    _max: HookCandidateMaxAggregateOutputType | null
  }

  type GetHookCandidateGroupByPayload<T extends HookCandidateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HookCandidateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HookCandidateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HookCandidateGroupByOutputType[P]>
            : GetScalarType<T[P], HookCandidateGroupByOutputType[P]>
        }
      >
    >


  export type HookCandidateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    tone?: boolean
    targetProblemTypes?: boolean
    targetUserTypes?: boolean
    appTapRate?: boolean
    appThumbsUpRate?: boolean
    appSampleSize?: boolean
    tiktokLikeRate?: boolean
    tiktokShareRate?: boolean
    tiktokSampleSize?: boolean
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tiktokPosts?: boolean | HookCandidate$tiktokPostsArgs<ExtArgs>
    _count?: boolean | HookCandidateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hookCandidate"]>

  export type HookCandidateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    tone?: boolean
    targetProblemTypes?: boolean
    targetUserTypes?: boolean
    appTapRate?: boolean
    appThumbsUpRate?: boolean
    appSampleSize?: boolean
    tiktokLikeRate?: boolean
    tiktokShareRate?: boolean
    tiktokSampleSize?: boolean
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["hookCandidate"]>

  export type HookCandidateSelectScalar = {
    id?: boolean
    text?: boolean
    tone?: boolean
    targetProblemTypes?: boolean
    targetUserTypes?: boolean
    appTapRate?: boolean
    appThumbsUpRate?: boolean
    appSampleSize?: boolean
    tiktokLikeRate?: boolean
    tiktokShareRate?: boolean
    tiktokSampleSize?: boolean
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HookCandidateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tiktokPosts?: boolean | HookCandidate$tiktokPostsArgs<ExtArgs>
    _count?: boolean | HookCandidateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HookCandidateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HookCandidatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HookCandidate"
    objects: {
      tiktokPosts: Prisma.$TiktokPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      tone: string
      targetProblemTypes: string[]
      targetUserTypes: string[]
      appTapRate: Prisma.Decimal
      appThumbsUpRate: Prisma.Decimal
      appSampleSize: number
      tiktokLikeRate: Prisma.Decimal
      tiktokShareRate: Prisma.Decimal
      tiktokSampleSize: number
      tiktokHighPerformer: boolean
      isWisdom: boolean
      explorationWeight: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["hookCandidate"]>
    composites: {}
  }

  type HookCandidateGetPayload<S extends boolean | null | undefined | HookCandidateDefaultArgs> = $Result.GetResult<Prisma.$HookCandidatePayload, S>

  type HookCandidateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HookCandidateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HookCandidateCountAggregateInputType | true
    }

  export interface HookCandidateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HookCandidate'], meta: { name: 'HookCandidate' } }
    /**
     * Find zero or one HookCandidate that matches the filter.
     * @param {HookCandidateFindUniqueArgs} args - Arguments to find a HookCandidate
     * @example
     * // Get one HookCandidate
     * const hookCandidate = await prisma.hookCandidate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HookCandidateFindUniqueArgs>(args: SelectSubset<T, HookCandidateFindUniqueArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HookCandidate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HookCandidateFindUniqueOrThrowArgs} args - Arguments to find a HookCandidate
     * @example
     * // Get one HookCandidate
     * const hookCandidate = await prisma.hookCandidate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HookCandidateFindUniqueOrThrowArgs>(args: SelectSubset<T, HookCandidateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HookCandidate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateFindFirstArgs} args - Arguments to find a HookCandidate
     * @example
     * // Get one HookCandidate
     * const hookCandidate = await prisma.hookCandidate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HookCandidateFindFirstArgs>(args?: SelectSubset<T, HookCandidateFindFirstArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HookCandidate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateFindFirstOrThrowArgs} args - Arguments to find a HookCandidate
     * @example
     * // Get one HookCandidate
     * const hookCandidate = await prisma.hookCandidate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HookCandidateFindFirstOrThrowArgs>(args?: SelectSubset<T, HookCandidateFindFirstOrThrowArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HookCandidates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HookCandidates
     * const hookCandidates = await prisma.hookCandidate.findMany()
     * 
     * // Get first 10 HookCandidates
     * const hookCandidates = await prisma.hookCandidate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hookCandidateWithIdOnly = await prisma.hookCandidate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HookCandidateFindManyArgs>(args?: SelectSubset<T, HookCandidateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HookCandidate.
     * @param {HookCandidateCreateArgs} args - Arguments to create a HookCandidate.
     * @example
     * // Create one HookCandidate
     * const HookCandidate = await prisma.hookCandidate.create({
     *   data: {
     *     // ... data to create a HookCandidate
     *   }
     * })
     * 
     */
    create<T extends HookCandidateCreateArgs>(args: SelectSubset<T, HookCandidateCreateArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HookCandidates.
     * @param {HookCandidateCreateManyArgs} args - Arguments to create many HookCandidates.
     * @example
     * // Create many HookCandidates
     * const hookCandidate = await prisma.hookCandidate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HookCandidateCreateManyArgs>(args?: SelectSubset<T, HookCandidateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HookCandidates and returns the data saved in the database.
     * @param {HookCandidateCreateManyAndReturnArgs} args - Arguments to create many HookCandidates.
     * @example
     * // Create many HookCandidates
     * const hookCandidate = await prisma.hookCandidate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HookCandidates and only return the `id`
     * const hookCandidateWithIdOnly = await prisma.hookCandidate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HookCandidateCreateManyAndReturnArgs>(args?: SelectSubset<T, HookCandidateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HookCandidate.
     * @param {HookCandidateDeleteArgs} args - Arguments to delete one HookCandidate.
     * @example
     * // Delete one HookCandidate
     * const HookCandidate = await prisma.hookCandidate.delete({
     *   where: {
     *     // ... filter to delete one HookCandidate
     *   }
     * })
     * 
     */
    delete<T extends HookCandidateDeleteArgs>(args: SelectSubset<T, HookCandidateDeleteArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HookCandidate.
     * @param {HookCandidateUpdateArgs} args - Arguments to update one HookCandidate.
     * @example
     * // Update one HookCandidate
     * const hookCandidate = await prisma.hookCandidate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HookCandidateUpdateArgs>(args: SelectSubset<T, HookCandidateUpdateArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HookCandidates.
     * @param {HookCandidateDeleteManyArgs} args - Arguments to filter HookCandidates to delete.
     * @example
     * // Delete a few HookCandidates
     * const { count } = await prisma.hookCandidate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HookCandidateDeleteManyArgs>(args?: SelectSubset<T, HookCandidateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HookCandidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HookCandidates
     * const hookCandidate = await prisma.hookCandidate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HookCandidateUpdateManyArgs>(args: SelectSubset<T, HookCandidateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HookCandidate.
     * @param {HookCandidateUpsertArgs} args - Arguments to update or create a HookCandidate.
     * @example
     * // Update or create a HookCandidate
     * const hookCandidate = await prisma.hookCandidate.upsert({
     *   create: {
     *     // ... data to create a HookCandidate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HookCandidate we want to update
     *   }
     * })
     */
    upsert<T extends HookCandidateUpsertArgs>(args: SelectSubset<T, HookCandidateUpsertArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HookCandidates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateCountArgs} args - Arguments to filter HookCandidates to count.
     * @example
     * // Count the number of HookCandidates
     * const count = await prisma.hookCandidate.count({
     *   where: {
     *     // ... the filter for the HookCandidates we want to count
     *   }
     * })
    **/
    count<T extends HookCandidateCountArgs>(
      args?: Subset<T, HookCandidateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HookCandidateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HookCandidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HookCandidateAggregateArgs>(args: Subset<T, HookCandidateAggregateArgs>): Prisma.PrismaPromise<GetHookCandidateAggregateType<T>>

    /**
     * Group by HookCandidate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HookCandidateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HookCandidateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HookCandidateGroupByArgs['orderBy'] }
        : { orderBy?: HookCandidateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HookCandidateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHookCandidateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HookCandidate model
   */
  readonly fields: HookCandidateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HookCandidate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HookCandidateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tiktokPosts<T extends HookCandidate$tiktokPostsArgs<ExtArgs> = {}>(args?: Subset<T, HookCandidate$tiktokPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HookCandidate model
   */ 
  interface HookCandidateFieldRefs {
    readonly id: FieldRef<"HookCandidate", 'String'>
    readonly text: FieldRef<"HookCandidate", 'String'>
    readonly tone: FieldRef<"HookCandidate", 'String'>
    readonly targetProblemTypes: FieldRef<"HookCandidate", 'String[]'>
    readonly targetUserTypes: FieldRef<"HookCandidate", 'String[]'>
    readonly appTapRate: FieldRef<"HookCandidate", 'Decimal'>
    readonly appThumbsUpRate: FieldRef<"HookCandidate", 'Decimal'>
    readonly appSampleSize: FieldRef<"HookCandidate", 'Int'>
    readonly tiktokLikeRate: FieldRef<"HookCandidate", 'Decimal'>
    readonly tiktokShareRate: FieldRef<"HookCandidate", 'Decimal'>
    readonly tiktokSampleSize: FieldRef<"HookCandidate", 'Int'>
    readonly tiktokHighPerformer: FieldRef<"HookCandidate", 'Boolean'>
    readonly isWisdom: FieldRef<"HookCandidate", 'Boolean'>
    readonly explorationWeight: FieldRef<"HookCandidate", 'Decimal'>
    readonly createdAt: FieldRef<"HookCandidate", 'DateTime'>
    readonly updatedAt: FieldRef<"HookCandidate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HookCandidate findUnique
   */
  export type HookCandidateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * Filter, which HookCandidate to fetch.
     */
    where: HookCandidateWhereUniqueInput
  }

  /**
   * HookCandidate findUniqueOrThrow
   */
  export type HookCandidateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * Filter, which HookCandidate to fetch.
     */
    where: HookCandidateWhereUniqueInput
  }

  /**
   * HookCandidate findFirst
   */
  export type HookCandidateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * Filter, which HookCandidate to fetch.
     */
    where?: HookCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HookCandidates to fetch.
     */
    orderBy?: HookCandidateOrderByWithRelationInput | HookCandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HookCandidates.
     */
    cursor?: HookCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HookCandidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HookCandidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HookCandidates.
     */
    distinct?: HookCandidateScalarFieldEnum | HookCandidateScalarFieldEnum[]
  }

  /**
   * HookCandidate findFirstOrThrow
   */
  export type HookCandidateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * Filter, which HookCandidate to fetch.
     */
    where?: HookCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HookCandidates to fetch.
     */
    orderBy?: HookCandidateOrderByWithRelationInput | HookCandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HookCandidates.
     */
    cursor?: HookCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HookCandidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HookCandidates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HookCandidates.
     */
    distinct?: HookCandidateScalarFieldEnum | HookCandidateScalarFieldEnum[]
  }

  /**
   * HookCandidate findMany
   */
  export type HookCandidateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * Filter, which HookCandidates to fetch.
     */
    where?: HookCandidateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HookCandidates to fetch.
     */
    orderBy?: HookCandidateOrderByWithRelationInput | HookCandidateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HookCandidates.
     */
    cursor?: HookCandidateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HookCandidates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HookCandidates.
     */
    skip?: number
    distinct?: HookCandidateScalarFieldEnum | HookCandidateScalarFieldEnum[]
  }

  /**
   * HookCandidate create
   */
  export type HookCandidateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * The data needed to create a HookCandidate.
     */
    data: XOR<HookCandidateCreateInput, HookCandidateUncheckedCreateInput>
  }

  /**
   * HookCandidate createMany
   */
  export type HookCandidateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HookCandidates.
     */
    data: HookCandidateCreateManyInput | HookCandidateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HookCandidate createManyAndReturn
   */
  export type HookCandidateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HookCandidates.
     */
    data: HookCandidateCreateManyInput | HookCandidateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HookCandidate update
   */
  export type HookCandidateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * The data needed to update a HookCandidate.
     */
    data: XOR<HookCandidateUpdateInput, HookCandidateUncheckedUpdateInput>
    /**
     * Choose, which HookCandidate to update.
     */
    where: HookCandidateWhereUniqueInput
  }

  /**
   * HookCandidate updateMany
   */
  export type HookCandidateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HookCandidates.
     */
    data: XOR<HookCandidateUpdateManyMutationInput, HookCandidateUncheckedUpdateManyInput>
    /**
     * Filter which HookCandidates to update
     */
    where?: HookCandidateWhereInput
  }

  /**
   * HookCandidate upsert
   */
  export type HookCandidateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * The filter to search for the HookCandidate to update in case it exists.
     */
    where: HookCandidateWhereUniqueInput
    /**
     * In case the HookCandidate found by the `where` argument doesn't exist, create a new HookCandidate with this data.
     */
    create: XOR<HookCandidateCreateInput, HookCandidateUncheckedCreateInput>
    /**
     * In case the HookCandidate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HookCandidateUpdateInput, HookCandidateUncheckedUpdateInput>
  }

  /**
   * HookCandidate delete
   */
  export type HookCandidateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    /**
     * Filter which HookCandidate to delete.
     */
    where: HookCandidateWhereUniqueInput
  }

  /**
   * HookCandidate deleteMany
   */
  export type HookCandidateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HookCandidates to delete
     */
    where?: HookCandidateWhereInput
  }

  /**
   * HookCandidate.tiktokPosts
   */
  export type HookCandidate$tiktokPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    where?: TiktokPostWhereInput
    orderBy?: TiktokPostOrderByWithRelationInput | TiktokPostOrderByWithRelationInput[]
    cursor?: TiktokPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TiktokPostScalarFieldEnum | TiktokPostScalarFieldEnum[]
  }

  /**
   * HookCandidate without action
   */
  export type HookCandidateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
  }


  /**
   * Model TiktokPost
   */

  export type AggregateTiktokPost = {
    _count: TiktokPostCountAggregateOutputType | null
    _avg: TiktokPostAvgAggregateOutputType | null
    _sum: TiktokPostSumAggregateOutputType | null
    _min: TiktokPostMinAggregateOutputType | null
    _max: TiktokPostMaxAggregateOutputType | null
  }

  export type TiktokPostAvgAggregateOutputType = {
    viewCount: number | null
    likeCount: number | null
    commentCount: number | null
    shareCount: number | null
  }

  export type TiktokPostSumAggregateOutputType = {
    viewCount: bigint | null
    likeCount: bigint | null
    commentCount: bigint | null
    shareCount: bigint | null
  }

  export type TiktokPostMinAggregateOutputType = {
    id: string | null
    hookCandidateId: string | null
    tiktokVideoId: string | null
    blotatoPostId: string | null
    caption: string | null
    postedAt: Date | null
    metricsFetchedAt: Date | null
    viewCount: bigint | null
    likeCount: bigint | null
    commentCount: bigint | null
    shareCount: bigint | null
    agentReasoning: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type TiktokPostMaxAggregateOutputType = {
    id: string | null
    hookCandidateId: string | null
    tiktokVideoId: string | null
    blotatoPostId: string | null
    caption: string | null
    postedAt: Date | null
    metricsFetchedAt: Date | null
    viewCount: bigint | null
    likeCount: bigint | null
    commentCount: bigint | null
    shareCount: bigint | null
    agentReasoning: string | null
    scheduledAt: Date | null
    createdAt: Date | null
  }

  export type TiktokPostCountAggregateOutputType = {
    id: number
    hookCandidateId: number
    tiktokVideoId: number
    blotatoPostId: number
    caption: number
    postedAt: number
    metricsFetchedAt: number
    viewCount: number
    likeCount: number
    commentCount: number
    shareCount: number
    agentReasoning: number
    scheduledAt: number
    createdAt: number
    _all: number
  }


  export type TiktokPostAvgAggregateInputType = {
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
  }

  export type TiktokPostSumAggregateInputType = {
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
  }

  export type TiktokPostMinAggregateInputType = {
    id?: true
    hookCandidateId?: true
    tiktokVideoId?: true
    blotatoPostId?: true
    caption?: true
    postedAt?: true
    metricsFetchedAt?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
    agentReasoning?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type TiktokPostMaxAggregateInputType = {
    id?: true
    hookCandidateId?: true
    tiktokVideoId?: true
    blotatoPostId?: true
    caption?: true
    postedAt?: true
    metricsFetchedAt?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
    agentReasoning?: true
    scheduledAt?: true
    createdAt?: true
  }

  export type TiktokPostCountAggregateInputType = {
    id?: true
    hookCandidateId?: true
    tiktokVideoId?: true
    blotatoPostId?: true
    caption?: true
    postedAt?: true
    metricsFetchedAt?: true
    viewCount?: true
    likeCount?: true
    commentCount?: true
    shareCount?: true
    agentReasoning?: true
    scheduledAt?: true
    createdAt?: true
    _all?: true
  }

  export type TiktokPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TiktokPost to aggregate.
     */
    where?: TiktokPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiktokPosts to fetch.
     */
    orderBy?: TiktokPostOrderByWithRelationInput | TiktokPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TiktokPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiktokPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiktokPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TiktokPosts
    **/
    _count?: true | TiktokPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TiktokPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TiktokPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TiktokPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TiktokPostMaxAggregateInputType
  }

  export type GetTiktokPostAggregateType<T extends TiktokPostAggregateArgs> = {
        [P in keyof T & keyof AggregateTiktokPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTiktokPost[P]>
      : GetScalarType<T[P], AggregateTiktokPost[P]>
  }




  export type TiktokPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiktokPostWhereInput
    orderBy?: TiktokPostOrderByWithAggregationInput | TiktokPostOrderByWithAggregationInput[]
    by: TiktokPostScalarFieldEnum[] | TiktokPostScalarFieldEnum
    having?: TiktokPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TiktokPostCountAggregateInputType | true
    _avg?: TiktokPostAvgAggregateInputType
    _sum?: TiktokPostSumAggregateInputType
    _min?: TiktokPostMinAggregateInputType
    _max?: TiktokPostMaxAggregateInputType
  }

  export type TiktokPostGroupByOutputType = {
    id: string
    hookCandidateId: string | null
    tiktokVideoId: string | null
    blotatoPostId: string | null
    caption: string | null
    postedAt: Date
    metricsFetchedAt: Date | null
    viewCount: bigint | null
    likeCount: bigint | null
    commentCount: bigint | null
    shareCount: bigint | null
    agentReasoning: string | null
    scheduledAt: Date | null
    createdAt: Date
    _count: TiktokPostCountAggregateOutputType | null
    _avg: TiktokPostAvgAggregateOutputType | null
    _sum: TiktokPostSumAggregateOutputType | null
    _min: TiktokPostMinAggregateOutputType | null
    _max: TiktokPostMaxAggregateOutputType | null
  }

  type GetTiktokPostGroupByPayload<T extends TiktokPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TiktokPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TiktokPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TiktokPostGroupByOutputType[P]>
            : GetScalarType<T[P], TiktokPostGroupByOutputType[P]>
        }
      >
    >


  export type TiktokPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hookCandidateId?: boolean
    tiktokVideoId?: boolean
    blotatoPostId?: boolean
    caption?: boolean
    postedAt?: boolean
    metricsFetchedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    commentCount?: boolean
    shareCount?: boolean
    agentReasoning?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    hookCandidate?: boolean | TiktokPost$hookCandidateArgs<ExtArgs>
  }, ExtArgs["result"]["tiktokPost"]>

  export type TiktokPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hookCandidateId?: boolean
    tiktokVideoId?: boolean
    blotatoPostId?: boolean
    caption?: boolean
    postedAt?: boolean
    metricsFetchedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    commentCount?: boolean
    shareCount?: boolean
    agentReasoning?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
    hookCandidate?: boolean | TiktokPost$hookCandidateArgs<ExtArgs>
  }, ExtArgs["result"]["tiktokPost"]>

  export type TiktokPostSelectScalar = {
    id?: boolean
    hookCandidateId?: boolean
    tiktokVideoId?: boolean
    blotatoPostId?: boolean
    caption?: boolean
    postedAt?: boolean
    metricsFetchedAt?: boolean
    viewCount?: boolean
    likeCount?: boolean
    commentCount?: boolean
    shareCount?: boolean
    agentReasoning?: boolean
    scheduledAt?: boolean
    createdAt?: boolean
  }

  export type TiktokPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hookCandidate?: boolean | TiktokPost$hookCandidateArgs<ExtArgs>
  }
  export type TiktokPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hookCandidate?: boolean | TiktokPost$hookCandidateArgs<ExtArgs>
  }

  export type $TiktokPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TiktokPost"
    objects: {
      hookCandidate: Prisma.$HookCandidatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hookCandidateId: string | null
      tiktokVideoId: string | null
      blotatoPostId: string | null
      caption: string | null
      postedAt: Date
      metricsFetchedAt: Date | null
      viewCount: bigint | null
      likeCount: bigint | null
      commentCount: bigint | null
      shareCount: bigint | null
      agentReasoning: string | null
      scheduledAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["tiktokPost"]>
    composites: {}
  }

  type TiktokPostGetPayload<S extends boolean | null | undefined | TiktokPostDefaultArgs> = $Result.GetResult<Prisma.$TiktokPostPayload, S>

  type TiktokPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TiktokPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TiktokPostCountAggregateInputType | true
    }

  export interface TiktokPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TiktokPost'], meta: { name: 'TiktokPost' } }
    /**
     * Find zero or one TiktokPost that matches the filter.
     * @param {TiktokPostFindUniqueArgs} args - Arguments to find a TiktokPost
     * @example
     * // Get one TiktokPost
     * const tiktokPost = await prisma.tiktokPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TiktokPostFindUniqueArgs>(args: SelectSubset<T, TiktokPostFindUniqueArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TiktokPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TiktokPostFindUniqueOrThrowArgs} args - Arguments to find a TiktokPost
     * @example
     * // Get one TiktokPost
     * const tiktokPost = await prisma.tiktokPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TiktokPostFindUniqueOrThrowArgs>(args: SelectSubset<T, TiktokPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TiktokPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostFindFirstArgs} args - Arguments to find a TiktokPost
     * @example
     * // Get one TiktokPost
     * const tiktokPost = await prisma.tiktokPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TiktokPostFindFirstArgs>(args?: SelectSubset<T, TiktokPostFindFirstArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TiktokPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostFindFirstOrThrowArgs} args - Arguments to find a TiktokPost
     * @example
     * // Get one TiktokPost
     * const tiktokPost = await prisma.tiktokPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TiktokPostFindFirstOrThrowArgs>(args?: SelectSubset<T, TiktokPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TiktokPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TiktokPosts
     * const tiktokPosts = await prisma.tiktokPost.findMany()
     * 
     * // Get first 10 TiktokPosts
     * const tiktokPosts = await prisma.tiktokPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tiktokPostWithIdOnly = await prisma.tiktokPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TiktokPostFindManyArgs>(args?: SelectSubset<T, TiktokPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TiktokPost.
     * @param {TiktokPostCreateArgs} args - Arguments to create a TiktokPost.
     * @example
     * // Create one TiktokPost
     * const TiktokPost = await prisma.tiktokPost.create({
     *   data: {
     *     // ... data to create a TiktokPost
     *   }
     * })
     * 
     */
    create<T extends TiktokPostCreateArgs>(args: SelectSubset<T, TiktokPostCreateArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TiktokPosts.
     * @param {TiktokPostCreateManyArgs} args - Arguments to create many TiktokPosts.
     * @example
     * // Create many TiktokPosts
     * const tiktokPost = await prisma.tiktokPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TiktokPostCreateManyArgs>(args?: SelectSubset<T, TiktokPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TiktokPosts and returns the data saved in the database.
     * @param {TiktokPostCreateManyAndReturnArgs} args - Arguments to create many TiktokPosts.
     * @example
     * // Create many TiktokPosts
     * const tiktokPost = await prisma.tiktokPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TiktokPosts and only return the `id`
     * const tiktokPostWithIdOnly = await prisma.tiktokPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TiktokPostCreateManyAndReturnArgs>(args?: SelectSubset<T, TiktokPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TiktokPost.
     * @param {TiktokPostDeleteArgs} args - Arguments to delete one TiktokPost.
     * @example
     * // Delete one TiktokPost
     * const TiktokPost = await prisma.tiktokPost.delete({
     *   where: {
     *     // ... filter to delete one TiktokPost
     *   }
     * })
     * 
     */
    delete<T extends TiktokPostDeleteArgs>(args: SelectSubset<T, TiktokPostDeleteArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TiktokPost.
     * @param {TiktokPostUpdateArgs} args - Arguments to update one TiktokPost.
     * @example
     * // Update one TiktokPost
     * const tiktokPost = await prisma.tiktokPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TiktokPostUpdateArgs>(args: SelectSubset<T, TiktokPostUpdateArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TiktokPosts.
     * @param {TiktokPostDeleteManyArgs} args - Arguments to filter TiktokPosts to delete.
     * @example
     * // Delete a few TiktokPosts
     * const { count } = await prisma.tiktokPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TiktokPostDeleteManyArgs>(args?: SelectSubset<T, TiktokPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TiktokPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TiktokPosts
     * const tiktokPost = await prisma.tiktokPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TiktokPostUpdateManyArgs>(args: SelectSubset<T, TiktokPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TiktokPost.
     * @param {TiktokPostUpsertArgs} args - Arguments to update or create a TiktokPost.
     * @example
     * // Update or create a TiktokPost
     * const tiktokPost = await prisma.tiktokPost.upsert({
     *   create: {
     *     // ... data to create a TiktokPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TiktokPost we want to update
     *   }
     * })
     */
    upsert<T extends TiktokPostUpsertArgs>(args: SelectSubset<T, TiktokPostUpsertArgs<ExtArgs>>): Prisma__TiktokPostClient<$Result.GetResult<Prisma.$TiktokPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TiktokPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostCountArgs} args - Arguments to filter TiktokPosts to count.
     * @example
     * // Count the number of TiktokPosts
     * const count = await prisma.tiktokPost.count({
     *   where: {
     *     // ... the filter for the TiktokPosts we want to count
     *   }
     * })
    **/
    count<T extends TiktokPostCountArgs>(
      args?: Subset<T, TiktokPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TiktokPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TiktokPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TiktokPostAggregateArgs>(args: Subset<T, TiktokPostAggregateArgs>): Prisma.PrismaPromise<GetTiktokPostAggregateType<T>>

    /**
     * Group by TiktokPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiktokPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TiktokPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TiktokPostGroupByArgs['orderBy'] }
        : { orderBy?: TiktokPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TiktokPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTiktokPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TiktokPost model
   */
  readonly fields: TiktokPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TiktokPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TiktokPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hookCandidate<T extends TiktokPost$hookCandidateArgs<ExtArgs> = {}>(args?: Subset<T, TiktokPost$hookCandidateArgs<ExtArgs>>): Prisma__HookCandidateClient<$Result.GetResult<Prisma.$HookCandidatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TiktokPost model
   */ 
  interface TiktokPostFieldRefs {
    readonly id: FieldRef<"TiktokPost", 'String'>
    readonly hookCandidateId: FieldRef<"TiktokPost", 'String'>
    readonly tiktokVideoId: FieldRef<"TiktokPost", 'String'>
    readonly blotatoPostId: FieldRef<"TiktokPost", 'String'>
    readonly caption: FieldRef<"TiktokPost", 'String'>
    readonly postedAt: FieldRef<"TiktokPost", 'DateTime'>
    readonly metricsFetchedAt: FieldRef<"TiktokPost", 'DateTime'>
    readonly viewCount: FieldRef<"TiktokPost", 'BigInt'>
    readonly likeCount: FieldRef<"TiktokPost", 'BigInt'>
    readonly commentCount: FieldRef<"TiktokPost", 'BigInt'>
    readonly shareCount: FieldRef<"TiktokPost", 'BigInt'>
    readonly agentReasoning: FieldRef<"TiktokPost", 'String'>
    readonly scheduledAt: FieldRef<"TiktokPost", 'DateTime'>
    readonly createdAt: FieldRef<"TiktokPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TiktokPost findUnique
   */
  export type TiktokPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * Filter, which TiktokPost to fetch.
     */
    where: TiktokPostWhereUniqueInput
  }

  /**
   * TiktokPost findUniqueOrThrow
   */
  export type TiktokPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * Filter, which TiktokPost to fetch.
     */
    where: TiktokPostWhereUniqueInput
  }

  /**
   * TiktokPost findFirst
   */
  export type TiktokPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * Filter, which TiktokPost to fetch.
     */
    where?: TiktokPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiktokPosts to fetch.
     */
    orderBy?: TiktokPostOrderByWithRelationInput | TiktokPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TiktokPosts.
     */
    cursor?: TiktokPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiktokPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiktokPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TiktokPosts.
     */
    distinct?: TiktokPostScalarFieldEnum | TiktokPostScalarFieldEnum[]
  }

  /**
   * TiktokPost findFirstOrThrow
   */
  export type TiktokPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * Filter, which TiktokPost to fetch.
     */
    where?: TiktokPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiktokPosts to fetch.
     */
    orderBy?: TiktokPostOrderByWithRelationInput | TiktokPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TiktokPosts.
     */
    cursor?: TiktokPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiktokPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiktokPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TiktokPosts.
     */
    distinct?: TiktokPostScalarFieldEnum | TiktokPostScalarFieldEnum[]
  }

  /**
   * TiktokPost findMany
   */
  export type TiktokPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * Filter, which TiktokPosts to fetch.
     */
    where?: TiktokPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TiktokPosts to fetch.
     */
    orderBy?: TiktokPostOrderByWithRelationInput | TiktokPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TiktokPosts.
     */
    cursor?: TiktokPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TiktokPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TiktokPosts.
     */
    skip?: number
    distinct?: TiktokPostScalarFieldEnum | TiktokPostScalarFieldEnum[]
  }

  /**
   * TiktokPost create
   */
  export type TiktokPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * The data needed to create a TiktokPost.
     */
    data?: XOR<TiktokPostCreateInput, TiktokPostUncheckedCreateInput>
  }

  /**
   * TiktokPost createMany
   */
  export type TiktokPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TiktokPosts.
     */
    data: TiktokPostCreateManyInput | TiktokPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TiktokPost createManyAndReturn
   */
  export type TiktokPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TiktokPosts.
     */
    data: TiktokPostCreateManyInput | TiktokPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TiktokPost update
   */
  export type TiktokPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * The data needed to update a TiktokPost.
     */
    data: XOR<TiktokPostUpdateInput, TiktokPostUncheckedUpdateInput>
    /**
     * Choose, which TiktokPost to update.
     */
    where: TiktokPostWhereUniqueInput
  }

  /**
   * TiktokPost updateMany
   */
  export type TiktokPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TiktokPosts.
     */
    data: XOR<TiktokPostUpdateManyMutationInput, TiktokPostUncheckedUpdateManyInput>
    /**
     * Filter which TiktokPosts to update
     */
    where?: TiktokPostWhereInput
  }

  /**
   * TiktokPost upsert
   */
  export type TiktokPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * The filter to search for the TiktokPost to update in case it exists.
     */
    where: TiktokPostWhereUniqueInput
    /**
     * In case the TiktokPost found by the `where` argument doesn't exist, create a new TiktokPost with this data.
     */
    create: XOR<TiktokPostCreateInput, TiktokPostUncheckedCreateInput>
    /**
     * In case the TiktokPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TiktokPostUpdateInput, TiktokPostUncheckedUpdateInput>
  }

  /**
   * TiktokPost delete
   */
  export type TiktokPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
    /**
     * Filter which TiktokPost to delete.
     */
    where: TiktokPostWhereUniqueInput
  }

  /**
   * TiktokPost deleteMany
   */
  export type TiktokPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TiktokPosts to delete
     */
    where?: TiktokPostWhereInput
  }

  /**
   * TiktokPost.hookCandidate
   */
  export type TiktokPost$hookCandidateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HookCandidate
     */
    select?: HookCandidateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HookCandidateInclude<ExtArgs> | null
    where?: HookCandidateWhereInput
  }

  /**
   * TiktokPost without action
   */
  export type TiktokPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TiktokPost
     */
    select?: TiktokPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiktokPostInclude<ExtArgs> | null
  }


  /**
   * Model WisdomPattern
   */

  export type AggregateWisdomPattern = {
    _count: WisdomPatternCountAggregateOutputType | null
    _avg: WisdomPatternAvgAggregateOutputType | null
    _sum: WisdomPatternSumAggregateOutputType | null
    _min: WisdomPatternMinAggregateOutputType | null
    _max: WisdomPatternMaxAggregateOutputType | null
  }

  export type WisdomPatternAvgAggregateOutputType = {
    confidence: Decimal | null
  }

  export type WisdomPatternSumAggregateOutputType = {
    confidence: Decimal | null
  }

  export type WisdomPatternMinAggregateOutputType = {
    id: string | null
    patternName: string | null
    description: string | null
    effectiveTone: string | null
    effectiveHookPattern: string | null
    effectiveContentLength: string | null
    confidence: Decimal | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WisdomPatternMaxAggregateOutputType = {
    id: string | null
    patternName: string | null
    description: string | null
    effectiveTone: string | null
    effectiveHookPattern: string | null
    effectiveContentLength: string | null
    confidence: Decimal | null
    verifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WisdomPatternCountAggregateOutputType = {
    id: number
    patternName: number
    description: number
    targetUserTypes: number
    effectiveTone: number
    effectiveHookPattern: number
    effectiveContentLength: number
    appEvidence: number
    tiktokEvidence: number
    confidence: number
    verifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WisdomPatternAvgAggregateInputType = {
    confidence?: true
  }

  export type WisdomPatternSumAggregateInputType = {
    confidence?: true
  }

  export type WisdomPatternMinAggregateInputType = {
    id?: true
    patternName?: true
    description?: true
    effectiveTone?: true
    effectiveHookPattern?: true
    effectiveContentLength?: true
    confidence?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WisdomPatternMaxAggregateInputType = {
    id?: true
    patternName?: true
    description?: true
    effectiveTone?: true
    effectiveHookPattern?: true
    effectiveContentLength?: true
    confidence?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WisdomPatternCountAggregateInputType = {
    id?: true
    patternName?: true
    description?: true
    targetUserTypes?: true
    effectiveTone?: true
    effectiveHookPattern?: true
    effectiveContentLength?: true
    appEvidence?: true
    tiktokEvidence?: true
    confidence?: true
    verifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WisdomPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WisdomPattern to aggregate.
     */
    where?: WisdomPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomPatterns to fetch.
     */
    orderBy?: WisdomPatternOrderByWithRelationInput | WisdomPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WisdomPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WisdomPatterns
    **/
    _count?: true | WisdomPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WisdomPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WisdomPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WisdomPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WisdomPatternMaxAggregateInputType
  }

  export type GetWisdomPatternAggregateType<T extends WisdomPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateWisdomPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWisdomPattern[P]>
      : GetScalarType<T[P], AggregateWisdomPattern[P]>
  }




  export type WisdomPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WisdomPatternWhereInput
    orderBy?: WisdomPatternOrderByWithAggregationInput | WisdomPatternOrderByWithAggregationInput[]
    by: WisdomPatternScalarFieldEnum[] | WisdomPatternScalarFieldEnum
    having?: WisdomPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WisdomPatternCountAggregateInputType | true
    _avg?: WisdomPatternAvgAggregateInputType
    _sum?: WisdomPatternSumAggregateInputType
    _min?: WisdomPatternMinAggregateInputType
    _max?: WisdomPatternMaxAggregateInputType
  }

  export type WisdomPatternGroupByOutputType = {
    id: string
    patternName: string
    description: string | null
    targetUserTypes: string[]
    effectiveTone: string | null
    effectiveHookPattern: string | null
    effectiveContentLength: string | null
    appEvidence: JsonValue
    tiktokEvidence: JsonValue
    confidence: Decimal
    verifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WisdomPatternCountAggregateOutputType | null
    _avg: WisdomPatternAvgAggregateOutputType | null
    _sum: WisdomPatternSumAggregateOutputType | null
    _min: WisdomPatternMinAggregateOutputType | null
    _max: WisdomPatternMaxAggregateOutputType | null
  }

  type GetWisdomPatternGroupByPayload<T extends WisdomPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WisdomPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WisdomPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WisdomPatternGroupByOutputType[P]>
            : GetScalarType<T[P], WisdomPatternGroupByOutputType[P]>
        }
      >
    >


  export type WisdomPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternName?: boolean
    description?: boolean
    targetUserTypes?: boolean
    effectiveTone?: boolean
    effectiveHookPattern?: boolean
    effectiveContentLength?: boolean
    appEvidence?: boolean
    tiktokEvidence?: boolean
    confidence?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wisdomPattern"]>

  export type WisdomPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternName?: boolean
    description?: boolean
    targetUserTypes?: boolean
    effectiveTone?: boolean
    effectiveHookPattern?: boolean
    effectiveContentLength?: boolean
    appEvidence?: boolean
    tiktokEvidence?: boolean
    confidence?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["wisdomPattern"]>

  export type WisdomPatternSelectScalar = {
    id?: boolean
    patternName?: boolean
    description?: boolean
    targetUserTypes?: boolean
    effectiveTone?: boolean
    effectiveHookPattern?: boolean
    effectiveContentLength?: boolean
    appEvidence?: boolean
    tiktokEvidence?: boolean
    confidence?: boolean
    verifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WisdomPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WisdomPattern"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternName: string
      description: string | null
      targetUserTypes: string[]
      effectiveTone: string | null
      effectiveHookPattern: string | null
      effectiveContentLength: string | null
      appEvidence: Prisma.JsonValue
      tiktokEvidence: Prisma.JsonValue
      confidence: Prisma.Decimal
      verifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wisdomPattern"]>
    composites: {}
  }

  type WisdomPatternGetPayload<S extends boolean | null | undefined | WisdomPatternDefaultArgs> = $Result.GetResult<Prisma.$WisdomPatternPayload, S>

  type WisdomPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WisdomPatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WisdomPatternCountAggregateInputType | true
    }

  export interface WisdomPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WisdomPattern'], meta: { name: 'WisdomPattern' } }
    /**
     * Find zero or one WisdomPattern that matches the filter.
     * @param {WisdomPatternFindUniqueArgs} args - Arguments to find a WisdomPattern
     * @example
     * // Get one WisdomPattern
     * const wisdomPattern = await prisma.wisdomPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WisdomPatternFindUniqueArgs>(args: SelectSubset<T, WisdomPatternFindUniqueArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WisdomPattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WisdomPatternFindUniqueOrThrowArgs} args - Arguments to find a WisdomPattern
     * @example
     * // Get one WisdomPattern
     * const wisdomPattern = await prisma.wisdomPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WisdomPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, WisdomPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WisdomPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternFindFirstArgs} args - Arguments to find a WisdomPattern
     * @example
     * // Get one WisdomPattern
     * const wisdomPattern = await prisma.wisdomPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WisdomPatternFindFirstArgs>(args?: SelectSubset<T, WisdomPatternFindFirstArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WisdomPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternFindFirstOrThrowArgs} args - Arguments to find a WisdomPattern
     * @example
     * // Get one WisdomPattern
     * const wisdomPattern = await prisma.wisdomPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WisdomPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, WisdomPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WisdomPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WisdomPatterns
     * const wisdomPatterns = await prisma.wisdomPattern.findMany()
     * 
     * // Get first 10 WisdomPatterns
     * const wisdomPatterns = await prisma.wisdomPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wisdomPatternWithIdOnly = await prisma.wisdomPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WisdomPatternFindManyArgs>(args?: SelectSubset<T, WisdomPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WisdomPattern.
     * @param {WisdomPatternCreateArgs} args - Arguments to create a WisdomPattern.
     * @example
     * // Create one WisdomPattern
     * const WisdomPattern = await prisma.wisdomPattern.create({
     *   data: {
     *     // ... data to create a WisdomPattern
     *   }
     * })
     * 
     */
    create<T extends WisdomPatternCreateArgs>(args: SelectSubset<T, WisdomPatternCreateArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WisdomPatterns.
     * @param {WisdomPatternCreateManyArgs} args - Arguments to create many WisdomPatterns.
     * @example
     * // Create many WisdomPatterns
     * const wisdomPattern = await prisma.wisdomPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WisdomPatternCreateManyArgs>(args?: SelectSubset<T, WisdomPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WisdomPatterns and returns the data saved in the database.
     * @param {WisdomPatternCreateManyAndReturnArgs} args - Arguments to create many WisdomPatterns.
     * @example
     * // Create many WisdomPatterns
     * const wisdomPattern = await prisma.wisdomPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WisdomPatterns and only return the `id`
     * const wisdomPatternWithIdOnly = await prisma.wisdomPattern.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WisdomPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, WisdomPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WisdomPattern.
     * @param {WisdomPatternDeleteArgs} args - Arguments to delete one WisdomPattern.
     * @example
     * // Delete one WisdomPattern
     * const WisdomPattern = await prisma.wisdomPattern.delete({
     *   where: {
     *     // ... filter to delete one WisdomPattern
     *   }
     * })
     * 
     */
    delete<T extends WisdomPatternDeleteArgs>(args: SelectSubset<T, WisdomPatternDeleteArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WisdomPattern.
     * @param {WisdomPatternUpdateArgs} args - Arguments to update one WisdomPattern.
     * @example
     * // Update one WisdomPattern
     * const wisdomPattern = await prisma.wisdomPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WisdomPatternUpdateArgs>(args: SelectSubset<T, WisdomPatternUpdateArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WisdomPatterns.
     * @param {WisdomPatternDeleteManyArgs} args - Arguments to filter WisdomPatterns to delete.
     * @example
     * // Delete a few WisdomPatterns
     * const { count } = await prisma.wisdomPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WisdomPatternDeleteManyArgs>(args?: SelectSubset<T, WisdomPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WisdomPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WisdomPatterns
     * const wisdomPattern = await prisma.wisdomPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WisdomPatternUpdateManyArgs>(args: SelectSubset<T, WisdomPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WisdomPattern.
     * @param {WisdomPatternUpsertArgs} args - Arguments to update or create a WisdomPattern.
     * @example
     * // Update or create a WisdomPattern
     * const wisdomPattern = await prisma.wisdomPattern.upsert({
     *   create: {
     *     // ... data to create a WisdomPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WisdomPattern we want to update
     *   }
     * })
     */
    upsert<T extends WisdomPatternUpsertArgs>(args: SelectSubset<T, WisdomPatternUpsertArgs<ExtArgs>>): Prisma__WisdomPatternClient<$Result.GetResult<Prisma.$WisdomPatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WisdomPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternCountArgs} args - Arguments to filter WisdomPatterns to count.
     * @example
     * // Count the number of WisdomPatterns
     * const count = await prisma.wisdomPattern.count({
     *   where: {
     *     // ... the filter for the WisdomPatterns we want to count
     *   }
     * })
    **/
    count<T extends WisdomPatternCountArgs>(
      args?: Subset<T, WisdomPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WisdomPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WisdomPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WisdomPatternAggregateArgs>(args: Subset<T, WisdomPatternAggregateArgs>): Prisma.PrismaPromise<GetWisdomPatternAggregateType<T>>

    /**
     * Group by WisdomPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WisdomPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WisdomPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WisdomPatternGroupByArgs['orderBy'] }
        : { orderBy?: WisdomPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WisdomPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWisdomPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WisdomPattern model
   */
  readonly fields: WisdomPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WisdomPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WisdomPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WisdomPattern model
   */ 
  interface WisdomPatternFieldRefs {
    readonly id: FieldRef<"WisdomPattern", 'String'>
    readonly patternName: FieldRef<"WisdomPattern", 'String'>
    readonly description: FieldRef<"WisdomPattern", 'String'>
    readonly targetUserTypes: FieldRef<"WisdomPattern", 'String[]'>
    readonly effectiveTone: FieldRef<"WisdomPattern", 'String'>
    readonly effectiveHookPattern: FieldRef<"WisdomPattern", 'String'>
    readonly effectiveContentLength: FieldRef<"WisdomPattern", 'String'>
    readonly appEvidence: FieldRef<"WisdomPattern", 'Json'>
    readonly tiktokEvidence: FieldRef<"WisdomPattern", 'Json'>
    readonly confidence: FieldRef<"WisdomPattern", 'Decimal'>
    readonly verifiedAt: FieldRef<"WisdomPattern", 'DateTime'>
    readonly createdAt: FieldRef<"WisdomPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"WisdomPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WisdomPattern findUnique
   */
  export type WisdomPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * Filter, which WisdomPattern to fetch.
     */
    where: WisdomPatternWhereUniqueInput
  }

  /**
   * WisdomPattern findUniqueOrThrow
   */
  export type WisdomPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * Filter, which WisdomPattern to fetch.
     */
    where: WisdomPatternWhereUniqueInput
  }

  /**
   * WisdomPattern findFirst
   */
  export type WisdomPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * Filter, which WisdomPattern to fetch.
     */
    where?: WisdomPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomPatterns to fetch.
     */
    orderBy?: WisdomPatternOrderByWithRelationInput | WisdomPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WisdomPatterns.
     */
    cursor?: WisdomPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WisdomPatterns.
     */
    distinct?: WisdomPatternScalarFieldEnum | WisdomPatternScalarFieldEnum[]
  }

  /**
   * WisdomPattern findFirstOrThrow
   */
  export type WisdomPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * Filter, which WisdomPattern to fetch.
     */
    where?: WisdomPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomPatterns to fetch.
     */
    orderBy?: WisdomPatternOrderByWithRelationInput | WisdomPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WisdomPatterns.
     */
    cursor?: WisdomPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WisdomPatterns.
     */
    distinct?: WisdomPatternScalarFieldEnum | WisdomPatternScalarFieldEnum[]
  }

  /**
   * WisdomPattern findMany
   */
  export type WisdomPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * Filter, which WisdomPatterns to fetch.
     */
    where?: WisdomPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WisdomPatterns to fetch.
     */
    orderBy?: WisdomPatternOrderByWithRelationInput | WisdomPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WisdomPatterns.
     */
    cursor?: WisdomPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WisdomPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WisdomPatterns.
     */
    skip?: number
    distinct?: WisdomPatternScalarFieldEnum | WisdomPatternScalarFieldEnum[]
  }

  /**
   * WisdomPattern create
   */
  export type WisdomPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * The data needed to create a WisdomPattern.
     */
    data: XOR<WisdomPatternCreateInput, WisdomPatternUncheckedCreateInput>
  }

  /**
   * WisdomPattern createMany
   */
  export type WisdomPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WisdomPatterns.
     */
    data: WisdomPatternCreateManyInput | WisdomPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WisdomPattern createManyAndReturn
   */
  export type WisdomPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WisdomPatterns.
     */
    data: WisdomPatternCreateManyInput | WisdomPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WisdomPattern update
   */
  export type WisdomPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * The data needed to update a WisdomPattern.
     */
    data: XOR<WisdomPatternUpdateInput, WisdomPatternUncheckedUpdateInput>
    /**
     * Choose, which WisdomPattern to update.
     */
    where: WisdomPatternWhereUniqueInput
  }

  /**
   * WisdomPattern updateMany
   */
  export type WisdomPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WisdomPatterns.
     */
    data: XOR<WisdomPatternUpdateManyMutationInput, WisdomPatternUncheckedUpdateManyInput>
    /**
     * Filter which WisdomPatterns to update
     */
    where?: WisdomPatternWhereInput
  }

  /**
   * WisdomPattern upsert
   */
  export type WisdomPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * The filter to search for the WisdomPattern to update in case it exists.
     */
    where: WisdomPatternWhereUniqueInput
    /**
     * In case the WisdomPattern found by the `where` argument doesn't exist, create a new WisdomPattern with this data.
     */
    create: XOR<WisdomPatternCreateInput, WisdomPatternUncheckedCreateInput>
    /**
     * In case the WisdomPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WisdomPatternUpdateInput, WisdomPatternUncheckedUpdateInput>
  }

  /**
   * WisdomPattern delete
   */
  export type WisdomPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
    /**
     * Filter which WisdomPattern to delete.
     */
    where: WisdomPatternWhereUniqueInput
  }

  /**
   * WisdomPattern deleteMany
   */
  export type WisdomPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WisdomPatterns to delete
     */
    where?: WisdomPatternWhereInput
  }

  /**
   * WisdomPattern without action
   */
  export type WisdomPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WisdomPattern
     */
    select?: WisdomPatternSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TokenScalarFieldEnum: {
    userId: 'userId',
    provider: 'provider',
    providerSub: 'providerSub',
    email: 'email',
    accessTokenEnc: 'accessTokenEnc',
    refreshTokenEnc: 'refreshTokenEnc',
    scope: 'scope',
    expiry: 'expiry',
    rotationFamilyId: 'rotationFamilyId',
    revokedAt: 'revokedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokenHash: 'tokenHash',
    deviceId: 'deviceId',
    userAgent: 'userAgent',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    rotatedFrom: 'rotatedFrom',
    revokedAt: 'revokedAt',
    lastUsedAt: 'lastUsedAt',
    reuseDetected: 'reuseDetected'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const MobileProfileScalarFieldEnum: {
    deviceId: 'deviceId',
    userId: 'userId',
    profile: 'profile',
    language: 'language',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type MobileProfileScalarFieldEnum = (typeof MobileProfileScalarFieldEnum)[keyof typeof MobileProfileScalarFieldEnum]


  export const UserSubscriptionScalarFieldEnum: {
    userId: 'userId',
    plan: 'plan',
    status: 'status',
    entitlementSource: 'entitlementSource',
    revenuecatEntitlementId: 'revenuecatEntitlementId',
    revenuecatOriginalTransactionId: 'revenuecatOriginalTransactionId',
    entitlementPayload: 'entitlementPayload',
    currentPeriodEnd: 'currentPeriodEnd',
    trialEnd: 'trialEnd',
    metadata: 'metadata',
    updatedAt: 'updatedAt'
  };

  export type UserSubscriptionScalarFieldEnum = (typeof UserSubscriptionScalarFieldEnum)[keyof typeof UserSubscriptionScalarFieldEnum]


  export const SubscriptionEventScalarFieldEnum: {
    eventId: 'eventId',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type SubscriptionEventScalarFieldEnum = (typeof SubscriptionEventScalarFieldEnum)[keyof typeof SubscriptionEventScalarFieldEnum]


  export const MonthlyVcGrantScalarFieldEnum: {
    userId: 'userId',
    grantMonth: 'grantMonth',
    reason: 'reason',
    minutes: 'minutes',
    grantedAt: 'grantedAt'
  };

  export type MonthlyVcGrantScalarFieldEnum = (typeof MonthlyVcGrantScalarFieldEnum)[keyof typeof MonthlyVcGrantScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    email: 'email',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const UserSettingScalarFieldEnum: {
    userId: 'userId',
    language: 'language',
    timezone: 'timezone',
    notificationsEnabled: 'notificationsEnabled',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingScalarFieldEnum = (typeof UserSettingScalarFieldEnum)[keyof typeof UserSettingScalarFieldEnum]


  export const UserTraitScalarFieldEnum: {
    userId: 'userId',
    ideals: 'ideals',
    struggles: 'struggles',
    big5: 'big5',
    keywords: 'keywords',
    summary: 'summary',
    nudgeIntensity: 'nudgeIntensity',
    stickyMode: 'stickyMode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTraitScalarFieldEnum = (typeof UserTraitScalarFieldEnum)[keyof typeof UserTraitScalarFieldEnum]


  export const DailyMetricScalarFieldEnum: {
    userId: 'userId',
    date: 'date',
    sleepDurationMin: 'sleepDurationMin',
    sleepStartAt: 'sleepStartAt',
    wakeAt: 'wakeAt',
    snsMinutesTotal: 'snsMinutesTotal',
    snsMinutesNight: 'snsMinutesNight',
    steps: 'steps',
    sedentaryMinutes: 'sedentaryMinutes',
    activitySummary: 'activitySummary',
    mindSummary: 'mindSummary',
    insights: 'insights',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DailyMetricScalarFieldEnum = (typeof DailyMetricScalarFieldEnum)[keyof typeof DailyMetricScalarFieldEnum]


  export const NudgeEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    domain: 'domain',
    subtype: 'subtype',
    decisionPoint: 'decisionPoint',
    state: 'state',
    actionTemplate: 'actionTemplate',
    channel: 'channel',
    sent: 'sent',
    createdAt: 'createdAt'
  };

  export type NudgeEventScalarFieldEnum = (typeof NudgeEventScalarFieldEnum)[keyof typeof NudgeEventScalarFieldEnum]


  export const NudgeOutcomeScalarFieldEnum: {
    id: 'id',
    nudgeEventId: 'nudgeEventId',
    reward: 'reward',
    shortTerm: 'shortTerm',
    emaScore: 'emaScore',
    signals: 'signals',
    createdAt: 'createdAt'
  };

  export type NudgeOutcomeScalarFieldEnum = (typeof NudgeOutcomeScalarFieldEnum)[keyof typeof NudgeOutcomeScalarFieldEnum]


  export const FeelingSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    feelingId: 'feelingId',
    topic: 'topic',
    actionTemplate: 'actionTemplate',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    emaBetter: 'emaBetter',
    summary: 'summary',
    transcript: 'transcript',
    context: 'context',
    createdAt: 'createdAt'
  };

  export type FeelingSessionScalarFieldEnum = (typeof FeelingSessionScalarFieldEnum)[keyof typeof FeelingSessionScalarFieldEnum]


  export const BanditModelScalarFieldEnum: {
    id: 'id',
    domain: 'domain',
    version: 'version',
    weights: 'weights',
    covariance: 'covariance',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BanditModelScalarFieldEnum = (typeof BanditModelScalarFieldEnum)[keyof typeof BanditModelScalarFieldEnum]


  export const UserTypeEstimateScalarFieldEnum: {
    userId: 'userId',
    primaryType: 'primaryType',
    typeScores: 'typeScores',
    confidence: 'confidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserTypeEstimateScalarFieldEnum = (typeof UserTypeEstimateScalarFieldEnum)[keyof typeof UserTypeEstimateScalarFieldEnum]


  export const TypeStatsScalarFieldEnum: {
    typeId: 'typeId',
    tone: 'tone',
    tappedCount: 'tappedCount',
    ignoredCount: 'ignoredCount',
    thumbsUpCount: 'thumbsUpCount',
    thumbsDownCount: 'thumbsDownCount',
    sampleSize: 'sampleSize',
    updatedAt: 'updatedAt'
  };

  export type TypeStatsScalarFieldEnum = (typeof TypeStatsScalarFieldEnum)[keyof typeof TypeStatsScalarFieldEnum]


  export const HookCandidateScalarFieldEnum: {
    id: 'id',
    text: 'text',
    tone: 'tone',
    targetProblemTypes: 'targetProblemTypes',
    targetUserTypes: 'targetUserTypes',
    appTapRate: 'appTapRate',
    appThumbsUpRate: 'appThumbsUpRate',
    appSampleSize: 'appSampleSize',
    tiktokLikeRate: 'tiktokLikeRate',
    tiktokShareRate: 'tiktokShareRate',
    tiktokSampleSize: 'tiktokSampleSize',
    tiktokHighPerformer: 'tiktokHighPerformer',
    isWisdom: 'isWisdom',
    explorationWeight: 'explorationWeight',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HookCandidateScalarFieldEnum = (typeof HookCandidateScalarFieldEnum)[keyof typeof HookCandidateScalarFieldEnum]


  export const TiktokPostScalarFieldEnum: {
    id: 'id',
    hookCandidateId: 'hookCandidateId',
    tiktokVideoId: 'tiktokVideoId',
    blotatoPostId: 'blotatoPostId',
    caption: 'caption',
    postedAt: 'postedAt',
    metricsFetchedAt: 'metricsFetchedAt',
    viewCount: 'viewCount',
    likeCount: 'likeCount',
    commentCount: 'commentCount',
    shareCount: 'shareCount',
    agentReasoning: 'agentReasoning',
    scheduledAt: 'scheduledAt',
    createdAt: 'createdAt'
  };

  export type TiktokPostScalarFieldEnum = (typeof TiktokPostScalarFieldEnum)[keyof typeof TiktokPostScalarFieldEnum]


  export const WisdomPatternScalarFieldEnum: {
    id: 'id',
    patternName: 'patternName',
    description: 'description',
    targetUserTypes: 'targetUserTypes',
    effectiveTone: 'effectiveTone',
    effectiveHookPattern: 'effectiveHookPattern',
    effectiveContentLength: 'effectiveContentLength',
    appEvidence: 'appEvidence',
    tiktokEvidence: 'tiktokEvidence',
    confidence: 'confidence',
    verifiedAt: 'verifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WisdomPatternScalarFieldEnum = (typeof WisdomPatternScalarFieldEnum)[keyof typeof WisdomPatternScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    
  /**
   * Deep Input Types
   */


  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    userId?: StringFilter<"Token"> | string
    provider?: StringFilter<"Token"> | string
    providerSub?: StringNullableFilter<"Token"> | string | null
    email?: StringNullableFilter<"Token"> | string | null
    accessTokenEnc?: JsonFilter<"Token">
    refreshTokenEnc?: JsonNullableFilter<"Token">
    scope?: StringNullableFilter<"Token"> | string | null
    expiry?: DateTimeNullableFilter<"Token"> | Date | string | null
    rotationFamilyId?: StringNullableFilter<"Token"> | string | null
    revokedAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type TokenOrderByWithRelationInput = {
    userId?: SortOrder
    provider?: SortOrder
    providerSub?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    rotationFamilyId?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    userId_provider?: TokenUserIdProviderCompoundUniqueInput
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    userId?: StringFilter<"Token"> | string
    provider?: StringFilter<"Token"> | string
    providerSub?: StringNullableFilter<"Token"> | string | null
    email?: StringNullableFilter<"Token"> | string | null
    accessTokenEnc?: JsonFilter<"Token">
    refreshTokenEnc?: JsonNullableFilter<"Token">
    scope?: StringNullableFilter<"Token"> | string | null
    expiry?: DateTimeNullableFilter<"Token"> | Date | string | null
    rotationFamilyId?: StringNullableFilter<"Token"> | string | null
    revokedAt?: DateTimeNullableFilter<"Token"> | Date | string | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
  }, "userId_provider">

  export type TokenOrderByWithAggregationInput = {
    userId?: SortOrder
    provider?: SortOrder
    providerSub?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    expiry?: SortOrderInput | SortOrder
    rotationFamilyId?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Token"> | string
    provider?: StringWithAggregatesFilter<"Token"> | string
    providerSub?: StringNullableWithAggregatesFilter<"Token"> | string | null
    email?: StringNullableWithAggregatesFilter<"Token"> | string | null
    accessTokenEnc?: JsonWithAggregatesFilter<"Token">
    refreshTokenEnc?: JsonNullableWithAggregatesFilter<"Token">
    scope?: StringNullableWithAggregatesFilter<"Token"> | string | null
    expiry?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
    rotationFamilyId?: StringNullableWithAggregatesFilter<"Token"> | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"Token"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: UuidFilter<"RefreshToken"> | string
    userId?: UuidFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    deviceId?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    rotatedFrom?: UuidNullableFilter<"RefreshToken"> | string | null
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    reuseDetected?: BoolFilter<"RefreshToken"> | boolean
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    rotatedFrom?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    reuseDetected?: SortOrder
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: UuidFilter<"RefreshToken"> | string
    tokenHash?: StringFilter<"RefreshToken"> | string
    deviceId?: StringFilter<"RefreshToken"> | string
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    rotatedFrom?: UuidNullableFilter<"RefreshToken"> | string | null
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    reuseDetected?: BoolFilter<"RefreshToken"> | boolean
  }, "id">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    rotatedFrom?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    reuseDetected?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"RefreshToken"> | string
    userId?: UuidWithAggregatesFilter<"RefreshToken"> | string
    tokenHash?: StringWithAggregatesFilter<"RefreshToken"> | string
    deviceId?: StringWithAggregatesFilter<"RefreshToken"> | string
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    rotatedFrom?: UuidNullableWithAggregatesFilter<"RefreshToken"> | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    reuseDetected?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
  }

  export type MobileProfileWhereInput = {
    AND?: MobileProfileWhereInput | MobileProfileWhereInput[]
    OR?: MobileProfileWhereInput[]
    NOT?: MobileProfileWhereInput | MobileProfileWhereInput[]
    deviceId?: StringFilter<"MobileProfile"> | string
    userId?: StringFilter<"MobileProfile"> | string
    profile?: JsonFilter<"MobileProfile">
    language?: StringFilter<"MobileProfile"> | string
    updatedAt?: DateTimeNullableFilter<"MobileProfile"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"MobileProfile"> | Date | string | null
  }

  export type MobileProfileOrderByWithRelationInput = {
    deviceId?: SortOrder
    userId?: SortOrder
    profile?: SortOrder
    language?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type MobileProfileWhereUniqueInput = Prisma.AtLeast<{
    deviceId?: string
    AND?: MobileProfileWhereInput | MobileProfileWhereInput[]
    OR?: MobileProfileWhereInput[]
    NOT?: MobileProfileWhereInput | MobileProfileWhereInput[]
    userId?: StringFilter<"MobileProfile"> | string
    profile?: JsonFilter<"MobileProfile">
    language?: StringFilter<"MobileProfile"> | string
    updatedAt?: DateTimeNullableFilter<"MobileProfile"> | Date | string | null
    createdAt?: DateTimeNullableFilter<"MobileProfile"> | Date | string | null
  }, "deviceId">

  export type MobileProfileOrderByWithAggregationInput = {
    deviceId?: SortOrder
    userId?: SortOrder
    profile?: SortOrder
    language?: SortOrder
    updatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: MobileProfileCountOrderByAggregateInput
    _max?: MobileProfileMaxOrderByAggregateInput
    _min?: MobileProfileMinOrderByAggregateInput
  }

  export type MobileProfileScalarWhereWithAggregatesInput = {
    AND?: MobileProfileScalarWhereWithAggregatesInput | MobileProfileScalarWhereWithAggregatesInput[]
    OR?: MobileProfileScalarWhereWithAggregatesInput[]
    NOT?: MobileProfileScalarWhereWithAggregatesInput | MobileProfileScalarWhereWithAggregatesInput[]
    deviceId?: StringWithAggregatesFilter<"MobileProfile"> | string
    userId?: StringWithAggregatesFilter<"MobileProfile"> | string
    profile?: JsonWithAggregatesFilter<"MobileProfile">
    language?: StringWithAggregatesFilter<"MobileProfile"> | string
    updatedAt?: DateTimeNullableWithAggregatesFilter<"MobileProfile"> | Date | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"MobileProfile"> | Date | string | null
  }

  export type UserSubscriptionWhereInput = {
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    userId?: StringFilter<"UserSubscription"> | string
    plan?: StringFilter<"UserSubscription"> | string
    status?: StringFilter<"UserSubscription"> | string
    entitlementSource?: StringFilter<"UserSubscription"> | string
    revenuecatEntitlementId?: StringNullableFilter<"UserSubscription"> | string | null
    revenuecatOriginalTransactionId?: StringNullableFilter<"UserSubscription"> | string | null
    entitlementPayload?: JsonNullableFilter<"UserSubscription">
    currentPeriodEnd?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    metadata?: JsonFilter<"UserSubscription">
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
  }

  export type UserSubscriptionOrderByWithRelationInput = {
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    entitlementSource?: SortOrder
    revenuecatEntitlementId?: SortOrderInput | SortOrder
    revenuecatOriginalTransactionId?: SortOrderInput | SortOrder
    entitlementPayload?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    metadata?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    OR?: UserSubscriptionWhereInput[]
    NOT?: UserSubscriptionWhereInput | UserSubscriptionWhereInput[]
    plan?: StringFilter<"UserSubscription"> | string
    status?: StringFilter<"UserSubscription"> | string
    entitlementSource?: StringFilter<"UserSubscription"> | string
    revenuecatEntitlementId?: StringNullableFilter<"UserSubscription"> | string | null
    revenuecatOriginalTransactionId?: StringNullableFilter<"UserSubscription"> | string | null
    entitlementPayload?: JsonNullableFilter<"UserSubscription">
    currentPeriodEnd?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableFilter<"UserSubscription"> | Date | string | null
    metadata?: JsonFilter<"UserSubscription">
    updatedAt?: DateTimeFilter<"UserSubscription"> | Date | string
  }, "userId">

  export type UserSubscriptionOrderByWithAggregationInput = {
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    entitlementSource?: SortOrder
    revenuecatEntitlementId?: SortOrderInput | SortOrder
    revenuecatOriginalTransactionId?: SortOrderInput | SortOrder
    entitlementPayload?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    trialEnd?: SortOrderInput | SortOrder
    metadata?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSubscriptionCountOrderByAggregateInput
    _max?: UserSubscriptionMaxOrderByAggregateInput
    _min?: UserSubscriptionMinOrderByAggregateInput
  }

  export type UserSubscriptionScalarWhereWithAggregatesInput = {
    AND?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    OR?: UserSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: UserSubscriptionScalarWhereWithAggregatesInput | UserSubscriptionScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSubscription"> | string
    plan?: StringWithAggregatesFilter<"UserSubscription"> | string
    status?: StringWithAggregatesFilter<"UserSubscription"> | string
    entitlementSource?: StringWithAggregatesFilter<"UserSubscription"> | string
    revenuecatEntitlementId?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    revenuecatOriginalTransactionId?: StringNullableWithAggregatesFilter<"UserSubscription"> | string | null
    entitlementPayload?: JsonNullableWithAggregatesFilter<"UserSubscription">
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    trialEnd?: DateTimeNullableWithAggregatesFilter<"UserSubscription"> | Date | string | null
    metadata?: JsonWithAggregatesFilter<"UserSubscription">
    updatedAt?: DateTimeWithAggregatesFilter<"UserSubscription"> | Date | string
  }

  export type SubscriptionEventWhereInput = {
    AND?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    OR?: SubscriptionEventWhereInput[]
    NOT?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    eventId?: StringFilter<"SubscriptionEvent"> | string
    userId?: StringNullableFilter<"SubscriptionEvent"> | string | null
    type?: StringFilter<"SubscriptionEvent"> | string
    provider?: StringFilter<"SubscriptionEvent"> | string
    payload?: JsonNullableFilter<"SubscriptionEvent">
    createdAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
  }

  export type SubscriptionEventOrderByWithRelationInput = {
    eventId?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    provider?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionEventWhereUniqueInput = Prisma.AtLeast<{
    eventId?: string
    AND?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    OR?: SubscriptionEventWhereInput[]
    NOT?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    userId?: StringNullableFilter<"SubscriptionEvent"> | string | null
    type?: StringFilter<"SubscriptionEvent"> | string
    provider?: StringFilter<"SubscriptionEvent"> | string
    payload?: JsonNullableFilter<"SubscriptionEvent">
    createdAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
  }, "eventId">

  export type SubscriptionEventOrderByWithAggregationInput = {
    eventId?: SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    provider?: SortOrder
    payload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SubscriptionEventCountOrderByAggregateInput
    _max?: SubscriptionEventMaxOrderByAggregateInput
    _min?: SubscriptionEventMinOrderByAggregateInput
  }

  export type SubscriptionEventScalarWhereWithAggregatesInput = {
    AND?: SubscriptionEventScalarWhereWithAggregatesInput | SubscriptionEventScalarWhereWithAggregatesInput[]
    OR?: SubscriptionEventScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionEventScalarWhereWithAggregatesInput | SubscriptionEventScalarWhereWithAggregatesInput[]
    eventId?: StringWithAggregatesFilter<"SubscriptionEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"SubscriptionEvent"> | string | null
    type?: StringWithAggregatesFilter<"SubscriptionEvent"> | string
    provider?: StringWithAggregatesFilter<"SubscriptionEvent"> | string
    payload?: JsonNullableWithAggregatesFilter<"SubscriptionEvent">
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionEvent"> | Date | string
  }

  export type MonthlyVcGrantWhereInput = {
    AND?: MonthlyVcGrantWhereInput | MonthlyVcGrantWhereInput[]
    OR?: MonthlyVcGrantWhereInput[]
    NOT?: MonthlyVcGrantWhereInput | MonthlyVcGrantWhereInput[]
    userId?: StringFilter<"MonthlyVcGrant"> | string
    grantMonth?: DateTimeFilter<"MonthlyVcGrant"> | Date | string
    reason?: StringFilter<"MonthlyVcGrant"> | string
    minutes?: IntFilter<"MonthlyVcGrant"> | number
    grantedAt?: DateTimeFilter<"MonthlyVcGrant"> | Date | string
  }

  export type MonthlyVcGrantOrderByWithRelationInput = {
    userId?: SortOrder
    grantMonth?: SortOrder
    reason?: SortOrder
    minutes?: SortOrder
    grantedAt?: SortOrder
  }

  export type MonthlyVcGrantWhereUniqueInput = Prisma.AtLeast<{
    userId_grantMonth_reason?: MonthlyVcGrantUserIdGrantMonthReasonCompoundUniqueInput
    AND?: MonthlyVcGrantWhereInput | MonthlyVcGrantWhereInput[]
    OR?: MonthlyVcGrantWhereInput[]
    NOT?: MonthlyVcGrantWhereInput | MonthlyVcGrantWhereInput[]
    userId?: StringFilter<"MonthlyVcGrant"> | string
    grantMonth?: DateTimeFilter<"MonthlyVcGrant"> | Date | string
    reason?: StringFilter<"MonthlyVcGrant"> | string
    minutes?: IntFilter<"MonthlyVcGrant"> | number
    grantedAt?: DateTimeFilter<"MonthlyVcGrant"> | Date | string
  }, "userId_grantMonth_reason">

  export type MonthlyVcGrantOrderByWithAggregationInput = {
    userId?: SortOrder
    grantMonth?: SortOrder
    reason?: SortOrder
    minutes?: SortOrder
    grantedAt?: SortOrder
    _count?: MonthlyVcGrantCountOrderByAggregateInput
    _avg?: MonthlyVcGrantAvgOrderByAggregateInput
    _max?: MonthlyVcGrantMaxOrderByAggregateInput
    _min?: MonthlyVcGrantMinOrderByAggregateInput
    _sum?: MonthlyVcGrantSumOrderByAggregateInput
  }

  export type MonthlyVcGrantScalarWhereWithAggregatesInput = {
    AND?: MonthlyVcGrantScalarWhereWithAggregatesInput | MonthlyVcGrantScalarWhereWithAggregatesInput[]
    OR?: MonthlyVcGrantScalarWhereWithAggregatesInput[]
    NOT?: MonthlyVcGrantScalarWhereWithAggregatesInput | MonthlyVcGrantScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"MonthlyVcGrant"> | string
    grantMonth?: DateTimeWithAggregatesFilter<"MonthlyVcGrant"> | Date | string
    reason?: StringWithAggregatesFilter<"MonthlyVcGrant"> | string
    minutes?: IntWithAggregatesFilter<"MonthlyVcGrant"> | number
    grantedAt?: DateTimeWithAggregatesFilter<"MonthlyVcGrant"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: UuidFilter<"Profile"> | string
    email?: StringNullableFilter<"Profile"> | string | null
    metadata?: JsonFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    settings?: XOR<UserSettingNullableRelationFilter, UserSettingWhereInput> | null
    userTypeEstimate?: XOR<UserTypeEstimateNullableRelationFilter, UserTypeEstimateWhereInput> | null
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settings?: UserSettingOrderByWithRelationInput
    userTypeEstimate?: UserTypeEstimateOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    metadata?: JsonFilter<"Profile">
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    settings?: XOR<UserSettingNullableRelationFilter, UserSettingWhereInput> | null
    userTypeEstimate?: XOR<UserTypeEstimateNullableRelationFilter, UserTypeEstimateWhereInput> | null
  }, "id" | "email">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Profile"> | string
    email?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    metadata?: JsonWithAggregatesFilter<"Profile">
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type UserSettingWhereInput = {
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    userId?: UuidFilter<"UserSetting"> | string
    language?: StringFilter<"UserSetting"> | string
    timezone?: StringFilter<"UserSetting"> | string
    notificationsEnabled?: BoolFilter<"UserSetting"> | boolean
    preferences?: JsonFilter<"UserSetting">
    createdAt?: DateTimeFilter<"UserSetting"> | Date | string
    updatedAt?: DateTimeFilter<"UserSetting"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type UserSettingOrderByWithRelationInput = {
    userId?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    notificationsEnabled?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserSettingWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserSettingWhereInput | UserSettingWhereInput[]
    OR?: UserSettingWhereInput[]
    NOT?: UserSettingWhereInput | UserSettingWhereInput[]
    language?: StringFilter<"UserSetting"> | string
    timezone?: StringFilter<"UserSetting"> | string
    notificationsEnabled?: BoolFilter<"UserSetting"> | boolean
    preferences?: JsonFilter<"UserSetting">
    createdAt?: DateTimeFilter<"UserSetting"> | Date | string
    updatedAt?: DateTimeFilter<"UserSetting"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "userId">

  export type UserSettingOrderByWithAggregationInput = {
    userId?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    notificationsEnabled?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingCountOrderByAggregateInput
    _max?: UserSettingMaxOrderByAggregateInput
    _min?: UserSettingMinOrderByAggregateInput
  }

  export type UserSettingScalarWhereWithAggregatesInput = {
    AND?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    OR?: UserSettingScalarWhereWithAggregatesInput[]
    NOT?: UserSettingScalarWhereWithAggregatesInput | UserSettingScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserSetting"> | string
    language?: StringWithAggregatesFilter<"UserSetting"> | string
    timezone?: StringWithAggregatesFilter<"UserSetting"> | string
    notificationsEnabled?: BoolWithAggregatesFilter<"UserSetting"> | boolean
    preferences?: JsonWithAggregatesFilter<"UserSetting">
    createdAt?: DateTimeWithAggregatesFilter<"UserSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSetting"> | Date | string
  }

  export type UserTraitWhereInput = {
    AND?: UserTraitWhereInput | UserTraitWhereInput[]
    OR?: UserTraitWhereInput[]
    NOT?: UserTraitWhereInput | UserTraitWhereInput[]
    userId?: UuidFilter<"UserTrait"> | string
    ideals?: StringNullableListFilter<"UserTrait">
    struggles?: StringNullableListFilter<"UserTrait">
    big5?: JsonFilter<"UserTrait">
    keywords?: StringNullableListFilter<"UserTrait">
    summary?: StringFilter<"UserTrait"> | string
    nudgeIntensity?: StringFilter<"UserTrait"> | string
    stickyMode?: BoolFilter<"UserTrait"> | boolean
    createdAt?: DateTimeFilter<"UserTrait"> | Date | string
    updatedAt?: DateTimeFilter<"UserTrait"> | Date | string
  }

  export type UserTraitOrderByWithRelationInput = {
    userId?: SortOrder
    ideals?: SortOrder
    struggles?: SortOrder
    big5?: SortOrder
    keywords?: SortOrder
    summary?: SortOrder
    nudgeIntensity?: SortOrder
    stickyMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTraitWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserTraitWhereInput | UserTraitWhereInput[]
    OR?: UserTraitWhereInput[]
    NOT?: UserTraitWhereInput | UserTraitWhereInput[]
    ideals?: StringNullableListFilter<"UserTrait">
    struggles?: StringNullableListFilter<"UserTrait">
    big5?: JsonFilter<"UserTrait">
    keywords?: StringNullableListFilter<"UserTrait">
    summary?: StringFilter<"UserTrait"> | string
    nudgeIntensity?: StringFilter<"UserTrait"> | string
    stickyMode?: BoolFilter<"UserTrait"> | boolean
    createdAt?: DateTimeFilter<"UserTrait"> | Date | string
    updatedAt?: DateTimeFilter<"UserTrait"> | Date | string
  }, "userId">

  export type UserTraitOrderByWithAggregationInput = {
    userId?: SortOrder
    ideals?: SortOrder
    struggles?: SortOrder
    big5?: SortOrder
    keywords?: SortOrder
    summary?: SortOrder
    nudgeIntensity?: SortOrder
    stickyMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTraitCountOrderByAggregateInput
    _max?: UserTraitMaxOrderByAggregateInput
    _min?: UserTraitMinOrderByAggregateInput
  }

  export type UserTraitScalarWhereWithAggregatesInput = {
    AND?: UserTraitScalarWhereWithAggregatesInput | UserTraitScalarWhereWithAggregatesInput[]
    OR?: UserTraitScalarWhereWithAggregatesInput[]
    NOT?: UserTraitScalarWhereWithAggregatesInput | UserTraitScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserTrait"> | string
    ideals?: StringNullableListFilter<"UserTrait">
    struggles?: StringNullableListFilter<"UserTrait">
    big5?: JsonWithAggregatesFilter<"UserTrait">
    keywords?: StringNullableListFilter<"UserTrait">
    summary?: StringWithAggregatesFilter<"UserTrait"> | string
    nudgeIntensity?: StringWithAggregatesFilter<"UserTrait"> | string
    stickyMode?: BoolWithAggregatesFilter<"UserTrait"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserTrait"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTrait"> | Date | string
  }

  export type DailyMetricWhereInput = {
    AND?: DailyMetricWhereInput | DailyMetricWhereInput[]
    OR?: DailyMetricWhereInput[]
    NOT?: DailyMetricWhereInput | DailyMetricWhereInput[]
    userId?: UuidFilter<"DailyMetric"> | string
    date?: DateTimeFilter<"DailyMetric"> | Date | string
    sleepDurationMin?: IntNullableFilter<"DailyMetric"> | number | null
    sleepStartAt?: DateTimeNullableFilter<"DailyMetric"> | Date | string | null
    wakeAt?: DateTimeNullableFilter<"DailyMetric"> | Date | string | null
    snsMinutesTotal?: IntFilter<"DailyMetric"> | number
    snsMinutesNight?: IntFilter<"DailyMetric"> | number
    steps?: IntFilter<"DailyMetric"> | number
    sedentaryMinutes?: IntFilter<"DailyMetric"> | number
    activitySummary?: JsonFilter<"DailyMetric">
    mindSummary?: JsonFilter<"DailyMetric">
    insights?: JsonFilter<"DailyMetric">
    createdAt?: DateTimeFilter<"DailyMetric"> | Date | string
    updatedAt?: DateTimeFilter<"DailyMetric"> | Date | string
  }

  export type DailyMetricOrderByWithRelationInput = {
    userId?: SortOrder
    date?: SortOrder
    sleepDurationMin?: SortOrderInput | SortOrder
    sleepStartAt?: SortOrderInput | SortOrder
    wakeAt?: SortOrderInput | SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
    activitySummary?: SortOrder
    mindSummary?: SortOrder
    insights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyMetricWhereUniqueInput = Prisma.AtLeast<{
    userId_date?: DailyMetricUserIdDateCompoundUniqueInput
    AND?: DailyMetricWhereInput | DailyMetricWhereInput[]
    OR?: DailyMetricWhereInput[]
    NOT?: DailyMetricWhereInput | DailyMetricWhereInput[]
    userId?: UuidFilter<"DailyMetric"> | string
    date?: DateTimeFilter<"DailyMetric"> | Date | string
    sleepDurationMin?: IntNullableFilter<"DailyMetric"> | number | null
    sleepStartAt?: DateTimeNullableFilter<"DailyMetric"> | Date | string | null
    wakeAt?: DateTimeNullableFilter<"DailyMetric"> | Date | string | null
    snsMinutesTotal?: IntFilter<"DailyMetric"> | number
    snsMinutesNight?: IntFilter<"DailyMetric"> | number
    steps?: IntFilter<"DailyMetric"> | number
    sedentaryMinutes?: IntFilter<"DailyMetric"> | number
    activitySummary?: JsonFilter<"DailyMetric">
    mindSummary?: JsonFilter<"DailyMetric">
    insights?: JsonFilter<"DailyMetric">
    createdAt?: DateTimeFilter<"DailyMetric"> | Date | string
    updatedAt?: DateTimeFilter<"DailyMetric"> | Date | string
  }, "userId_date">

  export type DailyMetricOrderByWithAggregationInput = {
    userId?: SortOrder
    date?: SortOrder
    sleepDurationMin?: SortOrderInput | SortOrder
    sleepStartAt?: SortOrderInput | SortOrder
    wakeAt?: SortOrderInput | SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
    activitySummary?: SortOrder
    mindSummary?: SortOrder
    insights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DailyMetricCountOrderByAggregateInput
    _avg?: DailyMetricAvgOrderByAggregateInput
    _max?: DailyMetricMaxOrderByAggregateInput
    _min?: DailyMetricMinOrderByAggregateInput
    _sum?: DailyMetricSumOrderByAggregateInput
  }

  export type DailyMetricScalarWhereWithAggregatesInput = {
    AND?: DailyMetricScalarWhereWithAggregatesInput | DailyMetricScalarWhereWithAggregatesInput[]
    OR?: DailyMetricScalarWhereWithAggregatesInput[]
    NOT?: DailyMetricScalarWhereWithAggregatesInput | DailyMetricScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"DailyMetric"> | string
    date?: DateTimeWithAggregatesFilter<"DailyMetric"> | Date | string
    sleepDurationMin?: IntNullableWithAggregatesFilter<"DailyMetric"> | number | null
    sleepStartAt?: DateTimeNullableWithAggregatesFilter<"DailyMetric"> | Date | string | null
    wakeAt?: DateTimeNullableWithAggregatesFilter<"DailyMetric"> | Date | string | null
    snsMinutesTotal?: IntWithAggregatesFilter<"DailyMetric"> | number
    snsMinutesNight?: IntWithAggregatesFilter<"DailyMetric"> | number
    steps?: IntWithAggregatesFilter<"DailyMetric"> | number
    sedentaryMinutes?: IntWithAggregatesFilter<"DailyMetric"> | number
    activitySummary?: JsonWithAggregatesFilter<"DailyMetric">
    mindSummary?: JsonWithAggregatesFilter<"DailyMetric">
    insights?: JsonWithAggregatesFilter<"DailyMetric">
    createdAt?: DateTimeWithAggregatesFilter<"DailyMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DailyMetric"> | Date | string
  }

  export type NudgeEventWhereInput = {
    AND?: NudgeEventWhereInput | NudgeEventWhereInput[]
    OR?: NudgeEventWhereInput[]
    NOT?: NudgeEventWhereInput | NudgeEventWhereInput[]
    id?: UuidFilter<"NudgeEvent"> | string
    userId?: UuidFilter<"NudgeEvent"> | string
    domain?: StringFilter<"NudgeEvent"> | string
    subtype?: StringFilter<"NudgeEvent"> | string
    decisionPoint?: StringFilter<"NudgeEvent"> | string
    state?: JsonFilter<"NudgeEvent">
    actionTemplate?: StringNullableFilter<"NudgeEvent"> | string | null
    channel?: StringFilter<"NudgeEvent"> | string
    sent?: BoolFilter<"NudgeEvent"> | boolean
    createdAt?: DateTimeFilter<"NudgeEvent"> | Date | string
    outcomes?: NudgeOutcomeListRelationFilter
  }

  export type NudgeEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    subtype?: SortOrder
    decisionPoint?: SortOrder
    state?: SortOrder
    actionTemplate?: SortOrderInput | SortOrder
    channel?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    outcomes?: NudgeOutcomeOrderByRelationAggregateInput
  }

  export type NudgeEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NudgeEventWhereInput | NudgeEventWhereInput[]
    OR?: NudgeEventWhereInput[]
    NOT?: NudgeEventWhereInput | NudgeEventWhereInput[]
    userId?: UuidFilter<"NudgeEvent"> | string
    domain?: StringFilter<"NudgeEvent"> | string
    subtype?: StringFilter<"NudgeEvent"> | string
    decisionPoint?: StringFilter<"NudgeEvent"> | string
    state?: JsonFilter<"NudgeEvent">
    actionTemplate?: StringNullableFilter<"NudgeEvent"> | string | null
    channel?: StringFilter<"NudgeEvent"> | string
    sent?: BoolFilter<"NudgeEvent"> | boolean
    createdAt?: DateTimeFilter<"NudgeEvent"> | Date | string
    outcomes?: NudgeOutcomeListRelationFilter
  }, "id">

  export type NudgeEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    subtype?: SortOrder
    decisionPoint?: SortOrder
    state?: SortOrder
    actionTemplate?: SortOrderInput | SortOrder
    channel?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
    _count?: NudgeEventCountOrderByAggregateInput
    _max?: NudgeEventMaxOrderByAggregateInput
    _min?: NudgeEventMinOrderByAggregateInput
  }

  export type NudgeEventScalarWhereWithAggregatesInput = {
    AND?: NudgeEventScalarWhereWithAggregatesInput | NudgeEventScalarWhereWithAggregatesInput[]
    OR?: NudgeEventScalarWhereWithAggregatesInput[]
    NOT?: NudgeEventScalarWhereWithAggregatesInput | NudgeEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NudgeEvent"> | string
    userId?: UuidWithAggregatesFilter<"NudgeEvent"> | string
    domain?: StringWithAggregatesFilter<"NudgeEvent"> | string
    subtype?: StringWithAggregatesFilter<"NudgeEvent"> | string
    decisionPoint?: StringWithAggregatesFilter<"NudgeEvent"> | string
    state?: JsonWithAggregatesFilter<"NudgeEvent">
    actionTemplate?: StringNullableWithAggregatesFilter<"NudgeEvent"> | string | null
    channel?: StringWithAggregatesFilter<"NudgeEvent"> | string
    sent?: BoolWithAggregatesFilter<"NudgeEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NudgeEvent"> | Date | string
  }

  export type NudgeOutcomeWhereInput = {
    AND?: NudgeOutcomeWhereInput | NudgeOutcomeWhereInput[]
    OR?: NudgeOutcomeWhereInput[]
    NOT?: NudgeOutcomeWhereInput | NudgeOutcomeWhereInput[]
    id?: UuidFilter<"NudgeOutcome"> | string
    nudgeEventId?: UuidFilter<"NudgeOutcome"> | string
    reward?: FloatNullableFilter<"NudgeOutcome"> | number | null
    shortTerm?: JsonFilter<"NudgeOutcome">
    emaScore?: JsonNullableFilter<"NudgeOutcome">
    signals?: JsonFilter<"NudgeOutcome">
    createdAt?: DateTimeFilter<"NudgeOutcome"> | Date | string
    event?: XOR<NudgeEventRelationFilter, NudgeEventWhereInput>
  }

  export type NudgeOutcomeOrderByWithRelationInput = {
    id?: SortOrder
    nudgeEventId?: SortOrder
    reward?: SortOrderInput | SortOrder
    shortTerm?: SortOrder
    emaScore?: SortOrderInput | SortOrder
    signals?: SortOrder
    createdAt?: SortOrder
    event?: NudgeEventOrderByWithRelationInput
  }

  export type NudgeOutcomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NudgeOutcomeWhereInput | NudgeOutcomeWhereInput[]
    OR?: NudgeOutcomeWhereInput[]
    NOT?: NudgeOutcomeWhereInput | NudgeOutcomeWhereInput[]
    nudgeEventId?: UuidFilter<"NudgeOutcome"> | string
    reward?: FloatNullableFilter<"NudgeOutcome"> | number | null
    shortTerm?: JsonFilter<"NudgeOutcome">
    emaScore?: JsonNullableFilter<"NudgeOutcome">
    signals?: JsonFilter<"NudgeOutcome">
    createdAt?: DateTimeFilter<"NudgeOutcome"> | Date | string
    event?: XOR<NudgeEventRelationFilter, NudgeEventWhereInput>
  }, "id">

  export type NudgeOutcomeOrderByWithAggregationInput = {
    id?: SortOrder
    nudgeEventId?: SortOrder
    reward?: SortOrderInput | SortOrder
    shortTerm?: SortOrder
    emaScore?: SortOrderInput | SortOrder
    signals?: SortOrder
    createdAt?: SortOrder
    _count?: NudgeOutcomeCountOrderByAggregateInput
    _avg?: NudgeOutcomeAvgOrderByAggregateInput
    _max?: NudgeOutcomeMaxOrderByAggregateInput
    _min?: NudgeOutcomeMinOrderByAggregateInput
    _sum?: NudgeOutcomeSumOrderByAggregateInput
  }

  export type NudgeOutcomeScalarWhereWithAggregatesInput = {
    AND?: NudgeOutcomeScalarWhereWithAggregatesInput | NudgeOutcomeScalarWhereWithAggregatesInput[]
    OR?: NudgeOutcomeScalarWhereWithAggregatesInput[]
    NOT?: NudgeOutcomeScalarWhereWithAggregatesInput | NudgeOutcomeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"NudgeOutcome"> | string
    nudgeEventId?: UuidWithAggregatesFilter<"NudgeOutcome"> | string
    reward?: FloatNullableWithAggregatesFilter<"NudgeOutcome"> | number | null
    shortTerm?: JsonWithAggregatesFilter<"NudgeOutcome">
    emaScore?: JsonNullableWithAggregatesFilter<"NudgeOutcome">
    signals?: JsonWithAggregatesFilter<"NudgeOutcome">
    createdAt?: DateTimeWithAggregatesFilter<"NudgeOutcome"> | Date | string
  }

  export type FeelingSessionWhereInput = {
    AND?: FeelingSessionWhereInput | FeelingSessionWhereInput[]
    OR?: FeelingSessionWhereInput[]
    NOT?: FeelingSessionWhereInput | FeelingSessionWhereInput[]
    id?: UuidFilter<"FeelingSession"> | string
    userId?: UuidFilter<"FeelingSession"> | string
    feelingId?: StringFilter<"FeelingSession"> | string
    topic?: StringNullableFilter<"FeelingSession"> | string | null
    actionTemplate?: StringNullableFilter<"FeelingSession"> | string | null
    startedAt?: DateTimeFilter<"FeelingSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"FeelingSession"> | Date | string | null
    emaBetter?: BoolNullableFilter<"FeelingSession"> | boolean | null
    summary?: StringNullableFilter<"FeelingSession"> | string | null
    transcript?: JsonNullableFilter<"FeelingSession">
    context?: JsonFilter<"FeelingSession">
    createdAt?: DateTimeFilter<"FeelingSession"> | Date | string
  }

  export type FeelingSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    feelingId?: SortOrder
    topic?: SortOrderInput | SortOrder
    actionTemplate?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    emaBetter?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type FeelingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeelingSessionWhereInput | FeelingSessionWhereInput[]
    OR?: FeelingSessionWhereInput[]
    NOT?: FeelingSessionWhereInput | FeelingSessionWhereInput[]
    userId?: UuidFilter<"FeelingSession"> | string
    feelingId?: StringFilter<"FeelingSession"> | string
    topic?: StringNullableFilter<"FeelingSession"> | string | null
    actionTemplate?: StringNullableFilter<"FeelingSession"> | string | null
    startedAt?: DateTimeFilter<"FeelingSession"> | Date | string
    endedAt?: DateTimeNullableFilter<"FeelingSession"> | Date | string | null
    emaBetter?: BoolNullableFilter<"FeelingSession"> | boolean | null
    summary?: StringNullableFilter<"FeelingSession"> | string | null
    transcript?: JsonNullableFilter<"FeelingSession">
    context?: JsonFilter<"FeelingSession">
    createdAt?: DateTimeFilter<"FeelingSession"> | Date | string
  }, "id">

  export type FeelingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    feelingId?: SortOrder
    topic?: SortOrderInput | SortOrder
    actionTemplate?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    emaBetter?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    context?: SortOrder
    createdAt?: SortOrder
    _count?: FeelingSessionCountOrderByAggregateInput
    _max?: FeelingSessionMaxOrderByAggregateInput
    _min?: FeelingSessionMinOrderByAggregateInput
  }

  export type FeelingSessionScalarWhereWithAggregatesInput = {
    AND?: FeelingSessionScalarWhereWithAggregatesInput | FeelingSessionScalarWhereWithAggregatesInput[]
    OR?: FeelingSessionScalarWhereWithAggregatesInput[]
    NOT?: FeelingSessionScalarWhereWithAggregatesInput | FeelingSessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FeelingSession"> | string
    userId?: UuidWithAggregatesFilter<"FeelingSession"> | string
    feelingId?: StringWithAggregatesFilter<"FeelingSession"> | string
    topic?: StringNullableWithAggregatesFilter<"FeelingSession"> | string | null
    actionTemplate?: StringNullableWithAggregatesFilter<"FeelingSession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"FeelingSession"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"FeelingSession"> | Date | string | null
    emaBetter?: BoolNullableWithAggregatesFilter<"FeelingSession"> | boolean | null
    summary?: StringNullableWithAggregatesFilter<"FeelingSession"> | string | null
    transcript?: JsonNullableWithAggregatesFilter<"FeelingSession">
    context?: JsonWithAggregatesFilter<"FeelingSession">
    createdAt?: DateTimeWithAggregatesFilter<"FeelingSession"> | Date | string
  }

  export type BanditModelWhereInput = {
    AND?: BanditModelWhereInput | BanditModelWhereInput[]
    OR?: BanditModelWhereInput[]
    NOT?: BanditModelWhereInput | BanditModelWhereInput[]
    id?: UuidFilter<"BanditModel"> | string
    domain?: StringFilter<"BanditModel"> | string
    version?: IntFilter<"BanditModel"> | number
    weights?: JsonFilter<"BanditModel">
    covariance?: JsonFilter<"BanditModel">
    meta?: JsonFilter<"BanditModel">
    createdAt?: DateTimeFilter<"BanditModel"> | Date | string
    updatedAt?: DateTimeFilter<"BanditModel"> | Date | string
  }

  export type BanditModelOrderByWithRelationInput = {
    id?: SortOrder
    domain?: SortOrder
    version?: SortOrder
    weights?: SortOrder
    covariance?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanditModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain_version?: BanditModelDomainVersionCompoundUniqueInput
    AND?: BanditModelWhereInput | BanditModelWhereInput[]
    OR?: BanditModelWhereInput[]
    NOT?: BanditModelWhereInput | BanditModelWhereInput[]
    domain?: StringFilter<"BanditModel"> | string
    version?: IntFilter<"BanditModel"> | number
    weights?: JsonFilter<"BanditModel">
    covariance?: JsonFilter<"BanditModel">
    meta?: JsonFilter<"BanditModel">
    createdAt?: DateTimeFilter<"BanditModel"> | Date | string
    updatedAt?: DateTimeFilter<"BanditModel"> | Date | string
  }, "id" | "domain_version">

  export type BanditModelOrderByWithAggregationInput = {
    id?: SortOrder
    domain?: SortOrder
    version?: SortOrder
    weights?: SortOrder
    covariance?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BanditModelCountOrderByAggregateInput
    _avg?: BanditModelAvgOrderByAggregateInput
    _max?: BanditModelMaxOrderByAggregateInput
    _min?: BanditModelMinOrderByAggregateInput
    _sum?: BanditModelSumOrderByAggregateInput
  }

  export type BanditModelScalarWhereWithAggregatesInput = {
    AND?: BanditModelScalarWhereWithAggregatesInput | BanditModelScalarWhereWithAggregatesInput[]
    OR?: BanditModelScalarWhereWithAggregatesInput[]
    NOT?: BanditModelScalarWhereWithAggregatesInput | BanditModelScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BanditModel"> | string
    domain?: StringWithAggregatesFilter<"BanditModel"> | string
    version?: IntWithAggregatesFilter<"BanditModel"> | number
    weights?: JsonWithAggregatesFilter<"BanditModel">
    covariance?: JsonWithAggregatesFilter<"BanditModel">
    meta?: JsonWithAggregatesFilter<"BanditModel">
    createdAt?: DateTimeWithAggregatesFilter<"BanditModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BanditModel"> | Date | string
  }

  export type UserTypeEstimateWhereInput = {
    AND?: UserTypeEstimateWhereInput | UserTypeEstimateWhereInput[]
    OR?: UserTypeEstimateWhereInput[]
    NOT?: UserTypeEstimateWhereInput | UserTypeEstimateWhereInput[]
    userId?: UuidFilter<"UserTypeEstimate"> | string
    primaryType?: StringFilter<"UserTypeEstimate"> | string
    typeScores?: JsonFilter<"UserTypeEstimate">
    confidence?: DecimalFilter<"UserTypeEstimate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"UserTypeEstimate"> | Date | string
    updatedAt?: DateTimeFilter<"UserTypeEstimate"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }

  export type UserTypeEstimateOrderByWithRelationInput = {
    userId?: SortOrder
    primaryType?: SortOrder
    typeScores?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserTypeEstimateWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserTypeEstimateWhereInput | UserTypeEstimateWhereInput[]
    OR?: UserTypeEstimateWhereInput[]
    NOT?: UserTypeEstimateWhereInput | UserTypeEstimateWhereInput[]
    primaryType?: StringFilter<"UserTypeEstimate"> | string
    typeScores?: JsonFilter<"UserTypeEstimate">
    confidence?: DecimalFilter<"UserTypeEstimate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"UserTypeEstimate"> | Date | string
    updatedAt?: DateTimeFilter<"UserTypeEstimate"> | Date | string
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
  }, "userId">

  export type UserTypeEstimateOrderByWithAggregationInput = {
    userId?: SortOrder
    primaryType?: SortOrder
    typeScores?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserTypeEstimateCountOrderByAggregateInput
    _avg?: UserTypeEstimateAvgOrderByAggregateInput
    _max?: UserTypeEstimateMaxOrderByAggregateInput
    _min?: UserTypeEstimateMinOrderByAggregateInput
    _sum?: UserTypeEstimateSumOrderByAggregateInput
  }

  export type UserTypeEstimateScalarWhereWithAggregatesInput = {
    AND?: UserTypeEstimateScalarWhereWithAggregatesInput | UserTypeEstimateScalarWhereWithAggregatesInput[]
    OR?: UserTypeEstimateScalarWhereWithAggregatesInput[]
    NOT?: UserTypeEstimateScalarWhereWithAggregatesInput | UserTypeEstimateScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserTypeEstimate"> | string
    primaryType?: StringWithAggregatesFilter<"UserTypeEstimate"> | string
    typeScores?: JsonWithAggregatesFilter<"UserTypeEstimate">
    confidence?: DecimalWithAggregatesFilter<"UserTypeEstimate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"UserTypeEstimate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserTypeEstimate"> | Date | string
  }

  export type TypeStatsWhereInput = {
    AND?: TypeStatsWhereInput | TypeStatsWhereInput[]
    OR?: TypeStatsWhereInput[]
    NOT?: TypeStatsWhereInput | TypeStatsWhereInput[]
    typeId?: StringFilter<"TypeStats"> | string
    tone?: StringFilter<"TypeStats"> | string
    tappedCount?: BigIntFilter<"TypeStats"> | bigint | number
    ignoredCount?: BigIntFilter<"TypeStats"> | bigint | number
    thumbsUpCount?: BigIntFilter<"TypeStats"> | bigint | number
    thumbsDownCount?: BigIntFilter<"TypeStats"> | bigint | number
    sampleSize?: BigIntFilter<"TypeStats"> | bigint | number
    updatedAt?: DateTimeFilter<"TypeStats"> | Date | string
  }

  export type TypeStatsOrderByWithRelationInput = {
    typeId?: SortOrder
    tone?: SortOrder
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeStatsWhereUniqueInput = Prisma.AtLeast<{
    typeId_tone?: TypeStatsTypeIdToneCompoundUniqueInput
    AND?: TypeStatsWhereInput | TypeStatsWhereInput[]
    OR?: TypeStatsWhereInput[]
    NOT?: TypeStatsWhereInput | TypeStatsWhereInput[]
    typeId?: StringFilter<"TypeStats"> | string
    tone?: StringFilter<"TypeStats"> | string
    tappedCount?: BigIntFilter<"TypeStats"> | bigint | number
    ignoredCount?: BigIntFilter<"TypeStats"> | bigint | number
    thumbsUpCount?: BigIntFilter<"TypeStats"> | bigint | number
    thumbsDownCount?: BigIntFilter<"TypeStats"> | bigint | number
    sampleSize?: BigIntFilter<"TypeStats"> | bigint | number
    updatedAt?: DateTimeFilter<"TypeStats"> | Date | string
  }, "typeId_tone">

  export type TypeStatsOrderByWithAggregationInput = {
    typeId?: SortOrder
    tone?: SortOrder
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
    updatedAt?: SortOrder
    _count?: TypeStatsCountOrderByAggregateInput
    _avg?: TypeStatsAvgOrderByAggregateInput
    _max?: TypeStatsMaxOrderByAggregateInput
    _min?: TypeStatsMinOrderByAggregateInput
    _sum?: TypeStatsSumOrderByAggregateInput
  }

  export type TypeStatsScalarWhereWithAggregatesInput = {
    AND?: TypeStatsScalarWhereWithAggregatesInput | TypeStatsScalarWhereWithAggregatesInput[]
    OR?: TypeStatsScalarWhereWithAggregatesInput[]
    NOT?: TypeStatsScalarWhereWithAggregatesInput | TypeStatsScalarWhereWithAggregatesInput[]
    typeId?: StringWithAggregatesFilter<"TypeStats"> | string
    tone?: StringWithAggregatesFilter<"TypeStats"> | string
    tappedCount?: BigIntWithAggregatesFilter<"TypeStats"> | bigint | number
    ignoredCount?: BigIntWithAggregatesFilter<"TypeStats"> | bigint | number
    thumbsUpCount?: BigIntWithAggregatesFilter<"TypeStats"> | bigint | number
    thumbsDownCount?: BigIntWithAggregatesFilter<"TypeStats"> | bigint | number
    sampleSize?: BigIntWithAggregatesFilter<"TypeStats"> | bigint | number
    updatedAt?: DateTimeWithAggregatesFilter<"TypeStats"> | Date | string
  }

  export type HookCandidateWhereInput = {
    AND?: HookCandidateWhereInput | HookCandidateWhereInput[]
    OR?: HookCandidateWhereInput[]
    NOT?: HookCandidateWhereInput | HookCandidateWhereInput[]
    id?: UuidFilter<"HookCandidate"> | string
    text?: StringFilter<"HookCandidate"> | string
    tone?: StringFilter<"HookCandidate"> | string
    targetProblemTypes?: StringNullableListFilter<"HookCandidate">
    targetUserTypes?: StringNullableListFilter<"HookCandidate">
    appTapRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFilter<"HookCandidate"> | number
    tiktokLikeRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFilter<"HookCandidate"> | number
    tiktokHighPerformer?: BoolFilter<"HookCandidate"> | boolean
    isWisdom?: BoolFilter<"HookCandidate"> | boolean
    explorationWeight?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"HookCandidate"> | Date | string
    updatedAt?: DateTimeFilter<"HookCandidate"> | Date | string
    tiktokPosts?: TiktokPostListRelationFilter
  }

  export type HookCandidateOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    tone?: SortOrder
    targetProblemTypes?: SortOrder
    targetUserTypes?: SortOrder
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    tiktokHighPerformer?: SortOrder
    isWisdom?: SortOrder
    explorationWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tiktokPosts?: TiktokPostOrderByRelationAggregateInput
  }

  export type HookCandidateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    text_tone?: HookCandidateTextToneCompoundUniqueInput
    AND?: HookCandidateWhereInput | HookCandidateWhereInput[]
    OR?: HookCandidateWhereInput[]
    NOT?: HookCandidateWhereInput | HookCandidateWhereInput[]
    text?: StringFilter<"HookCandidate"> | string
    tone?: StringFilter<"HookCandidate"> | string
    targetProblemTypes?: StringNullableListFilter<"HookCandidate">
    targetUserTypes?: StringNullableListFilter<"HookCandidate">
    appTapRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFilter<"HookCandidate"> | number
    tiktokLikeRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFilter<"HookCandidate"> | number
    tiktokHighPerformer?: BoolFilter<"HookCandidate"> | boolean
    isWisdom?: BoolFilter<"HookCandidate"> | boolean
    explorationWeight?: DecimalFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"HookCandidate"> | Date | string
    updatedAt?: DateTimeFilter<"HookCandidate"> | Date | string
    tiktokPosts?: TiktokPostListRelationFilter
  }, "id" | "text_tone">

  export type HookCandidateOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    tone?: SortOrder
    targetProblemTypes?: SortOrder
    targetUserTypes?: SortOrder
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    tiktokHighPerformer?: SortOrder
    isWisdom?: SortOrder
    explorationWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HookCandidateCountOrderByAggregateInput
    _avg?: HookCandidateAvgOrderByAggregateInput
    _max?: HookCandidateMaxOrderByAggregateInput
    _min?: HookCandidateMinOrderByAggregateInput
    _sum?: HookCandidateSumOrderByAggregateInput
  }

  export type HookCandidateScalarWhereWithAggregatesInput = {
    AND?: HookCandidateScalarWhereWithAggregatesInput | HookCandidateScalarWhereWithAggregatesInput[]
    OR?: HookCandidateScalarWhereWithAggregatesInput[]
    NOT?: HookCandidateScalarWhereWithAggregatesInput | HookCandidateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"HookCandidate"> | string
    text?: StringWithAggregatesFilter<"HookCandidate"> | string
    tone?: StringWithAggregatesFilter<"HookCandidate"> | string
    targetProblemTypes?: StringNullableListFilter<"HookCandidate">
    targetUserTypes?: StringNullableListFilter<"HookCandidate">
    appTapRate?: DecimalWithAggregatesFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalWithAggregatesFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntWithAggregatesFilter<"HookCandidate"> | number
    tiktokLikeRate?: DecimalWithAggregatesFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalWithAggregatesFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntWithAggregatesFilter<"HookCandidate"> | number
    tiktokHighPerformer?: BoolWithAggregatesFilter<"HookCandidate"> | boolean
    isWisdom?: BoolWithAggregatesFilter<"HookCandidate"> | boolean
    explorationWeight?: DecimalWithAggregatesFilter<"HookCandidate"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"HookCandidate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HookCandidate"> | Date | string
  }

  export type TiktokPostWhereInput = {
    AND?: TiktokPostWhereInput | TiktokPostWhereInput[]
    OR?: TiktokPostWhereInput[]
    NOT?: TiktokPostWhereInput | TiktokPostWhereInput[]
    id?: UuidFilter<"TiktokPost"> | string
    hookCandidateId?: UuidNullableFilter<"TiktokPost"> | string | null
    tiktokVideoId?: StringNullableFilter<"TiktokPost"> | string | null
    blotatoPostId?: StringNullableFilter<"TiktokPost"> | string | null
    caption?: StringNullableFilter<"TiktokPost"> | string | null
    postedAt?: DateTimeFilter<"TiktokPost"> | Date | string
    metricsFetchedAt?: DateTimeNullableFilter<"TiktokPost"> | Date | string | null
    viewCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    likeCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    commentCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    shareCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    agentReasoning?: StringNullableFilter<"TiktokPost"> | string | null
    scheduledAt?: DateTimeNullableFilter<"TiktokPost"> | Date | string | null
    createdAt?: DateTimeFilter<"TiktokPost"> | Date | string
    hookCandidate?: XOR<HookCandidateNullableRelationFilter, HookCandidateWhereInput> | null
  }

  export type TiktokPostOrderByWithRelationInput = {
    id?: SortOrder
    hookCandidateId?: SortOrderInput | SortOrder
    tiktokVideoId?: SortOrderInput | SortOrder
    blotatoPostId?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    postedAt?: SortOrder
    metricsFetchedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    commentCount?: SortOrderInput | SortOrder
    shareCount?: SortOrderInput | SortOrder
    agentReasoning?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    hookCandidate?: HookCandidateOrderByWithRelationInput
  }

  export type TiktokPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tiktokVideoId?: string
    AND?: TiktokPostWhereInput | TiktokPostWhereInput[]
    OR?: TiktokPostWhereInput[]
    NOT?: TiktokPostWhereInput | TiktokPostWhereInput[]
    hookCandidateId?: UuidNullableFilter<"TiktokPost"> | string | null
    blotatoPostId?: StringNullableFilter<"TiktokPost"> | string | null
    caption?: StringNullableFilter<"TiktokPost"> | string | null
    postedAt?: DateTimeFilter<"TiktokPost"> | Date | string
    metricsFetchedAt?: DateTimeNullableFilter<"TiktokPost"> | Date | string | null
    viewCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    likeCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    commentCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    shareCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    agentReasoning?: StringNullableFilter<"TiktokPost"> | string | null
    scheduledAt?: DateTimeNullableFilter<"TiktokPost"> | Date | string | null
    createdAt?: DateTimeFilter<"TiktokPost"> | Date | string
    hookCandidate?: XOR<HookCandidateNullableRelationFilter, HookCandidateWhereInput> | null
  }, "id" | "tiktokVideoId">

  export type TiktokPostOrderByWithAggregationInput = {
    id?: SortOrder
    hookCandidateId?: SortOrderInput | SortOrder
    tiktokVideoId?: SortOrderInput | SortOrder
    blotatoPostId?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    postedAt?: SortOrder
    metricsFetchedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrderInput | SortOrder
    likeCount?: SortOrderInput | SortOrder
    commentCount?: SortOrderInput | SortOrder
    shareCount?: SortOrderInput | SortOrder
    agentReasoning?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TiktokPostCountOrderByAggregateInput
    _avg?: TiktokPostAvgOrderByAggregateInput
    _max?: TiktokPostMaxOrderByAggregateInput
    _min?: TiktokPostMinOrderByAggregateInput
    _sum?: TiktokPostSumOrderByAggregateInput
  }

  export type TiktokPostScalarWhereWithAggregatesInput = {
    AND?: TiktokPostScalarWhereWithAggregatesInput | TiktokPostScalarWhereWithAggregatesInput[]
    OR?: TiktokPostScalarWhereWithAggregatesInput[]
    NOT?: TiktokPostScalarWhereWithAggregatesInput | TiktokPostScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TiktokPost"> | string
    hookCandidateId?: UuidNullableWithAggregatesFilter<"TiktokPost"> | string | null
    tiktokVideoId?: StringNullableWithAggregatesFilter<"TiktokPost"> | string | null
    blotatoPostId?: StringNullableWithAggregatesFilter<"TiktokPost"> | string | null
    caption?: StringNullableWithAggregatesFilter<"TiktokPost"> | string | null
    postedAt?: DateTimeWithAggregatesFilter<"TiktokPost"> | Date | string
    metricsFetchedAt?: DateTimeNullableWithAggregatesFilter<"TiktokPost"> | Date | string | null
    viewCount?: BigIntNullableWithAggregatesFilter<"TiktokPost"> | bigint | number | null
    likeCount?: BigIntNullableWithAggregatesFilter<"TiktokPost"> | bigint | number | null
    commentCount?: BigIntNullableWithAggregatesFilter<"TiktokPost"> | bigint | number | null
    shareCount?: BigIntNullableWithAggregatesFilter<"TiktokPost"> | bigint | number | null
    agentReasoning?: StringNullableWithAggregatesFilter<"TiktokPost"> | string | null
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"TiktokPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TiktokPost"> | Date | string
  }

  export type WisdomPatternWhereInput = {
    AND?: WisdomPatternWhereInput | WisdomPatternWhereInput[]
    OR?: WisdomPatternWhereInput[]
    NOT?: WisdomPatternWhereInput | WisdomPatternWhereInput[]
    id?: UuidFilter<"WisdomPattern"> | string
    patternName?: StringFilter<"WisdomPattern"> | string
    description?: StringNullableFilter<"WisdomPattern"> | string | null
    targetUserTypes?: StringNullableListFilter<"WisdomPattern">
    effectiveTone?: StringNullableFilter<"WisdomPattern"> | string | null
    effectiveHookPattern?: StringNullableFilter<"WisdomPattern"> | string | null
    effectiveContentLength?: StringNullableFilter<"WisdomPattern"> | string | null
    appEvidence?: JsonFilter<"WisdomPattern">
    tiktokEvidence?: JsonFilter<"WisdomPattern">
    confidence?: DecimalFilter<"WisdomPattern"> | Decimal | DecimalJsLike | number | string
    verifiedAt?: DateTimeNullableFilter<"WisdomPattern"> | Date | string | null
    createdAt?: DateTimeFilter<"WisdomPattern"> | Date | string
    updatedAt?: DateTimeFilter<"WisdomPattern"> | Date | string
  }

  export type WisdomPatternOrderByWithRelationInput = {
    id?: SortOrder
    patternName?: SortOrder
    description?: SortOrderInput | SortOrder
    targetUserTypes?: SortOrder
    effectiveTone?: SortOrderInput | SortOrder
    effectiveHookPattern?: SortOrderInput | SortOrder
    effectiveContentLength?: SortOrderInput | SortOrder
    appEvidence?: SortOrder
    tiktokEvidence?: SortOrder
    confidence?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WisdomPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternName?: string
    AND?: WisdomPatternWhereInput | WisdomPatternWhereInput[]
    OR?: WisdomPatternWhereInput[]
    NOT?: WisdomPatternWhereInput | WisdomPatternWhereInput[]
    description?: StringNullableFilter<"WisdomPattern"> | string | null
    targetUserTypes?: StringNullableListFilter<"WisdomPattern">
    effectiveTone?: StringNullableFilter<"WisdomPattern"> | string | null
    effectiveHookPattern?: StringNullableFilter<"WisdomPattern"> | string | null
    effectiveContentLength?: StringNullableFilter<"WisdomPattern"> | string | null
    appEvidence?: JsonFilter<"WisdomPattern">
    tiktokEvidence?: JsonFilter<"WisdomPattern">
    confidence?: DecimalFilter<"WisdomPattern"> | Decimal | DecimalJsLike | number | string
    verifiedAt?: DateTimeNullableFilter<"WisdomPattern"> | Date | string | null
    createdAt?: DateTimeFilter<"WisdomPattern"> | Date | string
    updatedAt?: DateTimeFilter<"WisdomPattern"> | Date | string
  }, "id" | "patternName">

  export type WisdomPatternOrderByWithAggregationInput = {
    id?: SortOrder
    patternName?: SortOrder
    description?: SortOrderInput | SortOrder
    targetUserTypes?: SortOrder
    effectiveTone?: SortOrderInput | SortOrder
    effectiveHookPattern?: SortOrderInput | SortOrder
    effectiveContentLength?: SortOrderInput | SortOrder
    appEvidence?: SortOrder
    tiktokEvidence?: SortOrder
    confidence?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WisdomPatternCountOrderByAggregateInput
    _avg?: WisdomPatternAvgOrderByAggregateInput
    _max?: WisdomPatternMaxOrderByAggregateInput
    _min?: WisdomPatternMinOrderByAggregateInput
    _sum?: WisdomPatternSumOrderByAggregateInput
  }

  export type WisdomPatternScalarWhereWithAggregatesInput = {
    AND?: WisdomPatternScalarWhereWithAggregatesInput | WisdomPatternScalarWhereWithAggregatesInput[]
    OR?: WisdomPatternScalarWhereWithAggregatesInput[]
    NOT?: WisdomPatternScalarWhereWithAggregatesInput | WisdomPatternScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"WisdomPattern"> | string
    patternName?: StringWithAggregatesFilter<"WisdomPattern"> | string
    description?: StringNullableWithAggregatesFilter<"WisdomPattern"> | string | null
    targetUserTypes?: StringNullableListFilter<"WisdomPattern">
    effectiveTone?: StringNullableWithAggregatesFilter<"WisdomPattern"> | string | null
    effectiveHookPattern?: StringNullableWithAggregatesFilter<"WisdomPattern"> | string | null
    effectiveContentLength?: StringNullableWithAggregatesFilter<"WisdomPattern"> | string | null
    appEvidence?: JsonWithAggregatesFilter<"WisdomPattern">
    tiktokEvidence?: JsonWithAggregatesFilter<"WisdomPattern">
    confidence?: DecimalWithAggregatesFilter<"WisdomPattern"> | Decimal | DecimalJsLike | number | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"WisdomPattern"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WisdomPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WisdomPattern"> | Date | string
  }

  export type TokenCreateInput = {
    userId: string
    provider: string
    providerSub?: string | null
    email?: string | null
    accessTokenEnc: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: string | null
    expiry?: Date | string | null
    rotationFamilyId?: string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUncheckedCreateInput = {
    userId: string
    provider: string
    providerSub?: string | null
    email?: string | null
    accessTokenEnc: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: string | null
    expiry?: Date | string | null
    rotationFamilyId?: string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerSub?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenEnc?: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotationFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerSub?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenEnc?: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotationFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    userId: string
    provider: string
    providerSub?: string | null
    email?: string | null
    accessTokenEnc: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: string | null
    expiry?: Date | string | null
    rotationFamilyId?: string | null
    revokedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerSub?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenEnc?: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotationFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerSub?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenEnc?: JsonNullValueInput | InputJsonValue
    refreshTokenEnc?: NullableJsonNullValueInput | InputJsonValue
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    expiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rotationFamilyId?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    deviceId: string
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    rotatedFrom?: string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    reuseDetected?: boolean
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    tokenHash: string
    deviceId: string
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    rotatedFrom?: string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    reuseDetected?: boolean
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reuseDetected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reuseDetected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    tokenHash: string
    deviceId: string
    userAgent?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    rotatedFrom?: string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    reuseDetected?: boolean
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reuseDetected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotatedFrom?: NullableStringFieldUpdateOperationsInput | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reuseDetected?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MobileProfileCreateInput = {
    deviceId: string
    userId: string
    profile?: JsonNullValueInput | InputJsonValue
    language?: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type MobileProfileUncheckedCreateInput = {
    deviceId: string
    userId: string
    profile?: JsonNullValueInput | InputJsonValue
    language?: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type MobileProfileUpdateInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileProfileUncheckedUpdateInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileProfileCreateManyInput = {
    deviceId: string
    userId: string
    profile?: JsonNullValueInput | InputJsonValue
    language?: string
    updatedAt?: Date | string | null
    createdAt?: Date | string | null
  }

  export type MobileProfileUpdateManyMutationInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileProfileUncheckedUpdateManyInput = {
    deviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profile?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSubscriptionCreateInput = {
    userId: string
    plan?: string
    status?: string
    entitlementSource?: string
    revenuecatEntitlementId?: string | null
    revenuecatOriginalTransactionId?: string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: Date | string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSubscriptionUncheckedCreateInput = {
    userId: string
    plan?: string
    status?: string
    entitlementSource?: string
    revenuecatEntitlementId?: string | null
    revenuecatOriginalTransactionId?: string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: Date | string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    entitlementSource?: StringFieldUpdateOperationsInput | string
    revenuecatEntitlementId?: NullableStringFieldUpdateOperationsInput | string | null
    revenuecatOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    entitlementSource?: StringFieldUpdateOperationsInput | string
    revenuecatEntitlementId?: NullableStringFieldUpdateOperationsInput | string | null
    revenuecatOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionCreateManyInput = {
    userId: string
    plan?: string
    status?: string
    entitlementSource?: string
    revenuecatEntitlementId?: string | null
    revenuecatOriginalTransactionId?: string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: Date | string | null
    trialEnd?: Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
  }

  export type UserSubscriptionUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    entitlementSource?: StringFieldUpdateOperationsInput | string
    revenuecatEntitlementId?: NullableStringFieldUpdateOperationsInput | string | null
    revenuecatOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSubscriptionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    entitlementSource?: StringFieldUpdateOperationsInput | string
    revenuecatEntitlementId?: NullableStringFieldUpdateOperationsInput | string | null
    revenuecatOriginalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    entitlementPayload?: NullableJsonNullValueInput | InputJsonValue
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventCreateInput = {
    eventId: string
    userId?: string | null
    type: string
    provider?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SubscriptionEventUncheckedCreateInput = {
    eventId: string
    userId?: string | null
    type: string
    provider?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SubscriptionEventUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventUncheckedUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventCreateManyInput = {
    eventId: string
    userId?: string | null
    type: string
    provider?: string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SubscriptionEventUpdateManyMutationInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventUncheckedUpdateManyInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    payload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyVcGrantCreateInput = {
    userId: string
    grantMonth: Date | string
    reason: string
    minutes: number
    grantedAt?: Date | string
  }

  export type MonthlyVcGrantUncheckedCreateInput = {
    userId: string
    grantMonth: Date | string
    reason: string
    minutes: number
    grantedAt?: Date | string
  }

  export type MonthlyVcGrantUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    grantMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyVcGrantUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    grantMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyVcGrantCreateManyInput = {
    userId: string
    grantMonth: Date | string
    reason: string
    minutes: number
    grantedAt?: Date | string
  }

  export type MonthlyVcGrantUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    grantMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyVcGrantUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    grantMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    minutes?: IntFieldUpdateOperationsInput | number
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingCreateNestedOneWithoutProfileInput
    userTypeEstimate?: UserTypeEstimateCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingUncheckedCreateNestedOneWithoutProfileInput
    userTypeEstimate?: UserTypeEstimateUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingUpdateOneWithoutProfileNestedInput
    userTypeEstimate?: UserTypeEstimateUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingUncheckedUpdateOneWithoutProfileNestedInput
    userTypeEstimate?: UserTypeEstimateUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingCreateInput = {
    language?: string
    timezone?: string
    notificationsEnabled?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingUncheckedCreateInput = {
    userId: string
    language?: string
    timezone?: string
    notificationsEnabled?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingUpdateInput = {
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingCreateManyInput = {
    userId: string
    language?: string
    timezone?: string
    notificationsEnabled?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingUpdateManyMutationInput = {
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTraitCreateInput = {
    userId: string
    ideals?: UserTraitCreateidealsInput | string[]
    struggles?: UserTraitCreatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitCreatekeywordsInput | string[]
    summary?: string
    nudgeIntensity?: string
    stickyMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTraitUncheckedCreateInput = {
    userId: string
    ideals?: UserTraitCreateidealsInput | string[]
    struggles?: UserTraitCreatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitCreatekeywordsInput | string[]
    summary?: string
    nudgeIntensity?: string
    stickyMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTraitUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ideals?: UserTraitUpdateidealsInput | string[]
    struggles?: UserTraitUpdatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitUpdatekeywordsInput | string[]
    summary?: StringFieldUpdateOperationsInput | string
    nudgeIntensity?: StringFieldUpdateOperationsInput | string
    stickyMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTraitUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ideals?: UserTraitUpdateidealsInput | string[]
    struggles?: UserTraitUpdatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitUpdatekeywordsInput | string[]
    summary?: StringFieldUpdateOperationsInput | string
    nudgeIntensity?: StringFieldUpdateOperationsInput | string
    stickyMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTraitCreateManyInput = {
    userId: string
    ideals?: UserTraitCreateidealsInput | string[]
    struggles?: UserTraitCreatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitCreatekeywordsInput | string[]
    summary?: string
    nudgeIntensity?: string
    stickyMode?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTraitUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ideals?: UserTraitUpdateidealsInput | string[]
    struggles?: UserTraitUpdatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitUpdatekeywordsInput | string[]
    summary?: StringFieldUpdateOperationsInput | string
    nudgeIntensity?: StringFieldUpdateOperationsInput | string
    stickyMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTraitUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    ideals?: UserTraitUpdateidealsInput | string[]
    struggles?: UserTraitUpdatestrugglesInput | string[]
    big5?: JsonNullValueInput | InputJsonValue
    keywords?: UserTraitUpdatekeywordsInput | string[]
    summary?: StringFieldUpdateOperationsInput | string
    nudgeIntensity?: StringFieldUpdateOperationsInput | string
    stickyMode?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricCreateInput = {
    userId: string
    date: Date | string
    sleepDurationMin?: number | null
    sleepStartAt?: Date | string | null
    wakeAt?: Date | string | null
    snsMinutesTotal?: number
    snsMinutesNight?: number
    steps?: number
    sedentaryMinutes?: number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyMetricUncheckedCreateInput = {
    userId: string
    date: Date | string
    sleepDurationMin?: number | null
    sleepStartAt?: Date | string | null
    wakeAt?: Date | string | null
    snsMinutesTotal?: number
    snsMinutesNight?: number
    steps?: number
    sedentaryMinutes?: number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyMetricUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    sleepStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snsMinutesTotal?: IntFieldUpdateOperationsInput | number
    snsMinutesNight?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    sedentaryMinutes?: IntFieldUpdateOperationsInput | number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    sleepStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snsMinutesTotal?: IntFieldUpdateOperationsInput | number
    snsMinutesNight?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    sedentaryMinutes?: IntFieldUpdateOperationsInput | number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricCreateManyInput = {
    userId: string
    date: Date | string
    sleepDurationMin?: number | null
    sleepStartAt?: Date | string | null
    wakeAt?: Date | string | null
    snsMinutesTotal?: number
    snsMinutesNight?: number
    steps?: number
    sedentaryMinutes?: number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyMetricUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    sleepStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snsMinutesTotal?: IntFieldUpdateOperationsInput | number
    snsMinutesNight?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    sedentaryMinutes?: IntFieldUpdateOperationsInput | number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyMetricUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sleepDurationMin?: NullableIntFieldUpdateOperationsInput | number | null
    sleepStartAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wakeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    snsMinutesTotal?: IntFieldUpdateOperationsInput | number
    snsMinutesNight?: IntFieldUpdateOperationsInput | number
    steps?: IntFieldUpdateOperationsInput | number
    sedentaryMinutes?: IntFieldUpdateOperationsInput | number
    activitySummary?: JsonNullValueInput | InputJsonValue
    mindSummary?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeEventCreateInput = {
    id?: string
    userId: string
    domain: string
    subtype: string
    decisionPoint: string
    state: JsonNullValueInput | InputJsonValue
    actionTemplate?: string | null
    channel: string
    sent?: boolean
    createdAt?: Date | string
    outcomes?: NudgeOutcomeCreateNestedManyWithoutEventInput
  }

  export type NudgeEventUncheckedCreateInput = {
    id?: string
    userId: string
    domain: string
    subtype: string
    decisionPoint: string
    state: JsonNullValueInput | InputJsonValue
    actionTemplate?: string | null
    channel: string
    sent?: boolean
    createdAt?: Date | string
    outcomes?: NudgeOutcomeUncheckedCreateNestedManyWithoutEventInput
  }

  export type NudgeEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    decisionPoint?: StringFieldUpdateOperationsInput | string
    state?: JsonNullValueInput | InputJsonValue
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outcomes?: NudgeOutcomeUpdateManyWithoutEventNestedInput
  }

  export type NudgeEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    decisionPoint?: StringFieldUpdateOperationsInput | string
    state?: JsonNullValueInput | InputJsonValue
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outcomes?: NudgeOutcomeUncheckedUpdateManyWithoutEventNestedInput
  }

  export type NudgeEventCreateManyInput = {
    id?: string
    userId: string
    domain: string
    subtype: string
    decisionPoint: string
    state: JsonNullValueInput | InputJsonValue
    actionTemplate?: string | null
    channel: string
    sent?: boolean
    createdAt?: Date | string
  }

  export type NudgeEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    decisionPoint?: StringFieldUpdateOperationsInput | string
    state?: JsonNullValueInput | InputJsonValue
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    decisionPoint?: StringFieldUpdateOperationsInput | string
    state?: JsonNullValueInput | InputJsonValue
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeOutcomeCreateInput = {
    id?: string
    reward?: number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    event: NudgeEventCreateNestedOneWithoutOutcomesInput
  }

  export type NudgeOutcomeUncheckedCreateInput = {
    id?: string
    nudgeEventId: string
    reward?: number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NudgeOutcomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: NudgeEventUpdateOneRequiredWithoutOutcomesNestedInput
  }

  export type NudgeOutcomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nudgeEventId?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeOutcomeCreateManyInput = {
    id?: string
    nudgeEventId: string
    reward?: number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NudgeOutcomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeOutcomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nudgeEventId?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeelingSessionCreateInput = {
    id?: string
    userId: string
    feelingId: string
    topic?: string | null
    actionTemplate?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    emaBetter?: boolean | null
    summary?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeelingSessionUncheckedCreateInput = {
    id?: string
    userId: string
    feelingId: string
    topic?: string | null
    actionTemplate?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    emaBetter?: boolean | null
    summary?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeelingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feelingId?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emaBetter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeelingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feelingId?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emaBetter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeelingSessionCreateManyInput = {
    id?: string
    userId: string
    feelingId: string
    topic?: string | null
    actionTemplate?: string | null
    startedAt?: Date | string
    endedAt?: Date | string | null
    emaBetter?: boolean | null
    summary?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FeelingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feelingId?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emaBetter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeelingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feelingId?: StringFieldUpdateOperationsInput | string
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emaBetter?: NullableBoolFieldUpdateOperationsInput | boolean | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    context?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanditModelCreateInput = {
    id?: string
    domain: string
    version?: number
    weights: JsonNullValueInput | InputJsonValue
    covariance: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BanditModelUncheckedCreateInput = {
    id?: string
    domain: string
    version?: number
    weights: JsonNullValueInput | InputJsonValue
    covariance: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BanditModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    covariance?: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanditModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    covariance?: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanditModelCreateManyInput = {
    id?: string
    domain: string
    version?: number
    weights: JsonNullValueInput | InputJsonValue
    covariance: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BanditModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    covariance?: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BanditModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    weights?: JsonNullValueInput | InputJsonValue
    covariance?: JsonNullValueInput | InputJsonValue
    meta?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTypeEstimateCreateInput = {
    primaryType: string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutUserTypeEstimateInput
  }

  export type UserTypeEstimateUncheckedCreateInput = {
    userId: string
    primaryType: string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTypeEstimateUpdateInput = {
    primaryType?: StringFieldUpdateOperationsInput | string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutUserTypeEstimateNestedInput
  }

  export type UserTypeEstimateUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    primaryType?: StringFieldUpdateOperationsInput | string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTypeEstimateCreateManyInput = {
    userId: string
    primaryType: string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTypeEstimateUpdateManyMutationInput = {
    primaryType?: StringFieldUpdateOperationsInput | string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTypeEstimateUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    primaryType?: StringFieldUpdateOperationsInput | string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeStatsCreateInput = {
    typeId: string
    tone: string
    tappedCount?: bigint | number
    ignoredCount?: bigint | number
    thumbsUpCount?: bigint | number
    thumbsDownCount?: bigint | number
    sampleSize?: bigint | number
    updatedAt?: Date | string
  }

  export type TypeStatsUncheckedCreateInput = {
    typeId: string
    tone: string
    tappedCount?: bigint | number
    ignoredCount?: bigint | number
    thumbsUpCount?: bigint | number
    thumbsDownCount?: bigint | number
    sampleSize?: bigint | number
    updatedAt?: Date | string
  }

  export type TypeStatsUpdateInput = {
    typeId?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    tappedCount?: BigIntFieldUpdateOperationsInput | bigint | number
    ignoredCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsUpCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsDownCount?: BigIntFieldUpdateOperationsInput | bigint | number
    sampleSize?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeStatsUncheckedUpdateInput = {
    typeId?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    tappedCount?: BigIntFieldUpdateOperationsInput | bigint | number
    ignoredCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsUpCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsDownCount?: BigIntFieldUpdateOperationsInput | bigint | number
    sampleSize?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeStatsCreateManyInput = {
    typeId: string
    tone: string
    tappedCount?: bigint | number
    ignoredCount?: bigint | number
    thumbsUpCount?: bigint | number
    thumbsDownCount?: bigint | number
    sampleSize?: bigint | number
    updatedAt?: Date | string
  }

  export type TypeStatsUpdateManyMutationInput = {
    typeId?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    tappedCount?: BigIntFieldUpdateOperationsInput | bigint | number
    ignoredCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsUpCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsDownCount?: BigIntFieldUpdateOperationsInput | bigint | number
    sampleSize?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TypeStatsUncheckedUpdateManyInput = {
    typeId?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    tappedCount?: BigIntFieldUpdateOperationsInput | bigint | number
    ignoredCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsUpCount?: BigIntFieldUpdateOperationsInput | bigint | number
    thumbsDownCount?: BigIntFieldUpdateOperationsInput | bigint | number
    sampleSize?: BigIntFieldUpdateOperationsInput | bigint | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HookCandidateCreateInput = {
    id?: string
    text: string
    tone: string
    targetProblemTypes?: HookCandidateCreatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateCreatetargetUserTypesInput | string[]
    appTapRate?: Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: Decimal | DecimalJsLike | number | string
    appSampleSize?: number
    tiktokLikeRate?: Decimal | DecimalJsLike | number | string
    tiktokShareRate?: Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: number
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tiktokPosts?: TiktokPostCreateNestedManyWithoutHookCandidateInput
  }

  export type HookCandidateUncheckedCreateInput = {
    id?: string
    text: string
    tone: string
    targetProblemTypes?: HookCandidateCreatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateCreatetargetUserTypesInput | string[]
    appTapRate?: Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: Decimal | DecimalJsLike | number | string
    appSampleSize?: number
    tiktokLikeRate?: Decimal | DecimalJsLike | number | string
    tiktokShareRate?: Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: number
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tiktokPosts?: TiktokPostUncheckedCreateNestedManyWithoutHookCandidateInput
  }

  export type HookCandidateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    targetProblemTypes?: HookCandidateUpdatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateUpdatetargetUserTypesInput | string[]
    appTapRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokLikeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokHighPerformer?: BoolFieldUpdateOperationsInput | boolean
    isWisdom?: BoolFieldUpdateOperationsInput | boolean
    explorationWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiktokPosts?: TiktokPostUpdateManyWithoutHookCandidateNestedInput
  }

  export type HookCandidateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    targetProblemTypes?: HookCandidateUpdatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateUpdatetargetUserTypesInput | string[]
    appTapRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokLikeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokHighPerformer?: BoolFieldUpdateOperationsInput | boolean
    isWisdom?: BoolFieldUpdateOperationsInput | boolean
    explorationWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tiktokPosts?: TiktokPostUncheckedUpdateManyWithoutHookCandidateNestedInput
  }

  export type HookCandidateCreateManyInput = {
    id?: string
    text: string
    tone: string
    targetProblemTypes?: HookCandidateCreatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateCreatetargetUserTypesInput | string[]
    appTapRate?: Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: Decimal | DecimalJsLike | number | string
    appSampleSize?: number
    tiktokLikeRate?: Decimal | DecimalJsLike | number | string
    tiktokShareRate?: Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: number
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HookCandidateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    targetProblemTypes?: HookCandidateUpdatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateUpdatetargetUserTypesInput | string[]
    appTapRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokLikeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokHighPerformer?: BoolFieldUpdateOperationsInput | boolean
    isWisdom?: BoolFieldUpdateOperationsInput | boolean
    explorationWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HookCandidateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    targetProblemTypes?: HookCandidateUpdatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateUpdatetargetUserTypesInput | string[]
    appTapRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokLikeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokHighPerformer?: BoolFieldUpdateOperationsInput | boolean
    isWisdom?: BoolFieldUpdateOperationsInput | boolean
    explorationWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiktokPostCreateInput = {
    id?: string
    tiktokVideoId?: string | null
    blotatoPostId?: string | null
    caption?: string | null
    postedAt?: Date | string
    metricsFetchedAt?: Date | string | null
    viewCount?: bigint | number | null
    likeCount?: bigint | number | null
    commentCount?: bigint | number | null
    shareCount?: bigint | number | null
    agentReasoning?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
    hookCandidate?: HookCandidateCreateNestedOneWithoutTiktokPostsInput
  }

  export type TiktokPostUncheckedCreateInput = {
    id?: string
    hookCandidateId?: string | null
    tiktokVideoId?: string | null
    blotatoPostId?: string | null
    caption?: string | null
    postedAt?: Date | string
    metricsFetchedAt?: Date | string | null
    viewCount?: bigint | number | null
    likeCount?: bigint | number | null
    commentCount?: bigint | number | null
    shareCount?: bigint | number | null
    agentReasoning?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TiktokPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    hookCandidate?: HookCandidateUpdateOneWithoutTiktokPostsNestedInput
  }

  export type TiktokPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hookCandidateId?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiktokPostCreateManyInput = {
    id?: string
    hookCandidateId?: string | null
    tiktokVideoId?: string | null
    blotatoPostId?: string | null
    caption?: string | null
    postedAt?: Date | string
    metricsFetchedAt?: Date | string | null
    viewCount?: bigint | number | null
    likeCount?: bigint | number | null
    commentCount?: bigint | number | null
    shareCount?: bigint | number | null
    agentReasoning?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TiktokPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiktokPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hookCandidateId?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WisdomPatternCreateInput = {
    id?: string
    patternName: string
    description?: string | null
    targetUserTypes?: WisdomPatternCreatetargetUserTypesInput | string[]
    effectiveTone?: string | null
    effectiveHookPattern?: string | null
    effectiveContentLength?: string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WisdomPatternUncheckedCreateInput = {
    id?: string
    patternName: string
    description?: string | null
    targetUserTypes?: WisdomPatternCreatetargetUserTypesInput | string[]
    effectiveTone?: string | null
    effectiveHookPattern?: string | null
    effectiveContentLength?: string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WisdomPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetUserTypes?: WisdomPatternUpdatetargetUserTypesInput | string[]
    effectiveTone?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveHookPattern?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveContentLength?: NullableStringFieldUpdateOperationsInput | string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WisdomPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetUserTypes?: WisdomPatternUpdatetargetUserTypesInput | string[]
    effectiveTone?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveHookPattern?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveContentLength?: NullableStringFieldUpdateOperationsInput | string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WisdomPatternCreateManyInput = {
    id?: string
    patternName: string
    description?: string | null
    targetUserTypes?: WisdomPatternCreatetargetUserTypesInput | string[]
    effectiveTone?: string | null
    effectiveHookPattern?: string | null
    effectiveContentLength?: string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    verifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WisdomPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetUserTypes?: WisdomPatternUpdatetargetUserTypesInput | string[]
    effectiveTone?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveHookPattern?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveContentLength?: NullableStringFieldUpdateOperationsInput | string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WisdomPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetUserTypes?: WisdomPatternUpdatetargetUserTypesInput | string[]
    effectiveTone?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveHookPattern?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveContentLength?: NullableStringFieldUpdateOperationsInput | string | null
    appEvidence?: JsonNullValueInput | InputJsonValue
    tiktokEvidence?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TokenUserIdProviderCompoundUniqueInput = {
    userId: string
    provider: string
  }

  export type TokenCountOrderByAggregateInput = {
    userId?: SortOrder
    provider?: SortOrder
    providerSub?: SortOrder
    email?: SortOrder
    accessTokenEnc?: SortOrder
    refreshTokenEnc?: SortOrder
    scope?: SortOrder
    expiry?: SortOrder
    rotationFamilyId?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    userId?: SortOrder
    provider?: SortOrder
    providerSub?: SortOrder
    email?: SortOrder
    scope?: SortOrder
    expiry?: SortOrder
    rotationFamilyId?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    userId?: SortOrder
    provider?: SortOrder
    providerSub?: SortOrder
    email?: SortOrder
    scope?: SortOrder
    expiry?: SortOrder
    rotationFamilyId?: SortOrder
    revokedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    rotatedFrom?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    reuseDetected?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    rotatedFrom?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    reuseDetected?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokenHash?: SortOrder
    deviceId?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    rotatedFrom?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    reuseDetected?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MobileProfileCountOrderByAggregateInput = {
    deviceId?: SortOrder
    userId?: SortOrder
    profile?: SortOrder
    language?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MobileProfileMaxOrderByAggregateInput = {
    deviceId?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type MobileProfileMinOrderByAggregateInput = {
    deviceId?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSubscriptionCountOrderByAggregateInput = {
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    entitlementSource?: SortOrder
    revenuecatEntitlementId?: SortOrder
    revenuecatOriginalTransactionId?: SortOrder
    entitlementPayload?: SortOrder
    currentPeriodEnd?: SortOrder
    trialEnd?: SortOrder
    metadata?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMaxOrderByAggregateInput = {
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    entitlementSource?: SortOrder
    revenuecatEntitlementId?: SortOrder
    revenuecatOriginalTransactionId?: SortOrder
    currentPeriodEnd?: SortOrder
    trialEnd?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSubscriptionMinOrderByAggregateInput = {
    userId?: SortOrder
    plan?: SortOrder
    status?: SortOrder
    entitlementSource?: SortOrder
    revenuecatEntitlementId?: SortOrder
    revenuecatOriginalTransactionId?: SortOrder
    currentPeriodEnd?: SortOrder
    trialEnd?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionEventCountOrderByAggregateInput = {
    eventId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionEventMaxOrderByAggregateInput = {
    eventId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
  }

  export type SubscriptionEventMinOrderByAggregateInput = {
    eventId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MonthlyVcGrantUserIdGrantMonthReasonCompoundUniqueInput = {
    userId: string
    grantMonth: Date | string
    reason: string
  }

  export type MonthlyVcGrantCountOrderByAggregateInput = {
    userId?: SortOrder
    grantMonth?: SortOrder
    reason?: SortOrder
    minutes?: SortOrder
    grantedAt?: SortOrder
  }

  export type MonthlyVcGrantAvgOrderByAggregateInput = {
    minutes?: SortOrder
  }

  export type MonthlyVcGrantMaxOrderByAggregateInput = {
    userId?: SortOrder
    grantMonth?: SortOrder
    reason?: SortOrder
    minutes?: SortOrder
    grantedAt?: SortOrder
  }

  export type MonthlyVcGrantMinOrderByAggregateInput = {
    userId?: SortOrder
    grantMonth?: SortOrder
    reason?: SortOrder
    minutes?: SortOrder
    grantedAt?: SortOrder
  }

  export type MonthlyVcGrantSumOrderByAggregateInput = {
    minutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserSettingNullableRelationFilter = {
    is?: UserSettingWhereInput | null
    isNot?: UserSettingWhereInput | null
  }

  export type UserTypeEstimateNullableRelationFilter = {
    is?: UserTypeEstimateWhereInput | null
    isNot?: UserTypeEstimateWhereInput | null
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type UserSettingCountOrderByAggregateInput = {
    userId?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    notificationsEnabled?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingMaxOrderByAggregateInput = {
    userId?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    notificationsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingMinOrderByAggregateInput = {
    userId?: SortOrder
    language?: SortOrder
    timezone?: SortOrder
    notificationsEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserTraitCountOrderByAggregateInput = {
    userId?: SortOrder
    ideals?: SortOrder
    struggles?: SortOrder
    big5?: SortOrder
    keywords?: SortOrder
    summary?: SortOrder
    nudgeIntensity?: SortOrder
    stickyMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTraitMaxOrderByAggregateInput = {
    userId?: SortOrder
    summary?: SortOrder
    nudgeIntensity?: SortOrder
    stickyMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTraitMinOrderByAggregateInput = {
    userId?: SortOrder
    summary?: SortOrder
    nudgeIntensity?: SortOrder
    stickyMode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DailyMetricUserIdDateCompoundUniqueInput = {
    userId: string
    date: Date | string
  }

  export type DailyMetricCountOrderByAggregateInput = {
    userId?: SortOrder
    date?: SortOrder
    sleepDurationMin?: SortOrder
    sleepStartAt?: SortOrder
    wakeAt?: SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
    activitySummary?: SortOrder
    mindSummary?: SortOrder
    insights?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyMetricAvgOrderByAggregateInput = {
    sleepDurationMin?: SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
  }

  export type DailyMetricMaxOrderByAggregateInput = {
    userId?: SortOrder
    date?: SortOrder
    sleepDurationMin?: SortOrder
    sleepStartAt?: SortOrder
    wakeAt?: SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyMetricMinOrderByAggregateInput = {
    userId?: SortOrder
    date?: SortOrder
    sleepDurationMin?: SortOrder
    sleepStartAt?: SortOrder
    wakeAt?: SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DailyMetricSumOrderByAggregateInput = {
    sleepDurationMin?: SortOrder
    snsMinutesTotal?: SortOrder
    snsMinutesNight?: SortOrder
    steps?: SortOrder
    sedentaryMinutes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NudgeOutcomeListRelationFilter = {
    every?: NudgeOutcomeWhereInput
    some?: NudgeOutcomeWhereInput
    none?: NudgeOutcomeWhereInput
  }

  export type NudgeOutcomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NudgeEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    subtype?: SortOrder
    decisionPoint?: SortOrder
    state?: SortOrder
    actionTemplate?: SortOrder
    channel?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
  }

  export type NudgeEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    subtype?: SortOrder
    decisionPoint?: SortOrder
    actionTemplate?: SortOrder
    channel?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
  }

  export type NudgeEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    domain?: SortOrder
    subtype?: SortOrder
    decisionPoint?: SortOrder
    actionTemplate?: SortOrder
    channel?: SortOrder
    sent?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NudgeEventRelationFilter = {
    is?: NudgeEventWhereInput
    isNot?: NudgeEventWhereInput
  }

  export type NudgeOutcomeCountOrderByAggregateInput = {
    id?: SortOrder
    nudgeEventId?: SortOrder
    reward?: SortOrder
    shortTerm?: SortOrder
    emaScore?: SortOrder
    signals?: SortOrder
    createdAt?: SortOrder
  }

  export type NudgeOutcomeAvgOrderByAggregateInput = {
    reward?: SortOrder
  }

  export type NudgeOutcomeMaxOrderByAggregateInput = {
    id?: SortOrder
    nudgeEventId?: SortOrder
    reward?: SortOrder
    createdAt?: SortOrder
  }

  export type NudgeOutcomeMinOrderByAggregateInput = {
    id?: SortOrder
    nudgeEventId?: SortOrder
    reward?: SortOrder
    createdAt?: SortOrder
  }

  export type NudgeOutcomeSumOrderByAggregateInput = {
    reward?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FeelingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feelingId?: SortOrder
    topic?: SortOrder
    actionTemplate?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    emaBetter?: SortOrder
    summary?: SortOrder
    transcript?: SortOrder
    context?: SortOrder
    createdAt?: SortOrder
  }

  export type FeelingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feelingId?: SortOrder
    topic?: SortOrder
    actionTemplate?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    emaBetter?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type FeelingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    feelingId?: SortOrder
    topic?: SortOrder
    actionTemplate?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    emaBetter?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BanditModelDomainVersionCompoundUniqueInput = {
    domain: string
    version: number
  }

  export type BanditModelCountOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    version?: SortOrder
    weights?: SortOrder
    covariance?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanditModelAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BanditModelMaxOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanditModelMinOrderByAggregateInput = {
    id?: SortOrder
    domain?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BanditModelSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserTypeEstimateCountOrderByAggregateInput = {
    userId?: SortOrder
    primaryType?: SortOrder
    typeScores?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTypeEstimateAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type UserTypeEstimateMaxOrderByAggregateInput = {
    userId?: SortOrder
    primaryType?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTypeEstimateMinOrderByAggregateInput = {
    userId?: SortOrder
    primaryType?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserTypeEstimateSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type TypeStatsTypeIdToneCompoundUniqueInput = {
    typeId: string
    tone: string
  }

  export type TypeStatsCountOrderByAggregateInput = {
    typeId?: SortOrder
    tone?: SortOrder
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeStatsAvgOrderByAggregateInput = {
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
  }

  export type TypeStatsMaxOrderByAggregateInput = {
    typeId?: SortOrder
    tone?: SortOrder
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeStatsMinOrderByAggregateInput = {
    typeId?: SortOrder
    tone?: SortOrder
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
    updatedAt?: SortOrder
  }

  export type TypeStatsSumOrderByAggregateInput = {
    tappedCount?: SortOrder
    ignoredCount?: SortOrder
    thumbsUpCount?: SortOrder
    thumbsDownCount?: SortOrder
    sampleSize?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type TiktokPostListRelationFilter = {
    every?: TiktokPostWhereInput
    some?: TiktokPostWhereInput
    none?: TiktokPostWhereInput
  }

  export type TiktokPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HookCandidateTextToneCompoundUniqueInput = {
    text: string
    tone: string
  }

  export type HookCandidateCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    tone?: SortOrder
    targetProblemTypes?: SortOrder
    targetUserTypes?: SortOrder
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    tiktokHighPerformer?: SortOrder
    isWisdom?: SortOrder
    explorationWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HookCandidateAvgOrderByAggregateInput = {
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    explorationWeight?: SortOrder
  }

  export type HookCandidateMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    tone?: SortOrder
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    tiktokHighPerformer?: SortOrder
    isWisdom?: SortOrder
    explorationWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HookCandidateMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    tone?: SortOrder
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    tiktokHighPerformer?: SortOrder
    isWisdom?: SortOrder
    explorationWeight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HookCandidateSumOrderByAggregateInput = {
    appTapRate?: SortOrder
    appThumbsUpRate?: SortOrder
    appSampleSize?: SortOrder
    tiktokLikeRate?: SortOrder
    tiktokShareRate?: SortOrder
    tiktokSampleSize?: SortOrder
    explorationWeight?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type HookCandidateNullableRelationFilter = {
    is?: HookCandidateWhereInput | null
    isNot?: HookCandidateWhereInput | null
  }

  export type TiktokPostCountOrderByAggregateInput = {
    id?: SortOrder
    hookCandidateId?: SortOrder
    tiktokVideoId?: SortOrder
    blotatoPostId?: SortOrder
    caption?: SortOrder
    postedAt?: SortOrder
    metricsFetchedAt?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    agentReasoning?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TiktokPostAvgOrderByAggregateInput = {
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
  }

  export type TiktokPostMaxOrderByAggregateInput = {
    id?: SortOrder
    hookCandidateId?: SortOrder
    tiktokVideoId?: SortOrder
    blotatoPostId?: SortOrder
    caption?: SortOrder
    postedAt?: SortOrder
    metricsFetchedAt?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    agentReasoning?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TiktokPostMinOrderByAggregateInput = {
    id?: SortOrder
    hookCandidateId?: SortOrder
    tiktokVideoId?: SortOrder
    blotatoPostId?: SortOrder
    caption?: SortOrder
    postedAt?: SortOrder
    metricsFetchedAt?: SortOrder
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
    agentReasoning?: SortOrder
    scheduledAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TiktokPostSumOrderByAggregateInput = {
    viewCount?: SortOrder
    likeCount?: SortOrder
    commentCount?: SortOrder
    shareCount?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type WisdomPatternCountOrderByAggregateInput = {
    id?: SortOrder
    patternName?: SortOrder
    description?: SortOrder
    targetUserTypes?: SortOrder
    effectiveTone?: SortOrder
    effectiveHookPattern?: SortOrder
    effectiveContentLength?: SortOrder
    appEvidence?: SortOrder
    tiktokEvidence?: SortOrder
    confidence?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WisdomPatternAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type WisdomPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    patternName?: SortOrder
    description?: SortOrder
    effectiveTone?: SortOrder
    effectiveHookPattern?: SortOrder
    effectiveContentLength?: SortOrder
    confidence?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WisdomPatternMinOrderByAggregateInput = {
    id?: SortOrder
    patternName?: SortOrder
    description?: SortOrder
    effectiveTone?: SortOrder
    effectiveHookPattern?: SortOrder
    effectiveContentLength?: SortOrder
    confidence?: SortOrder
    verifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WisdomPatternSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserSettingCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserSettingCreateWithoutProfileInput, UserSettingUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutProfileInput
    connect?: UserSettingWhereUniqueInput
  }

  export type UserTypeEstimateCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserTypeEstimateCreateWithoutProfileInput, UserTypeEstimateUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserTypeEstimateCreateOrConnectWithoutProfileInput
    connect?: UserTypeEstimateWhereUniqueInput
  }

  export type UserSettingUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserSettingCreateWithoutProfileInput, UserSettingUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutProfileInput
    connect?: UserSettingWhereUniqueInput
  }

  export type UserTypeEstimateUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserTypeEstimateCreateWithoutProfileInput, UserTypeEstimateUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserTypeEstimateCreateOrConnectWithoutProfileInput
    connect?: UserTypeEstimateWhereUniqueInput
  }

  export type UserSettingUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserSettingCreateWithoutProfileInput, UserSettingUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutProfileInput
    upsert?: UserSettingUpsertWithoutProfileInput
    disconnect?: UserSettingWhereInput | boolean
    delete?: UserSettingWhereInput | boolean
    connect?: UserSettingWhereUniqueInput
    update?: XOR<XOR<UserSettingUpdateToOneWithWhereWithoutProfileInput, UserSettingUpdateWithoutProfileInput>, UserSettingUncheckedUpdateWithoutProfileInput>
  }

  export type UserTypeEstimateUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserTypeEstimateCreateWithoutProfileInput, UserTypeEstimateUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserTypeEstimateCreateOrConnectWithoutProfileInput
    upsert?: UserTypeEstimateUpsertWithoutProfileInput
    disconnect?: UserTypeEstimateWhereInput | boolean
    delete?: UserTypeEstimateWhereInput | boolean
    connect?: UserTypeEstimateWhereUniqueInput
    update?: XOR<XOR<UserTypeEstimateUpdateToOneWithWhereWithoutProfileInput, UserTypeEstimateUpdateWithoutProfileInput>, UserTypeEstimateUncheckedUpdateWithoutProfileInput>
  }

  export type UserSettingUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserSettingCreateWithoutProfileInput, UserSettingUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserSettingCreateOrConnectWithoutProfileInput
    upsert?: UserSettingUpsertWithoutProfileInput
    disconnect?: UserSettingWhereInput | boolean
    delete?: UserSettingWhereInput | boolean
    connect?: UserSettingWhereUniqueInput
    update?: XOR<XOR<UserSettingUpdateToOneWithWhereWithoutProfileInput, UserSettingUpdateWithoutProfileInput>, UserSettingUncheckedUpdateWithoutProfileInput>
  }

  export type UserTypeEstimateUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserTypeEstimateCreateWithoutProfileInput, UserTypeEstimateUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserTypeEstimateCreateOrConnectWithoutProfileInput
    upsert?: UserTypeEstimateUpsertWithoutProfileInput
    disconnect?: UserTypeEstimateWhereInput | boolean
    delete?: UserTypeEstimateWhereInput | boolean
    connect?: UserTypeEstimateWhereUniqueInput
    update?: XOR<XOR<UserTypeEstimateUpdateToOneWithWhereWithoutProfileInput, UserTypeEstimateUpdateWithoutProfileInput>, UserTypeEstimateUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileCreateNestedOneWithoutSettingsInput = {
    create?: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSettingsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSettingsInput
    upsert?: ProfileUpsertWithoutSettingsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSettingsInput, ProfileUpdateWithoutSettingsInput>, ProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type UserTraitCreateidealsInput = {
    set: string[]
  }

  export type UserTraitCreatestrugglesInput = {
    set: string[]
  }

  export type UserTraitCreatekeywordsInput = {
    set: string[]
  }

  export type UserTraitUpdateidealsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserTraitUpdatestrugglesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserTraitUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NudgeOutcomeCreateNestedManyWithoutEventInput = {
    create?: XOR<NudgeOutcomeCreateWithoutEventInput, NudgeOutcomeUncheckedCreateWithoutEventInput> | NudgeOutcomeCreateWithoutEventInput[] | NudgeOutcomeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: NudgeOutcomeCreateOrConnectWithoutEventInput | NudgeOutcomeCreateOrConnectWithoutEventInput[]
    createMany?: NudgeOutcomeCreateManyEventInputEnvelope
    connect?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
  }

  export type NudgeOutcomeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<NudgeOutcomeCreateWithoutEventInput, NudgeOutcomeUncheckedCreateWithoutEventInput> | NudgeOutcomeCreateWithoutEventInput[] | NudgeOutcomeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: NudgeOutcomeCreateOrConnectWithoutEventInput | NudgeOutcomeCreateOrConnectWithoutEventInput[]
    createMany?: NudgeOutcomeCreateManyEventInputEnvelope
    connect?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
  }

  export type NudgeOutcomeUpdateManyWithoutEventNestedInput = {
    create?: XOR<NudgeOutcomeCreateWithoutEventInput, NudgeOutcomeUncheckedCreateWithoutEventInput> | NudgeOutcomeCreateWithoutEventInput[] | NudgeOutcomeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: NudgeOutcomeCreateOrConnectWithoutEventInput | NudgeOutcomeCreateOrConnectWithoutEventInput[]
    upsert?: NudgeOutcomeUpsertWithWhereUniqueWithoutEventInput | NudgeOutcomeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: NudgeOutcomeCreateManyEventInputEnvelope
    set?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    disconnect?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    delete?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    connect?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    update?: NudgeOutcomeUpdateWithWhereUniqueWithoutEventInput | NudgeOutcomeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: NudgeOutcomeUpdateManyWithWhereWithoutEventInput | NudgeOutcomeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: NudgeOutcomeScalarWhereInput | NudgeOutcomeScalarWhereInput[]
  }

  export type NudgeOutcomeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<NudgeOutcomeCreateWithoutEventInput, NudgeOutcomeUncheckedCreateWithoutEventInput> | NudgeOutcomeCreateWithoutEventInput[] | NudgeOutcomeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: NudgeOutcomeCreateOrConnectWithoutEventInput | NudgeOutcomeCreateOrConnectWithoutEventInput[]
    upsert?: NudgeOutcomeUpsertWithWhereUniqueWithoutEventInput | NudgeOutcomeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: NudgeOutcomeCreateManyEventInputEnvelope
    set?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    disconnect?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    delete?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    connect?: NudgeOutcomeWhereUniqueInput | NudgeOutcomeWhereUniqueInput[]
    update?: NudgeOutcomeUpdateWithWhereUniqueWithoutEventInput | NudgeOutcomeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: NudgeOutcomeUpdateManyWithWhereWithoutEventInput | NudgeOutcomeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: NudgeOutcomeScalarWhereInput | NudgeOutcomeScalarWhereInput[]
  }

  export type NudgeEventCreateNestedOneWithoutOutcomesInput = {
    create?: XOR<NudgeEventCreateWithoutOutcomesInput, NudgeEventUncheckedCreateWithoutOutcomesInput>
    connectOrCreate?: NudgeEventCreateOrConnectWithoutOutcomesInput
    connect?: NudgeEventWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NudgeEventUpdateOneRequiredWithoutOutcomesNestedInput = {
    create?: XOR<NudgeEventCreateWithoutOutcomesInput, NudgeEventUncheckedCreateWithoutOutcomesInput>
    connectOrCreate?: NudgeEventCreateOrConnectWithoutOutcomesInput
    upsert?: NudgeEventUpsertWithoutOutcomesInput
    connect?: NudgeEventWhereUniqueInput
    update?: XOR<XOR<NudgeEventUpdateToOneWithWhereWithoutOutcomesInput, NudgeEventUpdateWithoutOutcomesInput>, NudgeEventUncheckedUpdateWithoutOutcomesInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ProfileCreateNestedOneWithoutUserTypeEstimateInput = {
    create?: XOR<ProfileCreateWithoutUserTypeEstimateInput, ProfileUncheckedCreateWithoutUserTypeEstimateInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserTypeEstimateInput
    connect?: ProfileWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProfileUpdateOneRequiredWithoutUserTypeEstimateNestedInput = {
    create?: XOR<ProfileCreateWithoutUserTypeEstimateInput, ProfileUncheckedCreateWithoutUserTypeEstimateInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserTypeEstimateInput
    upsert?: ProfileUpsertWithoutUserTypeEstimateInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserTypeEstimateInput, ProfileUpdateWithoutUserTypeEstimateInput>, ProfileUncheckedUpdateWithoutUserTypeEstimateInput>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type HookCandidateCreatetargetProblemTypesInput = {
    set: string[]
  }

  export type HookCandidateCreatetargetUserTypesInput = {
    set: string[]
  }

  export type TiktokPostCreateNestedManyWithoutHookCandidateInput = {
    create?: XOR<TiktokPostCreateWithoutHookCandidateInput, TiktokPostUncheckedCreateWithoutHookCandidateInput> | TiktokPostCreateWithoutHookCandidateInput[] | TiktokPostUncheckedCreateWithoutHookCandidateInput[]
    connectOrCreate?: TiktokPostCreateOrConnectWithoutHookCandidateInput | TiktokPostCreateOrConnectWithoutHookCandidateInput[]
    createMany?: TiktokPostCreateManyHookCandidateInputEnvelope
    connect?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
  }

  export type TiktokPostUncheckedCreateNestedManyWithoutHookCandidateInput = {
    create?: XOR<TiktokPostCreateWithoutHookCandidateInput, TiktokPostUncheckedCreateWithoutHookCandidateInput> | TiktokPostCreateWithoutHookCandidateInput[] | TiktokPostUncheckedCreateWithoutHookCandidateInput[]
    connectOrCreate?: TiktokPostCreateOrConnectWithoutHookCandidateInput | TiktokPostCreateOrConnectWithoutHookCandidateInput[]
    createMany?: TiktokPostCreateManyHookCandidateInputEnvelope
    connect?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
  }

  export type HookCandidateUpdatetargetProblemTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HookCandidateUpdatetargetUserTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TiktokPostUpdateManyWithoutHookCandidateNestedInput = {
    create?: XOR<TiktokPostCreateWithoutHookCandidateInput, TiktokPostUncheckedCreateWithoutHookCandidateInput> | TiktokPostCreateWithoutHookCandidateInput[] | TiktokPostUncheckedCreateWithoutHookCandidateInput[]
    connectOrCreate?: TiktokPostCreateOrConnectWithoutHookCandidateInput | TiktokPostCreateOrConnectWithoutHookCandidateInput[]
    upsert?: TiktokPostUpsertWithWhereUniqueWithoutHookCandidateInput | TiktokPostUpsertWithWhereUniqueWithoutHookCandidateInput[]
    createMany?: TiktokPostCreateManyHookCandidateInputEnvelope
    set?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    disconnect?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    delete?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    connect?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    update?: TiktokPostUpdateWithWhereUniqueWithoutHookCandidateInput | TiktokPostUpdateWithWhereUniqueWithoutHookCandidateInput[]
    updateMany?: TiktokPostUpdateManyWithWhereWithoutHookCandidateInput | TiktokPostUpdateManyWithWhereWithoutHookCandidateInput[]
    deleteMany?: TiktokPostScalarWhereInput | TiktokPostScalarWhereInput[]
  }

  export type TiktokPostUncheckedUpdateManyWithoutHookCandidateNestedInput = {
    create?: XOR<TiktokPostCreateWithoutHookCandidateInput, TiktokPostUncheckedCreateWithoutHookCandidateInput> | TiktokPostCreateWithoutHookCandidateInput[] | TiktokPostUncheckedCreateWithoutHookCandidateInput[]
    connectOrCreate?: TiktokPostCreateOrConnectWithoutHookCandidateInput | TiktokPostCreateOrConnectWithoutHookCandidateInput[]
    upsert?: TiktokPostUpsertWithWhereUniqueWithoutHookCandidateInput | TiktokPostUpsertWithWhereUniqueWithoutHookCandidateInput[]
    createMany?: TiktokPostCreateManyHookCandidateInputEnvelope
    set?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    disconnect?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    delete?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    connect?: TiktokPostWhereUniqueInput | TiktokPostWhereUniqueInput[]
    update?: TiktokPostUpdateWithWhereUniqueWithoutHookCandidateInput | TiktokPostUpdateWithWhereUniqueWithoutHookCandidateInput[]
    updateMany?: TiktokPostUpdateManyWithWhereWithoutHookCandidateInput | TiktokPostUpdateManyWithWhereWithoutHookCandidateInput[]
    deleteMany?: TiktokPostScalarWhereInput | TiktokPostScalarWhereInput[]
  }

  export type HookCandidateCreateNestedOneWithoutTiktokPostsInput = {
    create?: XOR<HookCandidateCreateWithoutTiktokPostsInput, HookCandidateUncheckedCreateWithoutTiktokPostsInput>
    connectOrCreate?: HookCandidateCreateOrConnectWithoutTiktokPostsInput
    connect?: HookCandidateWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type HookCandidateUpdateOneWithoutTiktokPostsNestedInput = {
    create?: XOR<HookCandidateCreateWithoutTiktokPostsInput, HookCandidateUncheckedCreateWithoutTiktokPostsInput>
    connectOrCreate?: HookCandidateCreateOrConnectWithoutTiktokPostsInput
    upsert?: HookCandidateUpsertWithoutTiktokPostsInput
    disconnect?: HookCandidateWhereInput | boolean
    delete?: HookCandidateWhereInput | boolean
    connect?: HookCandidateWhereUniqueInput
    update?: XOR<XOR<HookCandidateUpdateToOneWithWhereWithoutTiktokPostsInput, HookCandidateUpdateWithoutTiktokPostsInput>, HookCandidateUncheckedUpdateWithoutTiktokPostsInput>
  }

  export type WisdomPatternCreatetargetUserTypesInput = {
    set: string[]
  }

  export type WisdomPatternUpdatetargetUserTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type UserSettingCreateWithoutProfileInput = {
    language?: string
    timezone?: string
    notificationsEnabled?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingUncheckedCreateWithoutProfileInput = {
    language?: string
    timezone?: string
    notificationsEnabled?: boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingCreateOrConnectWithoutProfileInput = {
    where: UserSettingWhereUniqueInput
    create: XOR<UserSettingCreateWithoutProfileInput, UserSettingUncheckedCreateWithoutProfileInput>
  }

  export type UserTypeEstimateCreateWithoutProfileInput = {
    primaryType: string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTypeEstimateUncheckedCreateWithoutProfileInput = {
    primaryType: string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserTypeEstimateCreateOrConnectWithoutProfileInput = {
    where: UserTypeEstimateWhereUniqueInput
    create: XOR<UserTypeEstimateCreateWithoutProfileInput, UserTypeEstimateUncheckedCreateWithoutProfileInput>
  }

  export type UserSettingUpsertWithoutProfileInput = {
    update: XOR<UserSettingUpdateWithoutProfileInput, UserSettingUncheckedUpdateWithoutProfileInput>
    create: XOR<UserSettingCreateWithoutProfileInput, UserSettingUncheckedCreateWithoutProfileInput>
    where?: UserSettingWhereInput
  }

  export type UserSettingUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserSettingWhereInput
    data: XOR<UserSettingUpdateWithoutProfileInput, UserSettingUncheckedUpdateWithoutProfileInput>
  }

  export type UserSettingUpdateWithoutProfileInput = {
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingUncheckedUpdateWithoutProfileInput = {
    language?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTypeEstimateUpsertWithoutProfileInput = {
    update: XOR<UserTypeEstimateUpdateWithoutProfileInput, UserTypeEstimateUncheckedUpdateWithoutProfileInput>
    create: XOR<UserTypeEstimateCreateWithoutProfileInput, UserTypeEstimateUncheckedCreateWithoutProfileInput>
    where?: UserTypeEstimateWhereInput
  }

  export type UserTypeEstimateUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserTypeEstimateWhereInput
    data: XOR<UserTypeEstimateUpdateWithoutProfileInput, UserTypeEstimateUncheckedUpdateWithoutProfileInput>
  }

  export type UserTypeEstimateUpdateWithoutProfileInput = {
    primaryType?: StringFieldUpdateOperationsInput | string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTypeEstimateUncheckedUpdateWithoutProfileInput = {
    primaryType?: StringFieldUpdateOperationsInput | string
    typeScores?: JsonNullValueInput | InputJsonValue
    confidence?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutSettingsInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userTypeEstimate?: UserTypeEstimateCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutSettingsInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    userTypeEstimate?: UserTypeEstimateUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutSettingsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
  }

  export type ProfileUpsertWithoutSettingsInput = {
    update: XOR<ProfileUpdateWithoutSettingsInput, ProfileUncheckedUpdateWithoutSettingsInput>
    create: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSettingsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSettingsInput, ProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type ProfileUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userTypeEstimate?: UserTypeEstimateUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userTypeEstimate?: UserTypeEstimateUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type NudgeOutcomeCreateWithoutEventInput = {
    id?: string
    reward?: number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NudgeOutcomeUncheckedCreateWithoutEventInput = {
    id?: string
    reward?: number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NudgeOutcomeCreateOrConnectWithoutEventInput = {
    where: NudgeOutcomeWhereUniqueInput
    create: XOR<NudgeOutcomeCreateWithoutEventInput, NudgeOutcomeUncheckedCreateWithoutEventInput>
  }

  export type NudgeOutcomeCreateManyEventInputEnvelope = {
    data: NudgeOutcomeCreateManyEventInput | NudgeOutcomeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type NudgeOutcomeUpsertWithWhereUniqueWithoutEventInput = {
    where: NudgeOutcomeWhereUniqueInput
    update: XOR<NudgeOutcomeUpdateWithoutEventInput, NudgeOutcomeUncheckedUpdateWithoutEventInput>
    create: XOR<NudgeOutcomeCreateWithoutEventInput, NudgeOutcomeUncheckedCreateWithoutEventInput>
  }

  export type NudgeOutcomeUpdateWithWhereUniqueWithoutEventInput = {
    where: NudgeOutcomeWhereUniqueInput
    data: XOR<NudgeOutcomeUpdateWithoutEventInput, NudgeOutcomeUncheckedUpdateWithoutEventInput>
  }

  export type NudgeOutcomeUpdateManyWithWhereWithoutEventInput = {
    where: NudgeOutcomeScalarWhereInput
    data: XOR<NudgeOutcomeUpdateManyMutationInput, NudgeOutcomeUncheckedUpdateManyWithoutEventInput>
  }

  export type NudgeOutcomeScalarWhereInput = {
    AND?: NudgeOutcomeScalarWhereInput | NudgeOutcomeScalarWhereInput[]
    OR?: NudgeOutcomeScalarWhereInput[]
    NOT?: NudgeOutcomeScalarWhereInput | NudgeOutcomeScalarWhereInput[]
    id?: UuidFilter<"NudgeOutcome"> | string
    nudgeEventId?: UuidFilter<"NudgeOutcome"> | string
    reward?: FloatNullableFilter<"NudgeOutcome"> | number | null
    shortTerm?: JsonFilter<"NudgeOutcome">
    emaScore?: JsonNullableFilter<"NudgeOutcome">
    signals?: JsonFilter<"NudgeOutcome">
    createdAt?: DateTimeFilter<"NudgeOutcome"> | Date | string
  }

  export type NudgeEventCreateWithoutOutcomesInput = {
    id?: string
    userId: string
    domain: string
    subtype: string
    decisionPoint: string
    state: JsonNullValueInput | InputJsonValue
    actionTemplate?: string | null
    channel: string
    sent?: boolean
    createdAt?: Date | string
  }

  export type NudgeEventUncheckedCreateWithoutOutcomesInput = {
    id?: string
    userId: string
    domain: string
    subtype: string
    decisionPoint: string
    state: JsonNullValueInput | InputJsonValue
    actionTemplate?: string | null
    channel: string
    sent?: boolean
    createdAt?: Date | string
  }

  export type NudgeEventCreateOrConnectWithoutOutcomesInput = {
    where: NudgeEventWhereUniqueInput
    create: XOR<NudgeEventCreateWithoutOutcomesInput, NudgeEventUncheckedCreateWithoutOutcomesInput>
  }

  export type NudgeEventUpsertWithoutOutcomesInput = {
    update: XOR<NudgeEventUpdateWithoutOutcomesInput, NudgeEventUncheckedUpdateWithoutOutcomesInput>
    create: XOR<NudgeEventCreateWithoutOutcomesInput, NudgeEventUncheckedCreateWithoutOutcomesInput>
    where?: NudgeEventWhereInput
  }

  export type NudgeEventUpdateToOneWithWhereWithoutOutcomesInput = {
    where?: NudgeEventWhereInput
    data: XOR<NudgeEventUpdateWithoutOutcomesInput, NudgeEventUncheckedUpdateWithoutOutcomesInput>
  }

  export type NudgeEventUpdateWithoutOutcomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    decisionPoint?: StringFieldUpdateOperationsInput | string
    state?: JsonNullValueInput | InputJsonValue
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeEventUncheckedUpdateWithoutOutcomesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    subtype?: StringFieldUpdateOperationsInput | string
    decisionPoint?: StringFieldUpdateOperationsInput | string
    state?: JsonNullValueInput | InputJsonValue
    actionTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    channel?: StringFieldUpdateOperationsInput | string
    sent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutUserTypeEstimateInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserTypeEstimateInput = {
    id: string
    email?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserTypeEstimateInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserTypeEstimateInput, ProfileUncheckedCreateWithoutUserTypeEstimateInput>
  }

  export type ProfileUpsertWithoutUserTypeEstimateInput = {
    update: XOR<ProfileUpdateWithoutUserTypeEstimateInput, ProfileUncheckedUpdateWithoutUserTypeEstimateInput>
    create: XOR<ProfileCreateWithoutUserTypeEstimateInput, ProfileUncheckedCreateWithoutUserTypeEstimateInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserTypeEstimateInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserTypeEstimateInput, ProfileUncheckedUpdateWithoutUserTypeEstimateInput>
  }

  export type ProfileUpdateWithoutUserTypeEstimateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserTypeEstimateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type TiktokPostCreateWithoutHookCandidateInput = {
    id?: string
    tiktokVideoId?: string | null
    blotatoPostId?: string | null
    caption?: string | null
    postedAt?: Date | string
    metricsFetchedAt?: Date | string | null
    viewCount?: bigint | number | null
    likeCount?: bigint | number | null
    commentCount?: bigint | number | null
    shareCount?: bigint | number | null
    agentReasoning?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TiktokPostUncheckedCreateWithoutHookCandidateInput = {
    id?: string
    tiktokVideoId?: string | null
    blotatoPostId?: string | null
    caption?: string | null
    postedAt?: Date | string
    metricsFetchedAt?: Date | string | null
    viewCount?: bigint | number | null
    likeCount?: bigint | number | null
    commentCount?: bigint | number | null
    shareCount?: bigint | number | null
    agentReasoning?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TiktokPostCreateOrConnectWithoutHookCandidateInput = {
    where: TiktokPostWhereUniqueInput
    create: XOR<TiktokPostCreateWithoutHookCandidateInput, TiktokPostUncheckedCreateWithoutHookCandidateInput>
  }

  export type TiktokPostCreateManyHookCandidateInputEnvelope = {
    data: TiktokPostCreateManyHookCandidateInput | TiktokPostCreateManyHookCandidateInput[]
    skipDuplicates?: boolean
  }

  export type TiktokPostUpsertWithWhereUniqueWithoutHookCandidateInput = {
    where: TiktokPostWhereUniqueInput
    update: XOR<TiktokPostUpdateWithoutHookCandidateInput, TiktokPostUncheckedUpdateWithoutHookCandidateInput>
    create: XOR<TiktokPostCreateWithoutHookCandidateInput, TiktokPostUncheckedCreateWithoutHookCandidateInput>
  }

  export type TiktokPostUpdateWithWhereUniqueWithoutHookCandidateInput = {
    where: TiktokPostWhereUniqueInput
    data: XOR<TiktokPostUpdateWithoutHookCandidateInput, TiktokPostUncheckedUpdateWithoutHookCandidateInput>
  }

  export type TiktokPostUpdateManyWithWhereWithoutHookCandidateInput = {
    where: TiktokPostScalarWhereInput
    data: XOR<TiktokPostUpdateManyMutationInput, TiktokPostUncheckedUpdateManyWithoutHookCandidateInput>
  }

  export type TiktokPostScalarWhereInput = {
    AND?: TiktokPostScalarWhereInput | TiktokPostScalarWhereInput[]
    OR?: TiktokPostScalarWhereInput[]
    NOT?: TiktokPostScalarWhereInput | TiktokPostScalarWhereInput[]
    id?: UuidFilter<"TiktokPost"> | string
    hookCandidateId?: UuidNullableFilter<"TiktokPost"> | string | null
    tiktokVideoId?: StringNullableFilter<"TiktokPost"> | string | null
    blotatoPostId?: StringNullableFilter<"TiktokPost"> | string | null
    caption?: StringNullableFilter<"TiktokPost"> | string | null
    postedAt?: DateTimeFilter<"TiktokPost"> | Date | string
    metricsFetchedAt?: DateTimeNullableFilter<"TiktokPost"> | Date | string | null
    viewCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    likeCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    commentCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    shareCount?: BigIntNullableFilter<"TiktokPost"> | bigint | number | null
    agentReasoning?: StringNullableFilter<"TiktokPost"> | string | null
    scheduledAt?: DateTimeNullableFilter<"TiktokPost"> | Date | string | null
    createdAt?: DateTimeFilter<"TiktokPost"> | Date | string
  }

  export type HookCandidateCreateWithoutTiktokPostsInput = {
    id?: string
    text: string
    tone: string
    targetProblemTypes?: HookCandidateCreatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateCreatetargetUserTypesInput | string[]
    appTapRate?: Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: Decimal | DecimalJsLike | number | string
    appSampleSize?: number
    tiktokLikeRate?: Decimal | DecimalJsLike | number | string
    tiktokShareRate?: Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: number
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HookCandidateUncheckedCreateWithoutTiktokPostsInput = {
    id?: string
    text: string
    tone: string
    targetProblemTypes?: HookCandidateCreatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateCreatetargetUserTypesInput | string[]
    appTapRate?: Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: Decimal | DecimalJsLike | number | string
    appSampleSize?: number
    tiktokLikeRate?: Decimal | DecimalJsLike | number | string
    tiktokShareRate?: Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: number
    tiktokHighPerformer?: boolean
    isWisdom?: boolean
    explorationWeight?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HookCandidateCreateOrConnectWithoutTiktokPostsInput = {
    where: HookCandidateWhereUniqueInput
    create: XOR<HookCandidateCreateWithoutTiktokPostsInput, HookCandidateUncheckedCreateWithoutTiktokPostsInput>
  }

  export type HookCandidateUpsertWithoutTiktokPostsInput = {
    update: XOR<HookCandidateUpdateWithoutTiktokPostsInput, HookCandidateUncheckedUpdateWithoutTiktokPostsInput>
    create: XOR<HookCandidateCreateWithoutTiktokPostsInput, HookCandidateUncheckedCreateWithoutTiktokPostsInput>
    where?: HookCandidateWhereInput
  }

  export type HookCandidateUpdateToOneWithWhereWithoutTiktokPostsInput = {
    where?: HookCandidateWhereInput
    data: XOR<HookCandidateUpdateWithoutTiktokPostsInput, HookCandidateUncheckedUpdateWithoutTiktokPostsInput>
  }

  export type HookCandidateUpdateWithoutTiktokPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    targetProblemTypes?: HookCandidateUpdatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateUpdatetargetUserTypesInput | string[]
    appTapRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokLikeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokHighPerformer?: BoolFieldUpdateOperationsInput | boolean
    isWisdom?: BoolFieldUpdateOperationsInput | boolean
    explorationWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HookCandidateUncheckedUpdateWithoutTiktokPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    targetProblemTypes?: HookCandidateUpdatetargetProblemTypesInput | string[]
    targetUserTypes?: HookCandidateUpdatetargetUserTypesInput | string[]
    appTapRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appThumbsUpRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    appSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokLikeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokShareRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tiktokSampleSize?: IntFieldUpdateOperationsInput | number
    tiktokHighPerformer?: BoolFieldUpdateOperationsInput | boolean
    isWisdom?: BoolFieldUpdateOperationsInput | boolean
    explorationWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeOutcomeCreateManyEventInput = {
    id?: string
    reward?: number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NudgeOutcomeUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeOutcomeUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NudgeOutcomeUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    reward?: NullableFloatFieldUpdateOperationsInput | number | null
    shortTerm?: JsonNullValueInput | InputJsonValue
    emaScore?: NullableJsonNullValueInput | InputJsonValue
    signals?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiktokPostCreateManyHookCandidateInput = {
    id?: string
    tiktokVideoId?: string | null
    blotatoPostId?: string | null
    caption?: string | null
    postedAt?: Date | string
    metricsFetchedAt?: Date | string | null
    viewCount?: bigint | number | null
    likeCount?: bigint | number | null
    commentCount?: bigint | number | null
    shareCount?: bigint | number | null
    agentReasoning?: string | null
    scheduledAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TiktokPostUpdateWithoutHookCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiktokPostUncheckedUpdateWithoutHookCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TiktokPostUncheckedUpdateManyWithoutHookCandidateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tiktokVideoId?: NullableStringFieldUpdateOperationsInput | string | null
    blotatoPostId?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    postedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metricsFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    likeCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    commentCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    shareCount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    agentReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use NudgeEventCountOutputTypeDefaultArgs instead
     */
    export type NudgeEventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NudgeEventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HookCandidateCountOutputTypeDefaultArgs instead
     */
    export type HookCandidateCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HookCandidateCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDefaultArgs instead
     */
    export type TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MobileProfileDefaultArgs instead
     */
    export type MobileProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MobileProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSubscriptionDefaultArgs instead
     */
    export type UserSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionEventDefaultArgs instead
     */
    export type SubscriptionEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonthlyVcGrantDefaultArgs instead
     */
    export type MonthlyVcGrantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonthlyVcGrantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSettingDefaultArgs instead
     */
    export type UserSettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTraitDefaultArgs instead
     */
    export type UserTraitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTraitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyMetricDefaultArgs instead
     */
    export type DailyMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NudgeEventDefaultArgs instead
     */
    export type NudgeEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NudgeEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NudgeOutcomeDefaultArgs instead
     */
    export type NudgeOutcomeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NudgeOutcomeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeelingSessionDefaultArgs instead
     */
    export type FeelingSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeelingSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BanditModelDefaultArgs instead
     */
    export type BanditModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BanditModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTypeEstimateDefaultArgs instead
     */
    export type UserTypeEstimateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTypeEstimateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypeStatsDefaultArgs instead
     */
    export type TypeStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypeStatsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HookCandidateDefaultArgs instead
     */
    export type HookCandidateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HookCandidateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TiktokPostDefaultArgs instead
     */
    export type TiktokPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TiktokPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WisdomPatternDefaultArgs instead
     */
    export type WisdomPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WisdomPatternDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}