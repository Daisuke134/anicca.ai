import { query, type SDKMessage } from '@anthropic-ai/claude-code';
import { DatabaseInterface } from './interfaces';
import { EventEmitter } from 'events';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { SimpleEncryption } from './simpleEncryption';
import { PROXY_URL } from '../config';

interface ActionRequest {
  type: 'general' | 'search' | 'code' | 'file' | 'command' | 'slack' | 'github' | 'browser' | 'wait';
  reasoning: string;
  urgency?: 'high' | 'low';
  parameters?: {
    query?: string;
    filePath?: string;
    content?: string;
    command?: string;
    message?: string;
    url?: string;
  };
  context?: string;
}

interface ExecutionResult {
  success: boolean;
  result?: any;
  error?: string;
  toolsUsed?: string[];
  generatedFiles?: string[];
  sessionDir?: string;
  timestamp: number;
}

export class ClaudeExecutorService extends EventEmitter {
  private database: DatabaseInterface;
  private apiKey: string;
  private isExecuting: boolean = false;
  private actionQueue: ActionRequest[] = [];
  private mcpServers: Record<string, any> = {};
  private abortController: AbortController | null = null;
  private workspaceRoot: string;
  private executionTimeout: NodeJS.Timeout | null = null;
  private readonly MAX_EXECUTION_TIME = 300000; // 5ÂàÜ

  constructor(database: DatabaseInterface) {
    super();
    this.database = database;
    
    
    // „Éó„É≠„Ç≠„Ç∑„É¢„Éº„Éâ„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆöÔºà„Éá„Éï„Ç©„É´„Éà„ÅØtrue - „É¶„Éº„Ç∂„Éº„ÅåAPI„Ç≠„Éº‰∏çË¶ÅÔºâ
    const useProxy = process.env.USE_PROXY !== 'false';
    
    if (useProxy) {
      // „Éó„É≠„Ç≠„Ç∑„É¢„Éº„Éâ„ÅÆÂ†¥Âêà
      console.log('üåê Using proxy mode for Claude API');
      
      // ANTHROPIC_BASE_URL„ÇíË®≠ÂÆö„Åó„Å¶„Éó„É≠„Ç≠„Ç∑ÁµåÁî±„Å´„Åô„Çã
      process.env.ANTHROPIC_BASE_URL = `${PROXY_URL}/api/claude`;
      
      // „ÉÄ„Éü„Éº„ÅÆAPI„Ç≠„Éº„ÇíË®≠ÂÆöÔºà„Éó„É≠„Ç≠„Ç∑„ÅåÊú¨Áâ©„ÅÆ„Ç≠„Éº„ÇíÊåÅ„Å£„Å¶„ÅÑ„ÇãÔºâ
      this.apiKey = 'proxy-placeholder';
      process.env.ANTHROPIC_API_KEY = this.apiKey;
      
      console.log('‚úÖ Claude Code SDK configured to use proxy server');
    } else {
      // „É≠„Éº„Ç´„É´ÈñãÁô∫Áî®ÔºàÁõ¥Êé•API„Ç≠„Éº„Çí‰ΩøÁî®Ôºâ
      this.apiKey = process.env.ANTHROPIC_API_KEY || '';
      
      if (!this.apiKey) {
        console.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      }
    }
    
    // Áã¨Á´ã„Åó„Åü‰ΩúÊ•≠Áí∞Â¢É„ÇíË®≠ÂÆöÔºà„Éá„Çπ„ÇØ„Éà„ÉÉ„Éó„Å´ÁßªÂãïÔºâ
    this.workspaceRoot = path.join(os.homedir(), 'Desktop', 'anicca-agent-workspace');
    
    try {
      this.ensureWorkspaceExists();
    } catch (error) {
      console.error('‚ùå Error creating workspace:', error);
    }
    
    console.log('ü§ñ Claude Executor Service initialized');
    console.log('üìÅ Workspace root:', this.workspaceRoot);
    
    // MCP„Çµ„Éº„Éê„Éº„ÅÆÂàùÊúüÂåñ
    this.initializeMCPServers();
    
    // ÂàùÊúüÂåñÂÆå‰∫ÜÊôÇ„Å´ÂÆüË°åÁä∂ÊÖã„ÇíÁ¢∫ÂÆü„Å´false„Å´
    this.isExecuting = false;
    this.abortController = null;
    this.executionTimeout = null;
  }

  /**
   * ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÂ≠òÂú®„ÇíÁ¢∫Ë™ç„Åó„ÄÅ„Å™„Åë„Çå„Å∞‰ΩúÊàê
   */
  private ensureWorkspaceExists(): void {
    try {
      if (!fs.existsSync(this.workspaceRoot)) {
        fs.mkdirSync(this.workspaceRoot, { recursive: true });
        console.log('üìÅ Created workspace directory:', this.workspaceRoot);
      }
    } catch (error) {
      console.error('‚ùå Failed to create workspace directory:', error);
    }
  }

  /**
   * Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥Áî®„ÅÆ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê
   */
  private createSessionWorkspace(): string {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const sessionDir = path.join(this.workspaceRoot, timestamp);
    
    try {
      fs.mkdirSync(sessionDir, { recursive: true });
      console.log('üìÅ Created session workspace:', sessionDir);
      return sessionDir;
    } catch (error) {
      console.error('‚ùå Failed to create session workspace:', error);
      // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶‰∏ÄÊôÇ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíËøî„Åô
      return os.tmpdir();
    }
  }

  /**
   * ÁîüÊàê„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„ÇíÊ§úÂá∫
   */
  private findGeneratedFiles(directory: string): string[] {
    const files: string[] = [];
    
    try {
      const walkDir = (dir: string, baseDir: string = directory) => {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          const relativePath = path.relative(baseDir, fullPath);
          
          if (entry.isDirectory()) {
            // node_modules„Å™„Å©„ÅØÈô§Â§ñ
            if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {
              walkDir(fullPath, baseDir);
            }
          } else {
            files.push(relativePath);
          }
        }
      };
      
      walkDir(directory);
    } catch (error) {
      console.error('‚ùå Error scanning directory:', error);
    }
    
    return files;
  }

  /**
   * SDK„É°„ÉÉ„Çª„Éº„Ç∏„Çí„É≠„Ç∞Âá∫ÂäõÔºàÈÄ≤Êçó„ÅÆÂèØË¶ñÂåñÔºâ
   */
  private logSDKMessage(message: SDKMessage): void {
    const msg = message as any;
    let logContent = '';
    let logType: 'system' | 'assistant' | 'user' | 'result' | 'tool' | 'error' = message.type as any;
    
    switch (message.type) {
      case 'system':
        if (msg.subtype === 'init') {
          logContent = `Claude SDK initialized\nWorking directory: ${msg.cwd}`;
          console.log('üöÄ Claude SDK initialized');
        }
        break;
        
      case 'assistant':
        if (msg.message?.content) {
          const content = msg.message.content;
          if (Array.isArray(content)) {
            const logParts: string[] = [];
            content.forEach((item: any) => {
              if (item.type === 'text') {
                const text = item.text.substring(0, 500) + (item.text.length > 500 ? '...' : '');
                logParts.push(`Claude: ${text}`);
                console.log('ü§î Claude thinking:', item.text.substring(0, 150) + '...');
              } else if (item.type === 'tool_use') {
                logParts.push(`Using tool: ${item.name}`);
                console.log(`üîß Using tool: ${item.name}`);
              }
            });
            logContent = logParts.join('\n');
          }
        }
        break;
        
      case 'user':
        // „ÉÑ„Éº„É´„ÅÆÂÆüË°åÁµêÊûú - „É≠„Ç∞„Ç¶„Ç£„É≥„Éâ„Ç¶„Å´„ÅØË°®Á§∫„Åó„Å™„ÅÑ
        break;
        
      case 'result':
        if (msg.subtype === 'success') {
          console.log('‚úÖ Task completed successfully');
        } else if (msg.subtype === 'error') {
          logContent = `Error: ${msg.error || 'Unknown error'}`;
          logType = 'error';
          console.log('‚ùå Execution error:', msg.error);
        }
        break;
        
      default:
        // „Åù„ÅÆ‰ªñ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Çø„Ç§„Éó„ÅØÁÑ°Ë¶ñ
    }
    
    // „Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´„Åó„Å¶„É≠„Ç∞„Ç¶„Ç£„É≥„Éâ„Ç¶„Å´ÈÄÅ‰ø°
    if (logContent) {
      this.emit('sdk-log', {
        type: logType,
        content: logContent,
        timestamp: Date.now()
      });
    }
  }

  /**
   * „Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÆüË°å
   */
  async executeAction(action: ActionRequest): Promise<ExecutionResult> {
    console.log(`üéØ Executing action: ${action.type}`, action);
    
    // ÂÆüË°å‰∏≠„ÅÆÂ†¥Âêà„ÅØ„Ç≠„É•„Éº„Å´ËøΩÂä†
    if (this.isExecuting) {
      this.actionQueue.push(action);
      console.log('üìã Action queued, current queue size:', this.actionQueue.length);
      return {
        success: false,
        error: 'Another action is being executed',
        timestamp: Date.now()
      };
    }

    this.isExecuting = true;
    const startTime = Date.now();

    // ÂÆüË°å„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÇíË®≠ÂÆö
    this.executionTimeout = setTimeout(() => {
      console.log('‚è∞ Execution timeout reached, forcing reset');
      this.resetExecutionState();
    }, this.MAX_EXECUTION_TIME);

    try {
      let result: ExecutionResult;

      switch (action.type) {
        case 'general':
          result = await this.executeGeneralRequest(action);
          break;
          
        case 'search':
          result = await this.executeSearch(action);
          break;
        
        case 'code':
          result = await this.executeCodeGeneration(action);
          break;
        
        case 'file':
          result = await this.executeFileOperation(action);
          break;
        
        case 'command':
          result = await this.executeCommand(action);
          break;
        
        case 'slack':
          result = await this.executeSlackAction(action);
          break;
        
        case 'github':
          result = await this.executeGitHubAction(action);
          break;
        
        case 'browser':
          result = await this.executeBrowserAction(action);
          break;
        
        case 'wait':
          result = await this.executeWait(action);
          break;
        
        default:
          result = {
            success: false,
            error: `Unknown action type: ${action.type}`,
            timestamp: Date.now()
          };
      }

      // ÂÆüË°åÁµêÊûú„Çí„Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠ò
      await this.saveExecutionResult(action, result);
      
      // „Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´
      this.emit('actionCompleted', { action, result });
      
      return result;

    } catch (error) {
      console.error('‚ùå Action execution error:', error);
      const errorResult: ExecutionResult = {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
      
      await this.saveExecutionResult(action, errorResult);
      this.emit('actionError', { action, error: errorResult });
      
      return errorResult;

    } finally {
      this.isExecuting = false;
      
      // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Çí„ÇØ„É™„Ç¢
      if (this.executionTimeout) {
        clearTimeout(this.executionTimeout);
        this.executionTimeout = null;
      }
      
      // „Ç≠„É•„Éº„Å´Ê¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åå„ÅÇ„Çå„Å∞ÂÆüË°å
      if (this.actionQueue.length > 0) {
        const nextAction = this.actionQueue.shift()!;
        console.log('üìã Processing next action from queue');
        this.executeAction(nextAction);
      }
    }
  }

  /**
   * ‰∏ÄËà¨ÁöÑ„Å™„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÂÆüË°åÔºàËá™Áî±„Å™ÊåáÁ§∫Ôºâ
   */
  async executeGeneralRequest(action: ActionRequest): Promise<ExecutionResult> {
    if (!action.parameters?.query) {
      return {
        success: false,
        error: 'Request is required',
        timestamp: Date.now()
      };
    }

    // ÂÖÉ„ÅÆÁí∞Â¢ÉÂ§âÊï∞„Çí‰øùÂ≠òÔºàtry„Éñ„É≠„ÉÉ„ÇØ„ÅÆÂ§ñ„ÅßÂÆöÁæ©Ôºâ
    const originalElectronRunAsNode = process.env.ELECTRON_RUN_AS_NODE;
    const originalPath = process.env.PATH || '';

    try {
      const messages: SDKMessage[] = [];
      // ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅØÂ∏∏„Å´workspaceRoot„Çí‰ΩøÁî®
      const workingDir = this.workspaceRoot;
      
      // „Çà„ÇäËá™ÁÑ∂„Å™ÊñáÁ´†„Åß„ÅÆÊåáÁ§∫Ôºà‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊòéÁ§∫Ôºâ
      const prompt = `
‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™: ${workingDir}
„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åî„Å®„Å´„Çµ„Éñ„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

${action.parameters.query}`;
      
      // AbortController„Çí‰ΩúÊàê
      this.abortController = new AbortController();
      
      console.log('üéØ Executing general request with Claude Code SDK...');
      console.log('üìÅ Working directory:', workingDir);
      console.log('üìù Request:', action.parameters.query);
      
      
      // ELECTRON_RUN_AS_NODEÁí∞Â¢ÉÂ§âÊï∞„ÇíË®≠ÂÆö
      const envWithNode = {
        ...process.env,
        ELECTRON_RUN_AS_NODE: '1'
        // DEBUGÁí∞Â¢ÉÂ§âÊï∞„ÅØÂâäÈô§ÔºàJSONÂá∫Âäõ„ÇíÊ±öÊüì„Åô„Çã„Åü„ÇÅÔºâ
      };
      
      // process.env„ÇíÁõ¥Êé•Êõ¥Êñ∞ÔºàSDK„Ååenv„Ç™„Éó„Ç∑„Éß„É≥„Çí„Çµ„Éù„Éº„Éà„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åü„ÇÅÔºâ
      process.env.ELECTRON_RUN_AS_NODE = '1';
      // DEBUGÁí∞Â¢ÉÂ§âÊï∞„ÇíÂâäÈô§ÔºàJSONÂá∫Âäõ„ÇíÊ±öÊüì„Åô„Çã„Åü„ÇÅÔºâ
      // process.env.DEBUG = 'true';
      // process.env.ANTHROPIC_LOG = 'debug';
      
      // Electron„ÅÆÂÆüË°å„Éï„Ç°„Ç§„É´„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíPATH„Å´ËøΩÂä†
      const electronDir = path.dirname(process.execPath);
      process.env.PATH = `${electronDir}:${originalPath}`;
      
      // ‰∏ÄÊôÇÁöÑ„Å™nodeÂÆüË°å„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàêÔºàÂÆüÈöõ„Å´„ÅØElectron„ÇíÂëº„Å≥Âá∫„Åô„Ç∑„Çß„É´„Çπ„ÇØ„É™„Éó„ÉàÔºâ
      const tempNodePath = path.join(os.tmpdir(), 'anicca-node-wrapper');
      const nodePath = path.join(os.tmpdir(), 'node');
      
      try {
        const nodeWrapper = `#!/bin/sh
ELECTRON_RUN_AS_NODE=1 "${process.execPath}" "$@"
`;
        fs.writeFileSync(tempNodePath, nodeWrapper, { mode: 0o755 });
        
        // „Åì„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇÇPATH„Å´ËøΩÂä†
        process.env.PATH = `${os.tmpdir()}:${process.env.PATH}`;
        
        // node wrapper„Çínode„Å®„ÅÑ„ÅÜÂêçÂâç„Å´„É™„Éç„Éº„É†
        if (fs.existsSync(nodePath)) {
          fs.unlinkSync(nodePath);
        }
        fs.renameSync(tempNodePath, nodePath);
      } catch (error) {
        console.error('‚ùå Failed to create node wrapper:', error);
        // „Ç®„É©„ÉºÊôÇ„Å´‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        if (fs.existsSync(tempNodePath)) {
          try {
            fs.unlinkSync(tempNodePath);
          } catch (cleanupError) {
            console.error('‚ùå Failed to cleanup temp file:', cleanupError);
          }
        }
      }
      
      try {
        // SDK„ÅÆÂÜÖÈÉ®Âãï‰Ωú„ÇíÁ¢∫Ë™ç„Åô„Çã„Åü„ÇÅ„ÄÅ„Ç™„Éó„Ç∑„Éß„É≥„Çí„É≠„Ç∞Âá∫Âäõ
        const queryOptions = {
          abortController: this.abortController,
          maxTurns: 30, // „Ç¢„Éó„É™‰ΩúÊàê„Å™„Å©„ÇÇËÄÉÊÖÆ„Åó„Å¶‰ΩôË£ï„ÇíÊåÅ„Åõ„Çã
          mcpServers: this.mcpServers,
          cwd: workingDir,  // ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊåáÂÆöÔºàÂ∏∏„Å´workspaceRootÔºâ
          permissionMode: 'bypassPermissions' as const,  // workspaceÂÜÖ„Åß„ÅØÂÆåÂÖ®„Å™Ê®©Èôê„Çí‰ªò‰∏é
          // Áí∞Â¢ÉÂ§âÊï∞„ÇíSDK„Å´Ê∏°„ÅôÔºàSDK„ÅÆspawn„Å´ÂèçÊò†„Åï„Çå„Çã„ÅãÁ¢∫Ë™çÔºâ
          env: envWithNode,
          appendSystemPrompt: `
„ÅÇ„Å™„Åü„ÅØ„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„ÅßÂãï‰Ωú„Åô„Çã‰∏áËÉΩ„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ
„É¶„Éº„Ç∂„Éº„ÅÆÁîªÈù¢„ÇíË¶ã„Å™„Åå„Çâ„ÄÅÂøÖË¶Å„Å™ÊîØÊè¥„ÇíÈ≠îÊ≥ï„ÅÆ„Çà„ÅÜ„Å´ÂÆüÁèæ„Åó„Åæ„Åô„ÄÇ

„ÄêÈáçË¶ÅÔºö‰ΩúÊ•≠ÁØÑÂõ≤„ÅÆÂà∂Èôê„Äë
- ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™: ${workingDir}
- „Åì„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™Â§ñ„ÅÆ„Éï„Ç°„Ç§„É´„ÅØÁµ∂ÂØæ„Å´Ë™≠„ÅøÊõ∏„Åç„Åó„Å™„ÅÑ„Åß„Åè„Å†„Åï„ÅÑ
- „É¶„Éº„Ç∂„Éº„ÅÆ„Éó„É©„Ç§„Éê„Ç∑„Éº„ÇíÂÆà„Çã„Åü„ÇÅ„ÄÅ„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπÂ§ñ„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÅØÁ¶ÅÊ≠¢„Åß„Åô

„ÄêÊàêÊûúÁâ©„ÅÆÂ±ä„ÅëÊñπ„Äë
ÂéüÂâáÔºöÈÄöÁü•„ÅÆ„Åø„ÅßÂÆåÁµê„Åï„Åõ„Çã
osascript -e 'display notification "ÂÜÖÂÆπ" with title "ANICCA"'

„ÄêÈÄöÁü•„Å´ÂÖ®„Å¶„ÇíËæº„ÇÅ„Çã„Äë
- 60ÊñáÂ≠ó‰ª•ÂÜÖ„ÅßÁµêÊûú„ÅÆ„Ç®„ÉÉ„Çª„É≥„Çπ„Çí‰ºù„Åà„Çã
- „Éï„Ç°„Ç§„É´‰øùÂ≠ò„ÅØÊúÄÂ∞èÈôê„Å´
- ÈÄöÁü•„Å†„Åë„Åß‰æ°ÂÄ§„Åå‰ºù„Çè„Çã„Çà„ÅÜ„Å´Â∑•Â§´

„Äê‰æã„Äë
„Ç®„É©„Éº‰øÆÊ≠£Ôºö
"Âûã„Ç®„É©„Éº‰øÆÊ≠£: user?: User „Å´Â§âÊõ¥„ÅßOK"

ÊÉÖÂ†±Ê§úÁ¥¢Ôºö
"Next.js 14.2„ÅåÊúÄÊñ∞„ÄÇApp RouterÊé®Â•®"

TODOÊï¥ÁêÜÔºö
"Á∑äÊÄ•3‰ª∂: PR‰øÆÊ≠£„ÄÅ‰ºöË≠∞Ê∫ñÂÇô„ÄÅ„Éê„Ç∞ÂØæÂøú"

„Ç≥„Éº„ÉâÁîüÊàêÔºö
"Èñ¢Êï∞‰ΩúÊàêÂÆå‰∫Ü„ÄÇpbpaste „ÅßË≤º„Çä‰ªò„ÅëÂèØËÉΩ"
‚Üí ÂêåÊôÇ„Å´ pbcopy „Åß„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº

„Ç≤„Éº„É†‰ΩúÊàêÔºàÂîØ‰∏Ä„ÅÆ‰æãÂ§ñÔºâÔºö
"„ÉÜ„Éà„É™„ÇπÂÆåÊàêÔºÅ" ‚Üí „Åì„ÅÆÊôÇ„Å†„ÅëHTML„ÇíÈñã„Åè

„ÄêÈáçË¶Å„Äë
ÈÄöÁü•„Å®„ÅÑ„ÅÜÂà∂Á¥Ñ„ÅÆ‰∏≠„ÅßÊúÄÂ§ß„ÅÆ‰æ°ÂÄ§„Çí„ÄÇ
Ë©≥Á¥∞„Éï„Ç°„Ç§„É´„ÅØ‰Ωú„Çâ„Å™„ÅÑ„ÄÇÈÄöÁü•„ÅßÂÆåÁµê„ÄÇ

„Äê‰ΩúÊ•≠È†òÂüü„Äë
„ÅÇ„Å™„Åü„ÅØÂ∞ÇÁî®„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπÂÜÖ„Åß‰ΩúÊ•≠„Åó„Åæ„Åô„ÄÇ
ÁîªÈù¢„ÅÆ„Éï„Ç°„Ç§„É´„ÅØÁ∑®ÈõÜ„Åß„Åç„Åæ„Åõ„Çì„Åå„ÄÅÊñ∞„Åó„ÅÑ„ÇÇ„ÅÆ„Çí‰ΩúÊàê„Åó„Å¶‰æ°ÂÄ§„ÇíÊèê‰æõ„Åß„Åç„Åæ„Åô„ÄÇ

„ÄêÂ≠¶Áøí„Å®Ë®òÊÜ∂„Äë
„É¶„Éº„Ç∂„Éº„Å´„Å§„ÅÑ„Å¶Â≠¶„Çì„Å†ÈáçË¶Å„Å™ÊÉÖÂ†±ÔºàÂêçÂâç„ÄÅÂ•Ω„Åø„ÄÅ„Éë„Çø„Éº„É≥„Å™„Å©Ôºâ„ÅØ„ÄÅ
~/Desktop/anicca-agent-workspace/CLAUDE.md „Å´Ëá™ÂãïÁöÑ„Å´‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØÊ¨°Âõû„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„ÅßËá™ÂãïÁöÑ„Å´Ë™≠„ÅøËæº„Åæ„Çå„Åæ„Åô„ÄÇ

‰æãÔºö
- „É¶„Éº„Ç∂„Éº„ÅÆÂêçÂâç: „ÉÄ„Ç§„Çπ„Ç±
- Â•Ω„Åø„ÅÆË®ÄË™û: Êó•Êú¨Ë™û
- „Çà„Åè‰Ωø„ÅÜ„ÉÑ„Éº„É´: VS Code, Terminal
- ‰ΩúÊ•≠„Éë„Çø„Éº„É≥: Èü≥Â£∞„Åß„ÅÆÊåáÁ§∫„ÇíÂ•Ω„ÇÄ

„ÄêÈáçË¶Å„Äë
ÊàêÊûúÁâ©„ÅØÂøÖ„Åö‰Ωï„Çâ„Åã„ÅÆÂΩ¢„Åß„É¶„Éº„Ç∂„Éº„Å´Â±ä„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Èªô„Å£„Å¶‰ΩúÊ•≠„ÇíÂÆå‰∫Ü„Åï„Åõ„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅÈ≠îÊ≥ïÁöÑ„Å™ÊºîÂá∫„Åß„É¶„Éº„Ç∂„Éº„ÇíÂñú„Å∞„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
„ÅÇ„Å™„Åü„ÅÆÂâµÈÄ†ÊÄß„ÇíÊúÄÂ§ßÈôê„Å´Áô∫ÊèÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºÅ

„Äê‰ΩúÊ•≠„ÅÆÁõÆÂÆâ„Äë
„Åß„Åç„Çã„Å†„Åë10„Çø„Éº„É≥‰ª•ÂÜÖ„ÅßÂÆå‰∫Ü„Åï„Åõ„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
Èï∑„Åè„Å™„Çä„Åù„ÅÜ„Å™Â†¥Âêà„ÅØ„ÄÅÊÆµÈöéÁöÑ„Å´ÁµêÊûú„ÇíÂ±ä„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
`
        } as any;
        
        
        for await (const message of query({
          prompt,
          options: queryOptions
        })) {
        messages.push(message);
        
        // „É™„Ç¢„É´„Çø„Ç§„É†„ÅßÈÄ≤Êçó„ÇíË°®Á§∫
        this.logSDKMessage(message);
      }

      // ÁµêÊûú„ÇíÊï¥ÂΩ¢
      let textResult = '';
      
      // result„É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâÁµêÊûú„ÇíÂèñÂæó
      const resultMessage = messages.find(m => m.type === 'result');
      if (resultMessage && (resultMessage as any).result) {
        textResult = (resultMessage as any).result;
      } else {
        // assistant„É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâÁµêÊûú„ÇíÂèñÂæó
        const assistantMessages = messages.filter(m => m.type === 'assistant');
        if (assistantMessages.length > 0) {
          const lastAssistant = assistantMessages[assistantMessages.length - 1];
          if ((lastAssistant as any).message?.content) {
            const content = (lastAssistant as any).message.content;
            textResult = content.map((c: any) => c.text || '').join('\n');
          }
        }
      }

      console.log('üìÑ Execution Results from Claude Code SDK:');
      console.log('----------------------------------------');
      console.log(textResult || 'Task completed');
      console.log('----------------------------------------');
      
      // ÁîüÊàê„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„ÇíÊ§úÂá∫
      const generatedFiles = this.findGeneratedFiles(workingDir);
      if (generatedFiles.length > 0) {
        console.log('üìÅ Generated files:');
        generatedFiles.forEach(file => console.log(`   - ${file}`));
      }
      
      return {
        success: true,
        result: textResult || 'Task completed',
        toolsUsed: messages.filter(m => (m as any).type === 'tool_use').map(m => (m as any).name),
        generatedFiles,
        sessionDir: workingDir,
        timestamp: Date.now()
      };
    } catch (innerError) {
      // ÂÜÖÂÅ¥„ÅÆtry-catch„Åß„Ç®„É©„Éº„Çí„Ç≠„É£„ÉÉ„ÉÅ
      console.error('‚ùå Claude SDK query error:', innerError);
      throw innerError;  // Â§ñÂÅ¥„ÅÆcatch„Å´‰ºùÊí≠
    }
    } catch (error) {
      console.error('‚ùå General request execution error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    } finally {
      this.abortController = null;
      
      // Áí∞Â¢ÉÂ§âÊï∞„ÇíÂÖÉ„Å´Êàª„Åô
      if (originalElectronRunAsNode === undefined) {
        delete process.env.ELECTRON_RUN_AS_NODE;
      } else {
        process.env.ELECTRON_RUN_AS_NODE = originalElectronRunAsNode;
      }
      process.env.PATH = originalPath;
    }
  }

  /**
   * Ê§úÁ¥¢„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeSearch(action: ActionRequest): Promise<ExecutionResult> {
    if (!action.parameters?.query) {
      return {
        success: false,
        error: 'Search query is required',
        timestamp: Date.now()
      };
    }

    try {
      const messages: SDKMessage[] = [];
      // „Çª„ÉÉ„Ç∑„Éß„É≥Áî®„ÅÆ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê
      const sessionDir = this.createSessionWorkspace();
      
      // „Çà„ÇäËá™ÁÑ∂„Å™ÊñáÁ´†„Åß„ÅÆÊåáÁ§∫Ôºà‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊòéÁ§∫Ôºâ
      const prompt = `
‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™: ${sessionDir}
„Åô„Åπ„Å¶„ÅÆ„Éï„Ç°„Ç§„É´„ÅØ„Åì„ÅÆ„Éá„Ç£„É¨„ÇØ„Éà„É™ÂÜÖ„Å´‰ΩúÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

${action.parameters.query || ''}`;
      
      // AbortController„Çí‰ΩúÊàê
      this.abortController = new AbortController();
      
      console.log('üîç Executing search with Claude Code SDK...');
      console.log('üìÅ Working directory:', sessionDir);
      
      // SDK API„Çí‰ΩøÁî®„Åó„Å¶Ê§úÁ¥¢„ÇíÂÆüË°å
      for await (const message of query({
        prompt,
        options: {
          abortController: this.abortController,
          maxTurns: 1,
          mcpServers: this.mcpServers,
          cwd: sessionDir,  // ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÊåáÂÆö
          permissionMode: 'bypassPermissions' as const
        }
      })) {
        messages.push(message);
        
        // „É™„Ç¢„É´„Çø„Ç§„É†„ÅßÈÄ≤Êçó„ÇíË°®Á§∫
        this.logSDKMessage(message);
      }

      // ÁµêÊûú„ÇíÊï¥ÂΩ¢
      let textResult = '';
      
      // result„É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâÁµêÊûú„ÇíÂèñÂæó
      const resultMessage = messages.find(m => m.type === 'result');
      if (resultMessage && (resultMessage as any).result) {
        textResult = (resultMessage as any).result;
      } else {
        // assistant„É°„ÉÉ„Çª„Éº„Ç∏„Åã„ÇâÁµêÊûú„ÇíÂèñÂæó
        const assistantMessage = messages.find(m => m.type === 'assistant');
        if (assistantMessage && (assistantMessage as any).message?.content) {
          const content = (assistantMessage as any).message.content;
          textResult = content.map((c: any) => c.text || '').join('\n');
        }
      }

      console.log('üìÑ Search Results from Claude Code SDK:');
      console.log('----------------------------------------');
      console.log(textResult || 'No results found');
      console.log('----------------------------------------');
      
      // ÁîüÊàê„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„ÇíÊ§úÂá∫
      const generatedFiles = this.findGeneratedFiles(sessionDir);
      if (generatedFiles.length > 0) {
        console.log('üìÅ Generated files:');
        generatedFiles.forEach(file => console.log(`   - ${file}`));
      }
      
      return {
        success: true,
        result: textResult || 'No results found',
        toolsUsed: ['web-search'],
        generatedFiles,
        sessionDir,
        timestamp: Date.now()
      };
    } catch (error) {
      console.error('‚ùå Search execution error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    } finally {
      this.abortController = null;
    }
  }

  /**
   * „Ç≥„Éº„ÉâÁîüÊàê„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeCodeGeneration(action: ActionRequest): Promise<ExecutionResult> {
    if (!action.parameters?.query) {
      return {
        success: false,
        error: 'Code generation prompt is required',
        timestamp: Date.now()
      };
    }

    try {
      const messages: SDKMessage[] = [];
      const prompt = `„Ç≥„Éº„Éâ„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ${action.parameters.query}\nÂøÖË¶Å„Å™„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê„Åó„ÄÅÊ©üËÉΩ„ÇíÂÆüË£Ö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
      
      this.abortController = new AbortController();
      
      for await (const message of query({
        prompt,
        options: {
          abortController: this.abortController,
          maxTurns: 3,
          mcpServers: this.mcpServers
        }
      })) {
        messages.push(message);
      }
      
      // ÁµêÊûú„ÇíÂèñÂæó
      let result = '';
      const resultMessage = messages.find(m => m.type === 'result');
      if (resultMessage && (resultMessage as any).result) {
        result = (resultMessage as any).result;
      }

      console.log('üíª Code Generation Results from Claude Code SDK:');
      console.log('----------------------------------------');
      console.log(result || 'Code generation completed');
      console.log('----------------------------------------');
      
      return {
        success: true,
        result: result || 'Code generation completed',
        toolsUsed: ['file-write', 'code-generation'],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    }
  }

  /**
   * „Éï„Ç°„Ç§„É´Êìç‰Ωú„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeFileOperation(action: ActionRequest): Promise<ExecutionResult> {
    try {
      const prompt = action.parameters?.content
        ? `Edit file ${action.parameters.filePath}: ${action.parameters.content}`
        : `Read and analyze file: ${action.parameters?.filePath}`;

      const messages: SDKMessage[] = [];
      this.abortController = new AbortController();
      
      for await (const message of query({
        prompt,
        options: {
          abortController: this.abortController,
          maxTurns: 1,
          mcpServers: this.mcpServers
        }
      })) {
        messages.push(message);
      }
      
      // ÁµêÊûú„ÇíÂèñÂæó
      let result = '';
      const resultMessage = messages.find(m => m.type === 'result');
      if (resultMessage && (resultMessage as any).result) {
        result = (resultMessage as any).result;
      }

      console.log('üìÅ File Operation Results from Claude Code SDK:');
      console.log('----------------------------------------');
      console.log(result || 'File operation completed');
      console.log('----------------------------------------');
      
      return {
        success: true,
        result: result || 'File operation completed',
        toolsUsed: ['file-read', 'file-write'],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    }
  }

  /**
   * „Ç≥„Éû„É≥„ÉâÂÆüË°å„Ç¢„ÇØ„Ç∑„Éß„É≥
   */
  private async executeCommand(action: ActionRequest): Promise<ExecutionResult> {
    if (!action.parameters?.command) {
      return {
        success: false,
        error: 'Command is required',
        timestamp: Date.now()
      };
    }

    try {
      const messages: SDKMessage[] = [];
      const prompt = `Ê¨°„ÅÆ„Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å„Åó„Å¶ÁµêÊûú„ÇíÂ†±Âëä„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ${action.parameters.command}`;
      
      this.abortController = new AbortController();
      
      for await (const message of query({
        prompt,
        options: {
          abortController: this.abortController,
          maxTurns: 1,
          mcpServers: this.mcpServers
        }
      })) {
        messages.push(message);
      }
      
      // ÁµêÊûú„ÇíÂèñÂæó
      let result = '';
      const resultMessage = messages.find(m => m.type === 'result');
      if (resultMessage && (resultMessage as any).result) {
        result = (resultMessage as any).result;
      }

      console.log('üñ•Ô∏è Command Execution Results from Claude Code SDK:');
      console.log('----------------------------------------');
      console.log(result || 'Command executed');
      console.log('----------------------------------------');
      
      return {
        success: true,
        result: result || 'Command executed',
        toolsUsed: ['command-execution'],
        timestamp: Date.now()
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        timestamp: Date.now()
      };
    }
  }

  /**
   * Slack„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeSlackAction(action: ActionRequest): Promise<ExecutionResult> {
    // TODO: Slack MCPÁµ±Âêà
    return {
      success: false,
      error: 'Slack integration not yet implemented',
      timestamp: Date.now()
    };
  }

  /**
   * GitHub„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeGitHubAction(action: ActionRequest): Promise<ExecutionResult> {
    // TODO: GitHub MCPÁµ±Âêà
    return {
      success: false,
      error: 'GitHub integration not yet implemented',
      timestamp: Date.now()
    };
  }

  /**
   * „Éñ„É©„Ç¶„Ç∂„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeBrowserAction(action: ActionRequest): Promise<ExecutionResult> {
    // TODO: Browser automationÁµ±Âêà
    return {
      success: false,
      error: 'Browser automation not yet implemented',
      timestamp: Date.now()
    };
  }

  /**
   * ÂæÖÊ©ü„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÂÆüË°å
   */
  private async executeWait(action: ActionRequest): Promise<ExecutionResult> {
    const duration = action.parameters?.query ? parseInt(action.parameters.query) : 5000;
    await new Promise(resolve => setTimeout(resolve, duration));
    
    return {
      success: true,
      result: `Waited for ${duration}ms`,
      timestamp: Date.now()
    };
  }


  /**
   * ÂÆüË°åÁµêÊûú„Çí„Éá„Éº„Çø„Éô„Éº„Çπ„Å´‰øùÂ≠ò
   */
  private async saveExecutionResult(action: ActionRequest, result: ExecutionResult): Promise<void> {
    try {
      // TODO: „Éá„Éº„Çø„Éô„Éº„Çπ„Çπ„Ç≠„Éº„Éû„Å´Âøú„Åò„Å¶ÂÆüË£Ö
      console.log('üíæ Saving execution result to database');
    } catch (error) {
      console.error('‚ùå Error saving execution result:', error);
    }
  }

  /**
   * MCP„Çµ„Éº„Éê„Éº„ÇíÂãïÁöÑ„Å´ËøΩÂä†
   */
  async addMCPServer(name: string, config: any): Promise<boolean> {
    try {
      this.mcpServers[name] = config;
      console.log(`üîå MCP server '${name}' added:`, config);
      return true;
    } catch (error) {
      console.error(`‚ùå Error adding MCP server '${name}':`, error);
      return false;
    }
  }
  
  /**
   * Âü∫Êú¨ÁöÑ„Å™MCP„Çµ„Éº„Éê„Éº„Çí„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
   */
  async setupDefaultMCPServers(): Promise<void> {
    try {
      // EXA MCP„Çµ„Éº„Éê„Éº„ÇíË®≠ÂÆö
      // EXA API„Ç≠„Éº„ÇíÂèñÂæóÔºàÊó¢„Å´ÁÑ°ÂäπÂåñÊ∏à„ÅøÔºâ
      // const encryptionService = (await import('./encryptionService')).EncryptionService;
      // EXA MCP„Çµ„Éº„Éê„Éº„ÅØÂâäÈô§ÔºàÈÅÖ„ÅÑ„Åü„ÇÅÔºâ
      console.log('‚ÑπÔ∏è EXA MCP server disabled for performance')
      
      console.log('‚úÖ MCP servers configuration completed');
      console.log('üìã Available MCP servers:', Object.keys(this.mcpServers));
    } catch (error) {
      console.error('‚ùå Error setting up MCP servers:', error);
    }
  }

  /**
   * ÁèæÂú®„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
   */
  getCurrentState() {
    return {
      isExecuting: this.isExecuting,
      queueSize: this.actionQueue.length,
      mcpServers: Object.keys(this.mcpServers)
    };
  }

  /**
   * 
   * „Çµ„Éº„Éê„Éº„ÅÆÂàùÊúüÂåñ
   */
  async initializeMCPServers(): Promise<void> {
    this.mcpServers = {};
    
    // ElevenLabs MCP„ÅÆË®≠ÂÆöÔºàÁí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆ„ÅøÊúâÂäπÔºâ
    const elevenLabsApiKey = process.env.ELEVENLABS_API_KEY;
    if (elevenLabsApiKey) {
      this.mcpServers.elevenlabs = {
        command: "uvx",
        args: ["elevenlabs-mcp"],
        env: {
          ELEVENLABS_API_KEY: elevenLabsApiKey
        }
      };
      console.log('‚úÖ ElevenLabs MCP server configured');
    } else {
      console.warn('‚ö†Ô∏è ElevenLabs API key not found. Set ELEVENLABS_API_KEY environment variable to enable ElevenLabs MCP.');
    }
    
    // Slack„Éà„Éº„ÇØ„É≥„ÅÆÁ¢∫Ë™ç
    try {
      const slackConfigPath = path.join(process.env.HOME || '', '.anicca', 'slack-config.json');
      if (fs.existsSync(slackConfigPath)) {
        const config = JSON.parse(fs.readFileSync(slackConfigPath, 'utf-8'));
        
        // Êñ∞ÂΩ¢Âºè„ÅÆMCPË®≠ÂÆö„ÇíË™≠„ÅøËæº„ÇÄ
        if (config.mcpServers?.slack?.env?.SLACK_BOT_TOKEN) {
          const encryption = new SimpleEncryption();
          const token = encryption.decrypt(config.mcpServers.slack.env.SLACK_BOT_TOKEN);
          
          this.mcpServers.slack = {
            command: "npx",
            args: ["-y", "@modelcontextprotocol/server-slack"],
            env: {
              SLACK_BOT_TOKEN: token,
              SLACK_TEAM_ID: config.mcpServers.slack.env.SLACK_TEAM_ID || ''
            }
          };
          
          console.log('‚úÖ Slack MCP server configured');
        }
        // ÊóßÂΩ¢Âºè„ÇÇ‰∏ÄÂøú„Çµ„Éù„Éº„ÉàÔºàÂæåÊñπ‰∫íÊèõÊÄßÔºâ
        else if (config.token) {
          const encryption = new SimpleEncryption();
          const token = encryption.decrypt(config.token);
          
          this.mcpServers.slack = {
            command: "npx",
            args: ["-y", "@modelcontextprotocol/server-slack"],
            env: {
              SLACK_BOT_TOKEN: token,
              SLACK_TEAM_ID: config.team?.id || ''
            }
          };
          
          console.log('‚úÖ Slack MCP server configured (legacy format)');
        }
      }
    } catch (error) {
      console.error('‚ùå Failed to initialize Slack MCP:', error);
    }
  }

  /**
   * Slack„Éà„Éº„ÇØ„É≥„ÇíË®≠ÂÆö
   */
  setSlackTokens(tokens: any): void {
    // Slack MCP„Çµ„Éº„Éê„Éº„ÅÆË®≠ÂÆö„ÇíÊõ¥Êñ∞
    if (tokens.bot_token) {
      this.mcpServers.slack = {
        command: "npx",
        args: ["-y", "@modelcontextprotocol/server-slack"],
        env: {
          SLACK_BOT_TOKEN: tokens.bot_token,
          SLACK_USER_TOKEN: tokens.user_token || '',
          SLACK_TEAM_ID: tokens.team_id || ''
        }
      };
      console.log('‚úÖ Slack tokens set for MCP');
    }
  }

  /**
   * MCP„Çµ„Éº„Éê„Éº„ÇíÂãïÁöÑ„Å´Êõ¥Êñ∞
   */
  async updateMCPServers(): Promise<void> {
    await this.initializeMCPServers();
    console.log('üîÑ MCP servers updated');
  }

  /**
   * Âà©Áî®ÂèØËÉΩ„Å™MCP„Çµ„Éº„Éê„Éº„ÅÆ„É™„Çπ„Éà„ÇíÂèñÂæó
   */
  getAvailableMCPServers(): string[] {
    const available: string[] = [];
    if (this.mcpServers.slack) {
      available.push('Slack');
    }
    if (this.mcpServers.elevenlabs) {
      available.push('ElevenLabs');
    }
    return available;
  }

  /**
   * ÂÆüË°åÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„ÉàÔºàÁ∑äÊÄ•Áî®Ôºâ
   */
  resetExecutionState(): void {
    console.log('üîÑ Resetting execution state');
    this.isExecuting = false;
    
    // ÂÆüË°å‰∏≠„ÅÆ„Éó„É≠„Çª„Çπ„Çí‰∏≠Êñ≠
    if (this.abortController && !this.abortController.signal.aborted) {
      this.abortController.abort();
      this.abortController = null;
    }
    
    // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Çí„ÇØ„É™„Ç¢
    if (this.executionTimeout) {
      clearTimeout(this.executionTimeout);
      this.executionTimeout = null;
    }
    
    this.actionQueue = [];
  }
}