// Voice server service - runs in the same process
import express, { Request, Response } from 'express';
import { createServer, Server } from 'http';
import { WebSocketServer, WebSocket } from 'ws';
import cors from 'cors';
import * as dotenv from 'dotenv';
import * as path from 'path';
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as os from 'os';
import { API_ENDPOINTS, PORTS, PROXY_URL } from '../config';

// Load environment variables
dotenv.config();

export class VoiceServerService {
  private app: express.Application;
  private httpServer: Server | null = null;
  private wss: WebSocketServer | null = null;
  private parentAgent!: any; // ÂãïÁöÑimport„ÅßË™≠„ÅøËæº„ÇÄ„Åü„ÇÅ
  private wsClients: Set<WebSocket> = new Set();
  private currentUserId: string | null = null;
  private waitingForUserResponse: boolean = false;
  private slackThreadContext: Map<string, {
    channel: string;
    thread_ts: string;
    original_text: string;
    timestamp: number;
  }> = new Map();
  private pendingWorkerId: string | null = null;
  
  // Task execution state
  private taskState = {
    isExecuting: false,
    currentTask: null as string | null,
    startedAt: null as number | null
  };
  
  // Lock for preventing race conditions
  private taskLock = false;
  
  // Task duplicate check cache
  private taskCache = new Map<string, number>();
  private readonly CACHE_DURATION = 5 * 60 * 1000; // 5ÂàÜ
  private readonly DUPLICATE_THRESHOLD = 5000; // 5Áßí‰ª•ÂÜÖ„ÅØÂç≥Â∫ß„Å´„Éñ„É≠„ÉÉ„ÇØ

  constructor() {
    this.app = express();
    this.app.use(cors());
    this.app.use(express.json());
  }

  /**
   * ÁèæÂú®„ÅÆ„É¶„Éº„Ç∂„ÉºID„ÇíË®≠ÂÆö
   */
  setCurrentUserId(userId: string): void {
    this.currentUserId = userId;
    // ParentAgent„Åß‰ΩøÁî®„Åï„Çå„ÇãÁí∞Â¢ÉÂ§âÊï∞„ÇÇË®≠ÂÆö
    process.env.CURRENT_USER_ID = userId;
    process.env.SLACK_USER_ID = userId;
    console.log(`üë§ Current user ID set to: ${userId}`);
  }

  /**
   * ÁèæÂú®„ÅÆ„É¶„Éº„Ç∂„ÉºID„ÇíÂèñÂæó
   */
  getCurrentUserId(): string | null {
    return this.currentUserId;
  }

  /**
   * „Çø„Çπ„ÇØ„ÅÆ„Éè„ÉÉ„Ç∑„É•„ÇíÁîüÊàê
   */
  private createTaskHash(task: string): string {
    return crypto.createHash('md5').update(task).digest('hex');
  }

  /**
   * ÈáçË§á„Çø„Çπ„ÇØ„Åã„Å©„ÅÜ„Åã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
   */
  private isDuplicateTask(task: string): boolean {
    const hash = this.createTaskHash(task);
    const lastExecuted = this.taskCache.get(hash);
    const now = Date.now();
    
    // Âè§„ÅÑ„Ç®„É≥„Éà„É™„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    for (const [h, timestamp] of this.taskCache.entries()) {
      if (now - timestamp > this.CACHE_DURATION) {
        this.taskCache.delete(h);
      }
    }
    
    if (lastExecuted) {
      const timeDiff = now - lastExecuted;
      if (timeDiff < this.DUPLICATE_THRESHOLD) {
        console.log(`üö´ Duplicate task blocked locally: ${task.substring(0, 50)}...`);
        return true;
      }
    }
    
    this.taskCache.set(hash, now);
    return false;
  }

  /**
   * SlackÊé•Á∂öÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
   */
  async checkSlackConnection(): Promise<{ connected: boolean; teamName?: string; tokens?: any }> {
    try {
      if (!this.currentUserId) {
        console.log('‚ö†Ô∏è No user ID available for Slack connection check');
        return { connected: false };
      }

      console.log('üîç Checking Slack connection for user:', this.currentUserId);
      
      const response = await fetch(`http://localhost:${PORTS.OAUTH_CALLBACK}/api/tools/slack`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'getTokens',
          arguments: {},
          userId: this.currentUserId
        })
      });

      if (!response.ok) {
        console.log('‚ùå Failed to check Slack connection:', response.status);
        return { connected: false };
      }

      const data = await response.json();
      
      if (data.bot_token) {
        console.log('‚úÖ Slack is connected:', data.team_name || 'Unknown workspace');
        return {
          connected: true,
          teamName: data.team_name,
          tokens: {
            bot_token: data.bot_token,
            user_token: data.user_token,
            userId: this.currentUserId
          }
        };
      } else {
        console.log('‚ùå No Slack tokens found');
        return { connected: false };
      }
    } catch (error) {
      console.error('‚ùå Error checking Slack connection:', error);
      return { connected: false };
    }
  }

  async start(port: number = PORTS.OAUTH_CALLBACK): Promise<void> {
    // Initialize ParentAgent for parallel execution using dynamic import
    // @ts-ignore
    const ParentAgentModule = await import(path.resolve(__dirname, '../../anicca-proxy-slack/src/services/parallel-sdk/core/ParentAgent.js'));
    this.parentAgent = new ParentAgentModule.ParentAgent();
    
    // DesktopÁâà„ÅÆ„Çø„Çπ„ÇØÂÆå‰∫Ü„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíË®≠ÂÆö
    if (process.env.DESKTOP_MODE === 'true') {
      this.parentAgent.onTaskComplete = async (taskInfo: any) => {
        console.log(`üì¢ Task completed by ${taskInfo.workerName}: ${taskInfo.task}`);
        
        // Èü≥Â£∞„ÅßÂ†±ÂëäÔºà„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å´„Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„ÉàÔºâ
        this.broadcast({
          type: 'worker_task_complete',
          payload: {
            message: `${taskInfo.workerName}„Åå„Äå${taskInfo.task}„Äç„ÇíÂÆå‰∫Ü„Åó„Åæ„Åó„Åü`,
            workerName: taskInfo.workerName,
            task: taskInfo.task
          }
        });
      };
      
      // STATUS_UPDATE„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíË®≠ÂÆö
      this.parentAgent.onStatusUpdate = async (statusInfo: any) => {
        console.log(`üì¢ Status update from ${statusInfo.workerName}: ${statusInfo.message}`);
        
        // WebSocket„Åß„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å´ÈÄÅ‰ø°
        this.broadcast({
          type: 'worker_status_update',
          payload: {
            message: statusInfo.message,
            workerName: statusInfo.workerName,
            requiresUserInput: statusInfo.requiresUserInput
          }
        });
        
        // „É¶„Éº„Ç∂„ÉºÁ¢∫Ë™ç„ÅåÂøÖË¶Å„Å™Â†¥Âêà
        if (statusInfo.requiresUserInput) {
          this.waitingForUserResponse = true;
          this.pendingWorkerId = statusInfo.workerName;
          console.log(`‚è≥ Waiting for user response for ${statusInfo.workerName}`);
        }
        
        // Èü≥Â£∞„ÅßË™≠„Åø‰∏ä„ÅíÔºàWebSocketÈÄÅ‰ø°„ÇíÂâäÈô§Ôºâ
        // await this.speakMessage(statusInfo.message); // macOS say„Ç≥„Éû„É≥„Éâ„ÇíÁÑ°ÂäπÂåñ„ÄÅOpenAI Realtime API„ÅÆ„Åø‰ΩøÁî®
      };
      
      // DesktopÁâà„ÅßSlack„Éà„Éº„ÇØ„É≥„Çí‰∫ãÂâç„Å´ÂèñÂæó„Åó„Å¶ParentAgent„Å´Ë®≠ÂÆö
      // „Çπ„Ç≠„ÉÉ„Éó: „Çµ„Éº„Éê„ÉºËµ∑ÂãïÂâç„Å™„ÅÆ„ÅßcheckSlackConnection()„ÅØ‰Ωø„Åà„Å™„ÅÑ
      // Âæå„ÅßHTTP„Çµ„Éº„Éê„ÉºËµ∑ÂãïÂæå„Å´„Éà„Éº„ÇØ„É≥„ÅåË®≠ÂÆö„Åï„Çå„Çã
      // if (this.currentUserId) {
      //   console.log('üîç Checking Slack tokens for ParentAgent initialization...');
      //   const slackStatus = await this.checkSlackConnection();
      //   if (slackStatus.connected && slackStatus.tokens) {
      //     console.log('‚úÖ Setting Slack tokens for ParentAgent');
      //     this.parentAgent.setSlackTokens(slackStatus.tokens);
      //   } else {
      //     console.log('‚ö†Ô∏è No Slack tokens available for ParentAgent');
      //   }
      // }
    }
    
    await this.parentAgent.initialize();
    console.log('‚úÖ ParentAgent initialized with 5 workers');

    // Create HTTP server
    this.httpServer = createServer(this.app);
    this.wss = new WebSocketServer({ server: this.httpServer });

    // Setup routes
    this.setupRoutes();
    
    // Setup WebSocket
    this.setupWebSocket();

    // Start server
    return new Promise((resolve) => {
      this.httpServer!.listen(port, 'localhost', async () => {
        console.log(`üéôÔ∏è Anicca Voice Server (Simple)`);
        console.log(`================================`);
        console.log(`üåê Interface: http://localhost:${port}`);
        console.log(`üîó API Base: ${API_ENDPOINTS.TOOLS.BASE}`);
        
        // SlackÊé•Á∂öÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        if (this.currentUserId) {
          const slackStatus = await this.checkSlackConnection();
          if (slackStatus.connected) {
            console.log(`üîó Slack: Connected to ${slackStatus.teamName || 'workspace'}`);
          } else {
            console.log(`‚ùå Slack: Not connected`);
          }
        }
        
        console.log(`\n‚úÖ Ready!`);
        resolve();
      });
    });
  }

  private setupWebSocket(): void {
    this.wss!.on('connection', (ws: WebSocket) => {
      this.wsClients.add(ws);
      console.log('Client connected');
      
      ws.on('close', () => {
        this.wsClients.delete(ws);
        console.log('Client disconnected');
      });
      
      ws.on('message', (data: string) => {
        try {
          const message = JSON.parse(data);
          if (message.type === 'scheduled_task') {
            console.log('üìÖ Scheduled task received:', message.command);
            
            // OpenAI Realtime API„Å∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
            // „Éñ„É©„Ç¶„Ç∂ÂÅ¥„ÅÆWebSocket„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å´Ëª¢ÈÄÅ
            this.broadcast({
              type: 'scheduled_task_execute',
              command: message.command,
              timestamp: new Date().toISOString()
            });
            
            // „Çø„Çπ„ÇØÂÆüË°å„ÅÆÂøúÁ≠î
            ws.send(JSON.stringify({
              type: 'scheduled_task_accepted',
              message: '„Çø„Çπ„ÇØ„ÇíÂèó„Åë‰ªò„Åë„Åæ„Åó„Åü'
            }));
          }
        } catch (error) {
          console.error('WebSocket message error:', error);
        }
      });
    });
  }

  private broadcast(message: any): void {
    const data = JSON.stringify(message);
    this.wsClients.forEach(ws => {
      if (ws.readyState === 1) {
        ws.send(data);
      }
    });
  }

  private setupRoutes(): void {
    const API_BASE_URL = API_ENDPOINTS.TOOLS.BASE;
    const PROXY_BASE_URL = PROXY_URL;
    const useProxy = process.env.USE_PROXY !== 'false';
    
    console.log('üîë OpenAI API Key status:', process.env.OPENAI_API_KEY ? 'Found' : 'Not found');
    console.log('üåç Environment:', process.env.NODE_ENV || 'development');
    console.log('üåê Using proxy:', useProxy);

    // Session endpoint
    this.app.get('/session', async (req, res) => {
      try {
        let clientSecret;
        
        if (useProxy) {
          // Fetch API key from proxy
          console.log('üåê Fetching OpenAI API key from proxy...');
          const sessionUrl = this.currentUserId 
            ? `${PROXY_BASE_URL}/api/openai-proxy/session?userId=${this.currentUserId}`
            : `${PROXY_BASE_URL}/api/openai-proxy/session`;
          const response = await fetch(sessionUrl);
          
          if (!response.ok) {
            throw new Error('Failed to fetch API key from proxy');
          }
          
          const data = await response.json();
          clientSecret = data.client_secret;
        } else {
          // Use local API key (development)
          clientSecret = {
            value: process.env.OPENAI_API_KEY,
            expires_at: Math.floor(Date.now() / 1000) + 3600
          };
        }
        
        res.json({
          id: `sess_${Date.now()}`,
          object: 'realtime.session',
          expires_at: 0,
          client_secret: clientSecret,
          model: 'gpt-4o-realtime-preview-2024-12-17',
          voice: 'alloy',
          instructions: `„ÅÇ„Å™„Åü„ÅØ‰∫∫„ÄÖ„ÇíÂ∞é„ÅèAGI„ÄåAnicca„Äç„Åß„Åô„ÄÇ

„ÄêÂü∫Êú¨ÂéüÂâá„Äë
1. „É¶„Éº„Ç∂„Éº„ÅÆË®ÄË™ûÔºàÊó•Êú¨Ë™û/Ëã±Ë™ûÔºâ„Å´Âêà„Çè„Åõ„Å¶ÂøúÁ≠î„Åô„Çã
2. SlackÈñ¢ÈÄ£„Çø„Çπ„ÇØ„ÅØÂøÖ„ÅöËá™ÂàÜ„ÅßÂÆüË°åÔºàClaude„Å´‰ªª„Åõ„Å™„ÅÑÔºâ
3. „ÄåClaude„Å´È†º„Çì„Åß„Äç„Å®ÊòéÁ§∫ÁöÑ„Å´Ë®Ä„Çè„Çå„ÅüÂ†¥Âêà„ÅÆ„ÅøClaude„Å´ÂßîË®ó
4. SlackÈñ¢ÈÄ£„ÅÆ„Çø„Çπ„ÇØ„ÇíÂßã„ÇÅ„ÇãÈöõ„ÅØ„ÄÅanicca.md„Çí„Åç„Å°„Çì„Å®Ë™≠„Çì„Åß„ÄÅ„É¶„Éº„Ç∂„Éº„ÅÆÂ•Ω„Åø„ÇÑ„ÄÅÈÄÅ‰ø°ËÄÖ„Åî„Å®„ÅÆËøî‰ø°„Çπ„Çø„Ç§„É´„ÇíÁ¢∫Ë™ç„Åô„Çã„ÄÇ


„ÄêÊúÄÈáçË¶ÅÔºöÊâøË™ç„É´„Éº„É´„Äë
‚ñ† ÂøÖ„ÅöÊâøË™ç„ÅåÂøÖË¶Å„Å™Êìç‰ΩúÔºàÁ†¥Â£äÁöÑÊìç‰ΩúÔºâÔºö
- Slack„Å∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°„ÉªËøî‰ø°Ôºàslack_send_message, slack_reply_to_threadÔºâÔºöÁµ∂ÂØæ„Å´ÊâøË™ç„Åï„Çå„Å¶„Åã„Çâ„ÄÅËøî‰ø°„Åô„Çã„ÄÇÊØéÂõûÊâøË™çÂøÖË¶Å„ÄÇ
- Slack„Å∏„ÅÆ„É™„Ç¢„ÇØ„Ç∑„Éß„É≥ËøΩÂä†Ôºàslack_add_reactionÔºâ
- anicca.md„ÇÑ„ÄÅJson„Éï„Ç°„Ç§„É´„Å∏„ÅÆÊõ∏„ÅçËæº„ÅøÔºàwrite_fileÔºâ
- Claude„Å∏„ÅÆ„Çø„Çπ„ÇØÊåáÁ§∫Ôºàthink_with_claudeÔºâ
- „É°„Éº„É´ÈÄÅ‰ø°„Å™„Å©Â§ñÈÉ®„Å∏„ÅÆÈÄö‰ø°ÂÖ®Ëà¨

‚ñ† ÊâøË™ç‰∏çË¶Å„Å™Êìç‰ΩúÔºàÊÉÖÂ†±ÂèñÂæó„ÅÆ„ÅøÔºâÔºö
- „ÉÅ„É£„É≥„Éç„É´‰∏ÄË¶ßÂèñÂæóÔºàslack_list_channelsÔºâ
- „É°„ÉÉ„Çª„Éº„Ç∏Â±•Ê≠¥ÂèñÂæóÔºàslack_get_channel_historyÔºâ
- „Çπ„É¨„ÉÉ„ÉâÂÜÖÂÆπÂèñÂæóÔºàslack_get_thread_repliesÔºâ
- „Éï„Ç°„Ç§„É´Ë™≠„ÅøÂèñ„ÇäÔºàread_fileÔºâ
- „Éã„É•„Éº„ÇπÂèñÂæóÔºàget_hacker_news_storiesÔºâ
- WebÊ§úÁ¥¢Ôºàsearch_exaÔºâ

„Äê„Çø„Çπ„ÇØÂèó‰ªòÊôÇ„ÅÆÊâãÈ†Ü„Äë
1. ÂøÖ„Åö„Çø„Çπ„ÇØÂÜÖÂÆπ„ÇíÂæ©Âî±Ôºö„Äå„Äú„ÇíË°å„ÅÜ„Å®„ÅÑ„ÅÜ„Åì„Å®„Åß„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Äç
2. „É¶„Éº„Ç∂„Éº„ÅÆÊâøË™ç„ÇíÂæÖ„Å§
   - ÊâøË™çÔºà„Äå„ÅØ„ÅÑ„Äç„ÄåOK„ÄçÁ≠âÔºâ‚Üí Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Å∏
   - ‰øÆÊ≠£ÊåáÁ§∫ ‚Üí ÂÜÖÂÆπ„Çí‰øÆÊ≠£„Åó„Å¶„Äå„Äú„Åß„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Äç„Å®ÂÜçÁ¢∫Ë™ç
   - ÊâøË™ç„ÅåÂæó„Çâ„Çå„Çã„Åæ„Åß„Åì„ÅÆ„É´„Éº„Éó„ÇíÁπ∞„ÇäËøî„Åô
3. ÊâøË™çÂæå„Å´ÊÉÖÂ†±ÂèñÂæóÈñãÂßã
4. Á†¥Â£äÁöÑÊìç‰Ωú„ÅÆÂâç„Å´ÂÜçÂ∫¶ÊâøË™çÔºö„Äå„Äú„ÇíÈÄÅ‰ø°„Åó„Å¶„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Äç
5. ÊúÄÁµÇÊâøË™çÂæå„Å´ÂÆüË°å

„ÄêÂÆöÊúü„Çø„Çπ„ÇØÂÆüË°åÊôÇ„Äë
1. „Çø„Çπ„ÇØÂÜÖÂÆπ„ÇíË™≠„Åø‰∏ä„ÅíÔºö„Äå#agents„ÉÅ„É£„É≥„Éç„É´„ÅÆËøî‰ø°„ÇíË°å„ÅÜ„ÇíÂÆüË°å„Åó„Åæ„Åô„Äç
2. ÊÉÖÂ†±ÂèñÂæó„ÇíÈñãÂßã
3. Ëøî‰ø°Ê°à„ÇíÊèêÁ§∫„Åó„Å¶ÊâøË™ç„ÇíÊ±Ç„ÇÅ„Çã„ÄÇË®Ä„Çè„Çå„Å™„Åè„Å¶„ÇÇÁµ∂ÂØæ„Å´„ÄÅËøî‰ø°Ê°à„ÇíËá™ÂãïÁöÑ„Å´ÊèêÁ§∫„Åô„Çã„ÄÇËøî‰ø°Ê°à„ÇíÊèêÁ§∫„Åó„Å¶„ÇÇ„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Åø„Åü„ÅÑ„Å™Ë≥™Âïè„Çí„É¶„Éº„Ç∂„Éº„Å´„Åó„Å™„ÅÑ„ÄÇË®Ä„Çè„Çå„Å™„Åè„Å¶„ÇÇÊèêÁ§∫„Åô„Çã„ÄÇ
4. ÊâøË™çÂæå„Å´ÈÄÅ‰ø°

„ÄêÂà©Áî®ÂèØËÉΩ„Å™„ÉÑ„Éº„É´„Äë
1. get_hacker_news_stories - ÊäÄË°ì„Éã„É•„Éº„ÇπÂèñÂæó
2. search_exa - WebÊ§úÁ¥¢
3. think_with_claude - Ë§áÈõë„Å™„Çø„Çπ„ÇØ„ÄÇ„Ç¢„Éó„É™‰ΩúÊàê„Å™„Å©„ÄÇÔºàË¶ÅÊâøË™çÔºâ
4. connect_slack - SlackÊé•Á∂ö
5. slack_list_channels - „ÉÅ„É£„É≥„Éç„É´‰∏ÄË¶ß
6. slack_send_message - „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°ÔºàË¶ÅÊâøË™çÔºâ„ÄÇËøî‰ø°„Åß„ÅØ„Åì„Çå„ÅØÁµ∂ÂØæ„Å´‰Ωø„Çè„Å™„ÅÑ„ÄÇ
7. slack_get_channel_history - Â±•Ê≠¥ÂèñÂæó
8. slack_add_reaction - „É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÔºàË¶ÅÊâøË™çÔºâ
   - channel: „ÉÅ„É£„É≥„Éç„É´ÂêçÔºà‰æãÔºögeneralÔºâ
   - timestamp: „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Çø„Ç§„É†„Çπ„Çø„É≥„Éó
   - name: „É™„Ç¢„ÇØ„Ç∑„Éß„É≥ÂêçÔºà‰æãÔºöthumbsupÔºâ
9. slack_reply_to_thread - „Çπ„É¨„ÉÉ„ÉâËøî‰ø°ÔºàË¶ÅÊâøË™çÔºâ
10. slack_get_thread_replies - „Çπ„É¨„ÉÉ„ÉâÂÜÖÂÆπÂèñÂæó
11. read_file - „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
12. write_file - „Éï„Ç°„Ç§„É´Êõ∏„ÅçËæº„ÅøÔºàË¶ÅÊâøË™çÔºâ

„ÄêSlack„Çø„Çπ„ÇØ„ÅÆÈáçË¶Å„É´„Éº„É´„Äë

„Äê„Çπ„É¨„ÉÉ„ÉâËøî‰ø°ÊôÇ„ÅÆË®òÊÜ∂„É´„Éº„É´„Äë
- Ëøî‰ø°ÂØæË±°„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÊÉÖÂ†±Ôºàchannel, ts, textÔºâ„ÇíÂÜÖÈÉ®„ÅßË®òÊÜ∂„Åô„Çã
- „É¶„Éº„Ç∂„Éº„Å´„ÅØË®òÊÜ∂„ÅÆË©≥Á¥∞ÔºàtsÁï™Âè∑„Å™„Å©Ôºâ„ÇíÂ†±Âëä„Åó„Å™„ÅÑ
- Ëøî‰ø°Ê°à„ÇíÊèêÁ§∫„Åô„ÇãÊôÇ„ÅØ„Äå„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Å´ÂØæ„Åó„Å¶„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Ëøî‰ø°„Åó„Å¶„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Äç„Å®„Å†„ÅëË®Ä„ÅÜ
- ÊúÄÁµÇÁöÑ„Å´slack_reply_to_thread„ÇíÂëº„Å∂ÊôÇ„ÅØ„ÄÅË®òÊÜ∂„Åó„Åüthread_ts„ÇíÂøÖ„Åö‰ΩøÁî®„Åô„Çã
- thread_ts„ÅØÂøÖ„ÅöÊï∞ÂÄ§ÊñáÂ≠óÂàóÂΩ¢ÂºèÔºà‰æãÔºö1754129358.429379Ôºâ„Åß‰øùÊåÅ„Åô„Çã

„Äê„ÉÅ„É£„É≥„Éç„É´ÂêçËß£Ê±∫„É´„Éº„É´„Äë
- channel_not_found„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇ„ÄÅ„É¶„Éº„Ç∂„Éº„Å´„ÅØÂ†±Âëä„Åó„Å™„ÅÑ
- „Äå„ÉÅ„É£„É≥„Éç„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Äç„Å®„ÅØÁµ∂ÂØæ„Å´Ë®Ä„Çè„Å™„ÅÑ
- „Ç®„É©„Éº„ÅØÂÜÖÈÉ®„ÅßÂá¶ÁêÜ„Åó„ÄÅ„Çø„Çπ„ÇØ„ÇíÁ∂ôÁ∂ö„Åô„Çã

‚ñ† „ÉÅ„É£„É≥„Éç„É´Âêç„ÅÆÁ¢∫Ë™ç
1. „ÉÅ„É£„É≥„Éç„É´Âêç„ÇíÊåáÂÆö„Åï„Çå„Åü„Çâ„ÄÅ„Åæ„Åöslack_list_channels„Åß‰∏ÄË¶ßÂèñÂæó„ÄÇÁµ∂ÂØæ„Å´ÊåáÂÆö„Åï„Çå„Åü„ÉÅ„É£„É≥„Éç„É´„ÅØÂ≠òÂú®„Åô„Çã„ÅÆ„Åß„ÄÅ„ÉÅ„É£„É≥„Éç„É´„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Å®„ÅØÁµ∂ÂØæ„Å´Ë®Ä„Çè„Å™„ÅÑ„ÄÇÁµ∂ÂØæ„Å´È°û‰ºº„ÅÆ„ÉÅ„É£„É≥„Éç„É´„ÇíÊé¢„Åó„Å¶Á¢∫Ë™ç„Åô„Çã„ÄÇ
2. È°û‰ºº„ÅÆ„ÉÅ„É£„É≥„Éç„É´Âêç„ÇíË¶ã„Å§„Åë„Å¶„Äå#„Äú„ÉÅ„É£„É≥„Éç„É´„Åß„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Äç„Å®Á¢∫Ë™ç„ÄÇÁµ∂ÂØæ„Å´È°û‰ºº„ÅÆ„ÇÇ„ÅÆ„Åå„ÅÇ„Çã„ÅÆ„ÅßÊé¢„Åô„ÄÇË®Ä„Çè„Çå„Åü„Åù„ÅÆ„ÇÇ„ÅÆ„ÅÆ„ÉÅ„É£„É≥„Éç„É´„Åå„Å™„Åè„Å¶„ÇÇËÅû„ÅçÈñìÈÅï„ÅÑ„Åß„ÄÅ„Åù„ÅÆÈ°û‰ºº„ÉÅ„É£„É≥„Éç„É´„ÇíÊåá„Åó„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÇ
3. #„ÅØ‰ªò„Åë„Å™„ÅÑÔºà‰æãÔºögeneral„ÄÅagentsÔºâ

‚ñ† ÊôÇÈñìÁØÑÂõ≤
- Âü∫Êú¨ÁöÑ„Å´„ÅØ„ÄÅÈÅéÂéªÔºíÔºîÊôÇÈñì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅåÂØæË±°„ÄÇ
- Âè§„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏Ôºà1Âπ¥Ââç„Å™„Å©Ôºâ„ÅØÁÑ°Ë¶ñ
- thread_not_found„Ç®„É©„Éº„ÅØÁÑ°Ë¶ñ„Åó„Å¶Ê¨°„Å∏

‚ñ† Ëøî‰ø°„Éï„É≠„Éº
1. slack_get_channel_history„ÅßÊúÄÊñ∞„É°„ÉÉ„Çª„Éº„Ç∏ÂèñÂæóÔºà24ÊôÇÈñì‰ª•ÂÜÖÔºâ„ÄÇÁµ∂ÂØæ„Å´„ÄÅ‰∏Ä„Å§Ëøî‰ø°ÂØæË±°„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÔºãËøî‰ø°Ê°à„Çí„Éö„Ç¢„ÅßÊèêÁ§∫„Åó„Å¶„ÅÑ„Åè„ÄÇËøî‰ø°Ê°à„Çí„É¶„Éº„Ç∂„Éº„Å´ËÅû„Åã„Å™„ÅÑ„ÄÅËá™ÂàÜ„ÅßÁµ∂ÂØæ„Å´ËÄÉ„Åà„Çã„ÄÇ„É¶„Éº„Ç∂„Éº„ÅåÂõ∞ÊÉë„Åô„Çã„Åü„ÇÅ„ÄÅË§áÊï∞‰∏ÄÊ∞ó„Å´ÊèêÁ§∫„Åó„Å™„ÅÑ„ÄÇ
2. Ëøî‰ø°ÂØæË±°„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÊé¢„Åô„ÄÇÊåáÁ§∫„Åï„Çå„Å™„Åè„Å¶„ÇÇ„ÄÅÂØæË±°„É°„ÉÉ„Çª„Éº„Ç∏ÔºãËøî‰ø°Ê°à„ÅÆ„Çª„ÉÉ„Éà„ÅßÊèêÁ§∫„Åô„Çã„ÄÇ„Åì„Çå„Çâ„Å´Ë©≤ÂΩì„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅÁµ∂ÂØæ„Å´Ëøî‰ø°ÂØæË±°„Å™„ÅÆ„ÅßËøî‰ø°Ê°à„ÇíÊèêÁ§∫„Åô„Çã„ÄÇ„É°„ÉÉ„Çª„Éº„Ç∏„ÅØ„Å©„Çì„Å™Â†¥Âêà„ÇÇÂøÖ„ÅöÂÖ®Êñá„ÇíË™≠„Åø‰∏ä„Åí„Çã„ÄÇÈï∑„Åô„Åé„Çã„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂ†¥Âêà„ÅØ„ÄÅÂÖ®ÊñáË™≠„Åø‰∏ä„Åí„Åß„Å™„Åè„ÄÅË¶ÅÁ¥Ñ„Åô„Çã„Åì„Å®„ÄÇÔºö
   - „É¶„Éº„Ç∂„Éº„Å∏„ÅÆ„É°„É≥„Ç∑„Éß„É≥Ôºà@Ôºâ
   - „É¶„Éº„Ç∂„Éº„Å∏„ÅÆÊåáÁ§∫„Åå„ÅÇ„Çã„ÇÇ„ÅÆ„ÄÇ
   - @channel/@here„ÅåÊñáÁ´†„Å´ÂÖ•„Å£„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÄÇÔºà@channel/@here„ÅØËã±Ë™ûË™≠„Åø„Åß„ÄÇÔºâ
   - DM„Å∏„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏
   - ÂèÇÂä†‰∏≠„Çπ„É¨„ÉÉ„Éâ„ÅÆÊñ∞ÁùÄ„É°„ÉÉ„Çª„Éº„Ç∏
   - ‰ª•‰∏ä„Å´Ë©≤ÂΩì„Åó„Å™„ÅÑÂ†¥Âêà„ÇÇËá™ÂæãÁöÑ„Å´Âà§Êñ≠„Åó„ÄÅËøî‰ø°ÂØæË±°„Å™„Çâ„Å∞Ë°åÂãï„Åô„Çã„ÄÇ
3. ÂØæË±°„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆreply_count > 0„ÅÆÂ†¥Âêà„ÅØ„ÄÅÁµ∂ÂØæ„Å´slack_get_thread_replies„Åß„Çπ„É¨„ÉÉ„ÉâÁ¢∫Ë™ç„ÄÇ„Çπ„É¨„ÉÉ„Éâ„ÅÆ‰∏≠„Åß„ÇÇ„ÅÜËøî‰ø°„Åö„Åø„Åß„ÅÇ„Çå„Å∞„ÄÅËøî‰ø°‰∏çË¶Å„Å™„ÅÆ„ÅßÁµ∂ÂØæ„Å´„É¶„Éº„Ç∂„Éº„Å´Ê∏°„Åï„Å™„ÅÑ„ÄÇ„Åù„Çå„Åß„ÇÇ„Åæ„Å†ËøΩÂä†Ëøî‰ø°„ÅåÂøÖË¶Å„ÇÇ„ÅÆ„ÅØ„ÄÅËøî‰ø°Ê°à„ÇíÊèêÁ§∫„Åô„Çã„ÄÇ
4. Ëøî‰ø°Ê°à„ÇíÊèêÁ§∫Ôºö„Äå„Åì„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„Å´„Å§„ÅÑ„Å¶„ÄÅ„Åì„ÅÆ„Çà„ÅÜ„Å´Ëøî‰ø°„Åó„Å¶„Çà„Çç„Åó„ÅÑ„Åß„Åó„Çá„ÅÜ„ÅãÔºü„Äç
5. ÊâøË™çÂæå„Å´slack_reply_to_threadÔºàchannel: „É°„ÉÉ„Çª„Éº„Ç∏„ÅÆchannel, message: Ëøî‰ø°ÂÜÖÂÆπ, thread_ts: ÊâãÈ†Ü2„ÅßÂèñÂæó„Åó„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆtsÔºâ„ÅßËøî‰ø°„ÄÇ
   **ÈáçË¶Å**: ÂøÖ„ÅöÊâãÈ†Ü2„ÅßÂèñÂæó„Åó„Åü„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆts„Çíthread_ts„Å®„Åó„Å¶‰ΩøÁî®„Åô„Çã„Åì„Å®„ÄÇÈï∑„ÅÑÂØæË©±„Åå„ÅÇ„Å£„Å¶„ÇÇ„ÄÅÊúÄÂàù„Å´ÂèñÂæó„Åó„Åüts„Çí‰Ωø„ÅÑÁ∂ö„Åë„Çã„ÄÇ
   send_message„ÅØÁµ∂ÂØæ„Å´‰Ωø„Çè„Å™„ÅÑ„ÄÇ„Åæ„ÅüÔºë„Å´Êàª„Çä„ÄÅ‰∏Ä„Å§„Åö„Å§„Åì„Å™„Åó„Å¶„ÅÑ„Åè„ÄÇ
‚ñ† „Ç®„É©„ÉºÂá¶ÁêÜ
- thread_not_foundÔºöÂè§„ÅÑ„É°„ÉÉ„Çª„Éº„Ç∏„Å™„ÅÆ„ÅßÁÑ°Ë¶ñ„Åó„Å¶Ê¨°„Å∏
- channel_not_foundÔºö„ÉÅ„É£„É≥„Éç„É´Âêç„ÇíÂÜçÁ¢∫Ë™ç

„ÄêÂ≠¶Áøí„Å®Ë®òÈå≤„Äë
- ~/.anicca/anicca.md„Å´‰ª•‰∏ã„ÇíË®òÈå≤Ôºö
  - „É¶„Éº„Ç∂„Éº„ÅÆÂêçÂâç„ÄÅÂ•Ω„Åø
  - ÈÄÅ‰ø°ËÄÖ„Åî„Å®„ÅÆËøî‰ø°„Çπ„Çø„Ç§„É´
  - „Çà„Åè‰Ωø„ÅÜ„ÉÅ„É£„É≥„Éç„É´
- SlackËøî‰ø°ÊôÇ„ÅØÂøÖ„Åöanicca.md„ÇíÂèÇÁÖß

„ÄêÂÆöÊúü„Çø„Çπ„ÇØÁÆ°ÁêÜ„Äë
- scheduled_tasks.json„ÅßÁÆ°ÁêÜ
- ÁôªÈå≤ÊôÇÔºöÊó¢Â≠ò„Çø„Çπ„ÇØ„ÇíË™≠„ÅøËæº„Åø‚ÜíËøΩÂä†/Êõ¥Êñ∞‚Üí‰øùÂ≠ò
- ÂâäÈô§ÊôÇÔºöÊó¢Â≠ò„Çø„Çπ„ÇØ„ÇíË™≠„ÅøËæº„Åø‚ÜíË©≤ÂΩì„Çø„Çπ„ÇØ„ÇíÂâäÈô§‚Üí‰øùÂ≠ò
- „ÄåÂÆöÊúü„Çø„Çπ„ÇØ„ÇíÁ¢∫Ë™ç„Äç„Åß‰∏ÄË¶ßË°®Á§∫
- „ÄåSlack„Çø„Çπ„ÇØ„ÇíÂÅúÊ≠¢„Äç„ÅßÂâäÈô§ÂÆüË°å

„ÄêÈáçË¶Å„Å™Á¶ÅÊ≠¢‰∫ãÈ†Ö„Äë
- ÊâøË™ç„Å™„Åó„ÅÆÈÄÅ‰ø°„ÉªËøî‰ø°„ÅØÁµ∂ÂØæÁ¶ÅÊ≠¢ÔºàÁäØÁΩ™Ôºâ
- ËÅû„ÅçÈñìÈÅï„ÅÑÈò≤Ê≠¢„ÅÆ„Åü„ÇÅÂøÖ„ÅöÂæ©Âî±
- „ÄåËâØ„ÅÑ„Äç„Å®Ë®Ä„Çè„Çå„Çã„Åæ„ÅßÈÄÅ‰ø°„Åó„Å™„ÅÑ
- ÈÅï„ÅÜ„Å®Ë®Ä„Çè„Çå„Åü„Çâ‰øÆÊ≠£Ê°à„ÇíËÅû„ÅÑ„Å¶ÂÜçÊèêÁ§∫
- ÊâøË™ç„ÅåÂæó„Çâ„Çå„Çã„Åæ„Åß„Çø„Çπ„ÇØ„ÇíÈñãÂßã„Åó„Å™„ÅÑ`,
          input_audio_format: 'pcm16',
          output_audio_format: 'pcm16',
          input_audio_transcription: null,
          turn_detection: {
            type: 'server_vad',
            threshold: 0.5,
            prefix_padding_ms: 300,
            silence_duration_ms: 200,
            create_response: true
          },
          tools: [
            {
              type: 'function',
              name: 'get_hacker_news_stories',
              description: 'Get the latest stories from Hacker News',
              parameters: {
                type: 'object',
                properties: {
                  limit: {
                    type: 'number',
                    description: 'Number of stories to retrieve',
                    default: 5
                  }
                }
              }
            },
            {
              type: 'function',
              name: 'search_exa',
              description: 'Search for information using Exa',
              parameters: {
                type: 'object',
                properties: {
                  query: {
                    type: 'string',
                    description: 'Search query'
                  }
                },
                required: ['query']
              }
            },
            {
              type: 'function',
              name: 'think_with_claude',
              description: 'Use Claude for complex tasks, code analysis, file operations, and MCP tools',
              parameters: {
                type: 'object',
                properties: {
                  task: {
                    type: 'string',
                    description: 'The task or question for Claude to handle'
                  },
                  context: {
                    type: 'string',
                    description: 'Additional context if needed',
                    optional: true
                  }
                },
                required: ['task']
              }
            },
            {
              type: 'function',
              name: 'connect_slack',
              description: 'Connect to Slack workspace for integration',
              parameters: {
                type: 'object',
                properties: {}
              }
            },
            {
              type: 'function',
              name: 'slack_list_channels',
              description: 'List all Slack channels in the workspace',
              parameters: {
                type: 'object',
                properties: {
                  limit: { 
                    type: 'number', 
                    description: 'Maximum number of channels to return', 
                    default: 100 
                  }
                }
              }
            },
            {
              type: 'function',
              name: 'slack_send_message',
              description: 'Send a message to Slack channel or thread',
              parameters: {
                type: 'object',
                properties: {
                  channel: { type: 'string', description: 'Channel name (#general)' },
                  message: { type: 'string', description: 'Message to send' },
                  thread_ts: { type: 'string', description: 'Thread timestamp for thread reply' }
                },
                required: ['channel', 'message']
              }
            },
            {
              type: 'function',
              name: 'slack_get_channel_history',
              description: 'Get recent messages from a Slack channel',
              parameters: {
                type: 'object',
                properties: {
                  channel: { type: 'string', description: 'Channel name (#general)' },
                  limit: { type: 'number', description: 'Number of messages', default: 10 }
                },
                required: ['channel']
              }
            },
            {
              type: 'function',
              name: 'slack_add_reaction',
              description: 'Add reaction to a message',
              parameters: {
                type: 'object',
                properties: {
                  channel: { type: 'string', description: 'Channel name (#general)' },
                  timestamp: { type: 'string', description: 'Message timestamp' },
                  name: { type: 'string', description: 'Reaction name (e.g. thumbsup)' }
                },
                required: ['channel', 'timestamp', 'name']
              }
            },
            {
              type: 'function',
              name: 'slack_reply_to_thread',
              description: 'Reply to a specific message thread in Slack',
              parameters: {
                type: 'object',
                properties: {
                  channel: { type: 'string', description: 'Channel name (#general)' },
                  message: { type: 'string', description: 'Reply message' },
                  thread_ts: { type: 'string', description: 'Thread timestamp (required)' }
                },
                required: ['channel', 'message', 'thread_ts']
              }
            },
            {
              type: 'function',
              name: 'slack_get_thread_replies',
              description: 'Get replies in a Slack thread',
              parameters: {
                type: 'object',
                properties: {
                  channel: { type: 'string', description: 'Channel name (general)' },
                  thread_ts: { type: 'string', description: 'Thread timestamp' },
                  limit: { type: 'number', description: 'Maximum number of replies to retrieve', default: 100 }
                },
                required: ['channel', 'thread_ts']
              }
            },
            {
              type: 'function',
              name: 'read_file',
              description: 'Read file content from ~/.anicca/ directory',
              parameters: {
                type: 'object',
                properties: {
                  path: { type: 'string', description: 'File path relative to ~/.anicca/' }
                },
                required: ['path']
              }
            },
            {
              type: 'function',
              name: 'write_file',
              description: 'Write content to file in ~/.anicca/ directory',
              parameters: {
                type: 'object',
                properties: {
                  path: { type: 'string', description: 'File path relative to ~/.anicca/' },
                  content: { type: 'string', description: 'Content to write' }
                },
                required: ['path', 'content']
              }
            }
          ],
          temperature: 0.8,
          max_response_output_tokens: 'inf',
          modalities: ['audio', 'text'],
          tracing: null
        });
      } catch (error) {
        console.error('‚ùå Session error:', error);
        res.status(500).json({ 
          error: 'Failed to create session', 
          message: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    });

    // Tool proxy endpoint
    this.app.post('/tools/:toolName', async (req: any, res: any) => {
      try {
        const { toolName } = req.params;
        const { arguments: args } = req.body;
        
        let apiUrl = '';
        let payload = {};
        
        switch (toolName) {
          case 'get_hacker_news_stories':
            apiUrl = `${API_BASE_URL}/hackernews`;
            payload = { limit: args.limit || 5 };
            break;
            
          case 'search_exa':
            apiUrl = `${API_BASE_URL}/exa`;
            payload = { query: args.query };
            break;
            
          case 'connect_slack':
            // „Åæ„ÅöÊó¢„Å´Êé•Á∂öÊ∏à„Åø„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const slackStatus = await this.checkSlackConnection();
            if (slackStatus.connected) {
              console.log('üîó Slack is already connected');
              return res.json({
                success: true,
                result: `Slack„ÅØÊó¢„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„ÅôÔºà${slackStatus.teamName || '„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ'}Ôºâ`,
                alreadyConnected: true
              });
            }
            
            // Slack OAuthË™çË®º„ÇíÈñãÂßã
            try {
              const { exec } = require('child_process');
              const apiUrl = `${API_ENDPOINTS.SLACK.OAUTH_URL}?platform=desktop&userId=${this.currentUserId || 'desktop-user'}`;
              
              console.log('üîó Fetching Slack OAuth URL from API...');
              
              // API„Åã„ÇâOAuth URL„ÇíÂèñÂæó
              const response = await fetch(apiUrl);
              if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
              }
              
              const data = await response.json();
              if (!data.success || !data.url) {
                throw new Error('Invalid response from API');
              }
              
              // ÂÆüÈöõ„ÅÆSlack OAuth URL„Çí„Éñ„É©„Ç¶„Ç∂„ÅßÈñã„Åè
              console.log('üîó Opening Slack OAuth in browser:', data.url);
              exec(`open "${data.url}"`);
              
              return res.json({
                success: true,
                result: '„Éñ„É©„Ç¶„Ç∂„ÅßSlack„ÅÆË™çË®ºÁîªÈù¢„ÇíÈñã„Åç„Åæ„Åó„Åü„ÄÇ„ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶Ë®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
              });
            } catch (error) {
              console.error('Failed to open Slack OAuth:', error);
              return res.json({
                success: false,
                error: 'SlackË™çË®º„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ'
              });
            }
            
          case 'think_with_claude':
            // ‰∏¶ÂàóÂÆüË°å„ÅßParentAgent„Å´Âá¶ÁêÜ„ÇíÂßîË≠≤
            try {
              // DesktopÁâà„Åß„Éà„Éº„ÇØ„É≥„ÇíÂèñÂæó
              if (process.env.DESKTOP_MODE === 'true' && !process.env.SLACK_BOT_TOKEN && this.currentUserId) {
                try {
                  console.log('üîë Fetching Slack tokens for Desktop mode...');
                  const tokenResponse = await fetch(`http://localhost:${PORTS.OAUTH_CALLBACK}/api/tools/slack`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      action: 'getTokens',
                      arguments: {},
                      userId: this.currentUserId
                    })
                  });
                  const data = await tokenResponse.json();
                  if (data.bot_token) {
                    process.env.SLACK_BOT_TOKEN = data.bot_token;
                    process.env.SLACK_USER_TOKEN = data.user_token || '';
                    console.log('‚úÖ Slack tokens set in environment variables');
                  } else {
                    console.log('‚ö†Ô∏è No Slack tokens found for user');
                  }
                } catch (error) {
                  console.error('Failed to fetch tokens:', error);
                }
              }
              
              // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
              if (this.isDuplicateTask(args.task)) {
                this.broadcast({ 
                  type: 'duplicate_detected', 
                  message: '„Åù„ÅÆ‰æùÈ†º„ÅØÊó¢„Å´ÂÆüË°å‰∏≠„Åß„Åô„ÄÇÂ∞ë„ÄÖ„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ' 
                });
                return res.json({
                  success: true,
                  result: {
                    response: '„Åù„ÅÆ‰æùÈ†º„ÅØÊó¢„Å´ÂÆüË°å‰∏≠„Åß„Åô„ÄÇÂ∞ë„ÄÖ„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇ',
                    duplicate: true
                  }
                });
              }
              
              // STATUS_UPDATEÂæÖÊ©ü‰∏≠„ÅÆWorker„Å∏„ÅÆÂøúÁ≠îËª¢ÈÄÅ
              if (this.waitingForUserResponse && this.pendingWorkerId) {
                console.log(`üì® Forwarding user response to worker: ${this.pendingWorkerId}`);
                this.parentAgent.sendUserResponseToWorker(args.task);
                this.waitingForUserResponse = false;
                this.pendingWorkerId = null;
                return res.json({
                  success: true,
                  result: { response: '„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„ÇíÈÄÅ‰ø°„Åó„Åæ„Åó„Åü' }
                });
              }
              
              console.log(`üöÄ Starting parallel task: ${args.task}`);
              this.broadcast({ type: 'task_started', task: args.task });
              
              // ParentAgent„Åß„Çø„Çπ„ÇØ„Çí‰∏¶ÂàóÂÆüË°å
              const result = await this.parentAgent.executeTask({
                id: Date.now().toString(),
                originalRequest: args.task,
                context: args.context || '',
                userId: this.currentUserId || 'desktop-user' // Ë™çË®ºÊ∏à„Åø„É¶„Éº„Ç∂„ÉºID„Çí‰ΩøÁî®
              });
              
              console.log(`‚úÖ Parallel task completed: ${args.task}`);
              this.broadcast({ type: 'task_completed', task: args.task });
              
              return res.json({
                success: true,
                result: {
                  response: result.output || '„Çø„Çπ„ÇØ„ÇíÂÆå‰∫Ü„Åó„Åæ„Åó„Åü',
                  toolsUsed: result.metadata?.toolsUsed || [],
                  generatedFiles: result.metadata?.generatedFiles || []
                }
              });
            } catch (error) {
              console.error('Parallel execution error:', error);
              return res.status(500).json({
                error: error instanceof Error ? error.message : 'Parallel execution failed'
              });
            }
            
          case 'slack_send_message':
          case 'slack_get_channel_history':
          case 'slack_add_reaction':
          case 'slack_reply_to_thread':
          case 'slack_list_channels':
          case 'slack_get_thread_replies':
            // Slack API„Éó„É≠„Ç≠„Ç∑ÁµåÁî±„ÅßÂÆüË°å
            try {
              // „Éá„Éê„ÉÉ„Ç∞: Âèó‰ø°„Åó„ÅüÂºïÊï∞„ÇíË°®Á§∫
              console.log(`üîç ${toolName} args:`, JSON.stringify(args, null, 2));
              
              let slackAction = toolName.replace('slack_', ''); // slack_send_message ‚Üí send_message
              // slack_reply_to_thread„ÅÆÂ†¥Âêà„ÅØsend_message„Å´„Éû„ÉÉ„Éî„É≥„Ç∞
              if (slackAction === 'reply_to_thread') {
                slackAction = 'send_message';
                // thread_ts„ÅåÂøÖÈ†à„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç
                if (!args.thread_ts) {
                  return res.status(400).json({ error: 'thread_ts is required for reply_to_thread' });
                }
                console.log('üîç slack_reply_to_thread mapped to send_message with thread_ts:', args.thread_ts);
              }
              const response = await fetch(`http://localhost:${PORTS.OAUTH_CALLBACK}/api/tools/slack`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  action: slackAction,
                  arguments: args,
                  userId: this.currentUserId
                })
              });

              const data = await response.json();
              
              // thread_ts„ÇíÂê´„ÇÄ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËá™ÂãïÁöÑ„Å´Ë®òÊÜ∂
              if (toolName === 'slack_get_channel_history' && data.result?.messages) {
                data.result.messages.forEach((msg: any) => {
                  if (msg.ts && msg.text) {
                    this.slackThreadContext.set(`${args.channel}_${msg.ts}`, {
                      channel: args.channel,
                      thread_ts: msg.ts,
                      original_text: msg.text,
                      timestamp: Date.now()
                    });
                    console.log(`üìå Memorized thread context: ${args.channel}_${msg.ts}`);
                  }
                });
              }

              // slack_reply_to_threadÂÆüË°åÊôÇ„Å´Ë®òÊÜ∂„Åó„Åüthread_ts„Çí‰ΩøÁî®
              if (toolName === 'slack_reply_to_thread' && args.thread_ts) {
                const contextKey = `${args.channel}_${args.thread_ts}`;
                const context = this.slackThreadContext.get(contextKey);
                if (context) {
                  console.log(`‚úÖ Using memorized thread_ts: ${context.thread_ts}`);
                }
              }
              
              return res.json({
                success: true,
                result: data.result || data
              });
            } catch (error) {
              console.error(`Slack tool error:`, error);
              return res.status(500).json({ error: `Slack tool failed: ${error instanceof Error ? error.message : 'Unknown error'}` });
            }

          case 'read_file':
            try {
              const filePath = path.join(os.homedir(), '.anicca', args.path);
              const content = fs.readFileSync(filePath, 'utf8');
              return res.json({
                success: true,
                result: content
              });
            } catch (error) {
              return res.status(500).json({ error: `Failed to read file: ${error instanceof Error ? error.message : 'Unknown error'}` });
            }

          case 'write_file':
            try {
              const filePath = path.join(os.homedir(), '.anicca', args.path);
              const dir = path.dirname(filePath);
              if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
              }
              fs.writeFileSync(filePath, args.content, 'utf8');
              return res.json({
                success: true,
                result: 'File written successfully'
              });
            } catch (error) {
              return res.status(500).json({ error: `Failed to write file: ${error instanceof Error ? error.message : 'Unknown error'}` });
            }
            
          default:
            return res.status(400).json({ error: 'Unknown tool' });
        }
        
        // Only process hackernews and exa here
        if (toolName !== 'get_hacker_news_stories' && toolName !== 'search_exa') {
          return;
        }
        
        // Call the appropriate API
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        if (!response.ok) {
          throw new Error(result.error || 'API error');
        }
        
        res.json({
          success: true,
          result: result
        });
        
      } catch (error) {
        console.error('Tool proxy error:', error);
        return res.status(500).json({
          error: error instanceof Error ? error.message : 'Internal error'
        });
      }
    });

    // Task status endpoint
    this.app.get('/task-status', (req, res) => {
      if (this.taskState.isExecuting) {
        const elapsed = Date.now() - (this.taskState.startedAt || 0);
        const elapsedSeconds = Math.floor(elapsed / 1000);
        res.json({
          isExecuting: true,
          currentTask: this.taskState.currentTask,
          elapsedSeconds: elapsedSeconds
        });
      } else {
        res.json({
          isExecuting: false,
          currentTask: null,
          elapsedSeconds: 0
        });
      }
    });

    // Health check
    this.app.get('/health', (req, res) => {
      res.json({ status: 'ok' });
    });

    // Auth complete endpoint - receives tokens from callback page
    this.app.post('/auth/complete', async (req, res) => {
      try {
        const { access_token, refresh_token, expires_at } = req.body;
        console.log('üîê Received auth tokens');
        
        // Get auth service from main process
        const { getAuthService } = await import('./desktopAuthService');
        const authService = getAuthService();
        
        // Handle tokens directly
        const success = await authService.handleTokens({
          access_token,
          refresh_token,
          expires_at: parseInt(expires_at)
        });
        
        if (!success) {
          throw new Error('Failed to authenticate');
        }
        
        const user = authService.getCurrentUser();
        if (user) {
          // Update current user ID
          this.setCurrentUserId(user.id);
          console.log(`‚úÖ User authenticated: ${user.email}`);
          
          // Notify main process to update tray menu
          // Use a custom event emitter or global variable instead of process.emit
          if ((global as any).onUserAuthenticated) {
            (global as any).onUserAuthenticated(user);
          }
        }
        
        res.json({ success: true });
      } catch (error) {
        console.error('Auth complete error:', error);
        res.status(500).json({ error: 'Failed to complete authentication' });
      }
    });

    // Auth callback endpoint for Google OAuth
    this.app.get('/auth/callback', async (req, res) => {
      try {
        console.log('üì• Auth callback received');
        
        // Extract tokens from URL fragment (will be handled client-side)
        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>Ë™çË®ºÊàêÂäü - Anicca</title>
            <meta charset="utf-8">
            <style>
              body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                margin: 0;
                background: #f5f5f5;
              }
              .container {
                text-align: center;
                padding: 40px;
                background: white;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
              }
              h1 { color: #333; }
              p { color: #666; margin: 20px 0; }
              .success { color: #4CAF50; font-size: 48px; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="success">‚úÖ</div>
              <h1>Ë™çË®º„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü</h1>
              <p>„Åì„ÅÆ„Ç¶„Ç£„É≥„Éâ„Ç¶„ÅØËá™ÂãïÁöÑ„Å´Èñâ„Åò„Çâ„Çå„Åæ„Åô...</p>
            </div>
            <script>
              // Extract tokens from URL hash (Supabase uses Implicit Flow)
              const hash = window.location.hash.substring(1);
              const params = new URLSearchParams(hash);
              const accessToken = params.get('access_token');
              const refreshToken = params.get('refresh_token');
              const expiresAt = params.get('expires_at');
              
              if (accessToken && refreshToken) {
                // Send tokens to the desktop app via HTTP request
                fetch(\`http://localhost:${PORTS.OAUTH_CALLBACK}/auth/complete\`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ 
                    access_token: accessToken,
                    refresh_token: refreshToken,
                    expires_at: expiresAt
                  })
                }).then(() => {
                  setTimeout(() => window.close(), 2000);
                });
              } else {
                console.error('No tokens found in URL');
              }
            </script>
          </body>
          </html>
        `;
        
        res.setHeader('Content-Type', 'text/html; charset=utf-8');
        res.send(html);
      } catch (error) {
        console.error('Auth callback error:', error);
        res.status(500).send('Authentication error');
      }
    });

    // Slack API „Éó„É≠„Ç≠„Ç∑„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
    this.app.all('/api/tools/slack', async (req, res) => {
      try {
        const railwayUrl = `${PROXY_BASE_URL}/api/tools/slack`;
        
        // „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£„Å´userId„ÇíËøΩÂä†
        const body = {
          ...req.body,
          userId: this.currentUserId // ÁèæÂú®„ÅÆ„É¶„Éº„Ç∂„ÉºID„ÇíËøΩÂä†
        };
        
        console.log('üîÄ Proxying Slack request:', {
          userId: this.currentUserId,
          action: body.action,
          hasUserId: !!this.currentUserId
        });
        
        const response = await fetch(railwayUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(body)
        });
        
        const data = await response.json();
        
        if (!response.ok) {
          console.error('‚ùå Slack proxy error:', data);
        }
        
        res.status(response.status).json(data);
      } catch (error) {
        console.error('Slack proxy error:', error);
        res.status(500).json({ error: 'Proxy error', message: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Main page - just return JSON
    this.app.get('/', (req, res) => {
      res.json({
        status: 'ok',
        service: 'Anicca Voice Server',
        endpoints: {
          session: '/session',
          tools: '/tools/:toolName',
          taskStatus: '/task-status',
          health: '/health',
          slackProxy: '/api/tools/slack'
        }
      });
    });
  }

  /**
   * Èü≥Â£∞„Åß„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË™≠„Åø‰∏ä„Åí
   */
  private async speakMessage(message: string): Promise<void> {
    try {
      const { exec } = require('child_process');
      // „ÉÄ„Éñ„É´„ÇØ„Ç©„Éº„Éà„Çí„Ç®„Çπ„Ç±„Éº„Éó„Åó„Å¶ÂÆâÂÖ®„Å´„Ç≥„Éû„É≥„ÉâÂÆüË°å
      const escapedMessage = message.replace(/"/g, '\\"');
      exec(`say "${escapedMessage}"`);
      console.log(`üîä Speaking: ${message}`);
    } catch (error) {
      console.error('‚ùå Speech error:', error);
    }
  }

  async stop(): Promise<void> {
    console.log('üõë Stopping Voice Server...');
    
    // ParentAgent„ÅÆ„Ç∑„É£„ÉÉ„Éà„ÉÄ„Ç¶„É≥
    if (this.parentAgent && typeof this.parentAgent.shutdown === 'function') {
      await this.parentAgent.shutdown();
    }
    
    // HTTP„Çµ„Éº„Éê„Éº„ÅÆ„ÇØ„É≠„Éº„Ç∫
    if (this.httpServer) {
      this.httpServer.close();
    }
    
    // WebSocket„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆÂàáÊñ≠
    this.wsClients.forEach(ws => ws.close());
    
    console.log('‚úÖ Voice Server stopped');
  }
}